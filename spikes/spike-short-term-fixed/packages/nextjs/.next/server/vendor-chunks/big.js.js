"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/big.js";
exports.ids = ["vendor-chunks/big.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/big.js/big.mjs":
/*!*************************************!*\
  !*** ./node_modules/big.js/big.mjs ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Big: () => (/* binding */ Big),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*\r\n *  big.js v5.2.2\r\n *  A small, fast, easy-to-use library for arbitrary-precision decimal arithmetic.\r\n *  Copyright (c) 2018 Michael Mclaughlin <M8ch88l@gmail.com>\r\n *  https://github.com/MikeMcl/big.js/LICENCE\r\n */ /************************************** EDITABLE DEFAULTS *****************************************/ // The default values below must be integers within the stated ranges.\n/*\r\n   * The maximum number of decimal places (DP) of the results of operations involving division:\r\n   * div and sqrt, and pow with negative exponents.\r\n   */ var DP = 20, /*\r\n   * The rounding mode (RM) used when rounding to the above decimal places.\r\n   *\r\n   *  0  Towards zero (i.e. truncate, no rounding).       (ROUND_DOWN)\r\n   *  1  To nearest neighbour. If equidistant, round up.  (ROUND_HALF_UP)\r\n   *  2  To nearest neighbour. If equidistant, to even.   (ROUND_HALF_EVEN)\r\n   *  3  Away from zero.                                  (ROUND_UP)\r\n   */ RM = 1, // The maximum value of DP and Big.DP.\nMAX_DP = 1E6, // The maximum magnitude of the exponent argument to the pow method.\nMAX_POWER = 1E6, /*\r\n   * The negative exponent (NE) at and beneath which toString returns exponential notation.\r\n   * (JavaScript numbers: -7)\r\n   * -1000000 is the minimum recommended exponent value of a Big.\r\n   */ NE = -7, /*\r\n   * The positive exponent (PE) at and above which toString returns exponential notation.\r\n   * (JavaScript numbers: 21)\r\n   * 1000000 is the maximum recommended exponent value of a Big.\r\n   * (This limit is not enforced or checked.)\r\n   */ PE = 21, /**************************************************************************************************/ // Error messages.\nNAME = \"[big.js] \", INVALID = NAME + \"Invalid \", INVALID_DP = INVALID + \"decimal places\", INVALID_RM = INVALID + \"rounding mode\", DIV_BY_ZERO = NAME + \"Division by zero\", // The shared prototype object.\nP = {}, UNDEFINED = void 0, NUMERIC = /^-?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i;\n/*\r\n * Create and return a Big constructor.\r\n *\r\n */ function _Big_() {\n    /*\r\n   * The Big constructor and exported function.\r\n   * Create and return a new instance of a Big number object.\r\n   *\r\n   * n {number|string|Big} A numeric value.\r\n   */ function Big(n) {\n        var x = this;\n        // Enable constructor usage without new.\n        if (!(x instanceof Big)) return n === UNDEFINED ? _Big_() : new Big(n);\n        // Duplicate.\n        if (n instanceof Big) {\n            x.s = n.s;\n            x.e = n.e;\n            x.c = n.c.slice();\n        } else {\n            parse(x, n);\n        }\n        /*\r\n     * Retain a reference to this Big constructor, and shadow Big.prototype.constructor which\r\n     * points to Object.\r\n     */ x.constructor = Big;\n    }\n    Big.prototype = P;\n    Big.DP = DP;\n    Big.RM = RM;\n    Big.NE = NE;\n    Big.PE = PE;\n    Big.version = \"5.2.2\";\n    return Big;\n}\n/*\r\n * Parse the number or string value passed to a Big constructor.\r\n *\r\n * x {Big} A Big number instance.\r\n * n {number|string} A numeric value.\r\n */ function parse(x, n) {\n    var e, i, nl;\n    // Minus zero?\n    if (n === 0 && 1 / n < 0) n = \"-0\";\n    else if (!NUMERIC.test(n += \"\")) throw Error(INVALID + \"number\");\n    // Determine sign.\n    x.s = n.charAt(0) == \"-\" ? (n = n.slice(1), -1) : 1;\n    // Decimal point?\n    if ((e = n.indexOf(\".\")) > -1) n = n.replace(\".\", \"\");\n    // Exponential form?\n    if ((i = n.search(/e/i)) > 0) {\n        // Determine exponent.\n        if (e < 0) e = i;\n        e += +n.slice(i + 1);\n        n = n.substring(0, i);\n    } else if (e < 0) {\n        // Integer.\n        e = n.length;\n    }\n    nl = n.length;\n    // Determine leading zeros.\n    for(i = 0; i < nl && n.charAt(i) == \"0\";)++i;\n    if (i == nl) {\n        // Zero.\n        x.c = [\n            x.e = 0\n        ];\n    } else {\n        // Determine trailing zeros.\n        for(; nl > 0 && n.charAt(--nl) == \"0\";);\n        x.e = e - i - 1;\n        x.c = [];\n        // Convert string to array of digits without leading/trailing zeros.\n        for(e = 0; i <= nl;)x.c[e++] = +n.charAt(i++);\n    }\n    return x;\n}\n/*\r\n * Round Big x to a maximum of dp decimal places using rounding mode rm.\r\n * Called by stringify, P.div, P.round and P.sqrt.\r\n *\r\n * x {Big} The Big to round.\r\n * dp {number} Integer, 0 to MAX_DP inclusive.\r\n * rm {number} 0, 1, 2 or 3 (DOWN, HALF_UP, HALF_EVEN, UP)\r\n * [more] {boolean} Whether the result of division was truncated.\r\n */ function round(x, dp, rm, more) {\n    var xc = x.c, i = x.e + dp + 1;\n    if (i < xc.length) {\n        if (rm === 1) {\n            // xc[i] is the digit after the digit that may be rounded up.\n            more = xc[i] >= 5;\n        } else if (rm === 2) {\n            more = xc[i] > 5 || xc[i] == 5 && (more || i < 0 || xc[i + 1] !== UNDEFINED || xc[i - 1] & 1);\n        } else if (rm === 3) {\n            more = more || !!xc[0];\n        } else {\n            more = false;\n            if (rm !== 0) throw Error(INVALID_RM);\n        }\n        if (i < 1) {\n            xc.length = 1;\n            if (more) {\n                // 1, 0.1, 0.01, 0.001, 0.0001 etc.\n                x.e = -dp;\n                xc[0] = 1;\n            } else {\n                // Zero.\n                xc[0] = x.e = 0;\n            }\n        } else {\n            // Remove any digits after the required decimal places.\n            xc.length = i--;\n            // Round up?\n            if (more) {\n                // Rounding up may mean the previous digit has to be rounded up.\n                for(; ++xc[i] > 9;){\n                    xc[i] = 0;\n                    if (!i--) {\n                        ++x.e;\n                        xc.unshift(1);\n                    }\n                }\n            }\n            // Remove trailing zeros.\n            for(i = xc.length; !xc[--i];)xc.pop();\n        }\n    } else if (rm < 0 || rm > 3 || rm !== ~~rm) {\n        throw Error(INVALID_RM);\n    }\n    return x;\n}\n/*\r\n * Return a string representing the value of Big x in normal or exponential notation.\r\n * Handles P.toExponential, P.toFixed, P.toJSON, P.toPrecision, P.toString and P.valueOf.\r\n *\r\n * x {Big}\r\n * id? {number} Caller id.\r\n *         1 toExponential\r\n *         2 toFixed\r\n *         3 toPrecision\r\n *         4 valueOf\r\n * n? {number|undefined} Caller's argument.\r\n * k? {number|undefined}\r\n */ function stringify(x, id, n, k) {\n    var e, s, Big = x.constructor, z = !x.c[0];\n    if (n !== UNDEFINED) {\n        if (n !== ~~n || n < (id == 3) || n > MAX_DP) {\n            throw Error(id == 3 ? INVALID + \"precision\" : INVALID_DP);\n        }\n        x = new Big(x);\n        // The index of the digit that may be rounded up.\n        n = k - x.e;\n        // Round?\n        if (x.c.length > ++k) round(x, n, Big.RM);\n        // toFixed: recalculate k as x.e may have changed if value rounded up.\n        if (id == 2) k = x.e + n + 1;\n        // Append zeros?\n        for(; x.c.length < k;)x.c.push(0);\n    }\n    e = x.e;\n    s = x.c.join(\"\");\n    n = s.length;\n    // Exponential notation?\n    if (id != 2 && (id == 1 || id == 3 && k <= e || e <= Big.NE || e >= Big.PE)) {\n        s = s.charAt(0) + (n > 1 ? \".\" + s.slice(1) : \"\") + (e < 0 ? \"e\" : \"e+\") + e;\n    // Normal notation.\n    } else if (e < 0) {\n        for(; ++e;)s = \"0\" + s;\n        s = \"0.\" + s;\n    } else if (e > 0) {\n        if (++e > n) for(e -= n; e--;)s += \"0\";\n        else if (e < n) s = s.slice(0, e) + \".\" + s.slice(e);\n    } else if (n > 1) {\n        s = s.charAt(0) + \".\" + s.slice(1);\n    }\n    return x.s < 0 && (!z || id == 4) ? \"-\" + s : s;\n}\n// Prototype/instance methods\n/*\r\n * Return a new Big whose value is the absolute value of this Big.\r\n */ P.abs = function() {\n    var x = new this.constructor(this);\n    x.s = 1;\n    return x;\n};\n/*\r\n * Return 1 if the value of this Big is greater than the value of Big y,\r\n *       -1 if the value of this Big is less than the value of Big y, or\r\n *        0 if they have the same value.\r\n*/ P.cmp = function(y) {\n    var isneg, x = this, xc = x.c, yc = (y = new x.constructor(y)).c, i = x.s, j = y.s, k = x.e, l = y.e;\n    // Either zero?\n    if (!xc[0] || !yc[0]) return !xc[0] ? !yc[0] ? 0 : -j : i;\n    // Signs differ?\n    if (i != j) return i;\n    isneg = i < 0;\n    // Compare exponents.\n    if (k != l) return k > l ^ isneg ? 1 : -1;\n    j = (k = xc.length) < (l = yc.length) ? k : l;\n    // Compare digit by digit.\n    for(i = -1; ++i < j;){\n        if (xc[i] != yc[i]) return xc[i] > yc[i] ^ isneg ? 1 : -1;\n    }\n    // Compare lengths.\n    return k == l ? 0 : k > l ^ isneg ? 1 : -1;\n};\n/*\r\n * Return a new Big whose value is the value of this Big divided by the value of Big y, rounded,\r\n * if necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.\r\n */ P.div = function(y) {\n    var x = this, Big = x.constructor, a = x.c, b = (y = new Big(y)).c, k = x.s == y.s ? 1 : -1, dp = Big.DP;\n    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) throw Error(INVALID_DP);\n    // Divisor is zero?\n    if (!b[0]) throw Error(DIV_BY_ZERO);\n    // Dividend is 0? Return +-0.\n    if (!a[0]) return new Big(k * 0);\n    var bl, bt, n, cmp, ri, bz = b.slice(), ai = bl = b.length, al = a.length, r = a.slice(0, bl), rl = r.length, q = y, qc = q.c = [], qi = 0, d = dp + (q.e = x.e - y.e) + 1; // number of digits of the result\n    q.s = k;\n    k = d < 0 ? 0 : d;\n    // Create version of divisor with leading zero.\n    bz.unshift(0);\n    // Add zeros to make remainder as long as divisor.\n    for(; rl++ < bl;)r.push(0);\n    do {\n        // n is how many times the divisor goes into current remainder.\n        for(n = 0; n < 10; n++){\n            // Compare divisor and remainder.\n            if (bl != (rl = r.length)) {\n                cmp = bl > rl ? 1 : -1;\n            } else {\n                for(ri = -1, cmp = 0; ++ri < bl;){\n                    if (b[ri] != r[ri]) {\n                        cmp = b[ri] > r[ri] ? 1 : -1;\n                        break;\n                    }\n                }\n            }\n            // If divisor < remainder, subtract divisor from remainder.\n            if (cmp < 0) {\n                // Remainder can't be more than 1 digit longer than divisor.\n                // Equalise lengths using divisor with extra leading zero?\n                for(bt = rl == bl ? b : bz; rl;){\n                    if (r[--rl] < bt[rl]) {\n                        ri = rl;\n                        for(; ri && !r[--ri];)r[ri] = 9;\n                        --r[ri];\n                        r[rl] += 10;\n                    }\n                    r[rl] -= bt[rl];\n                }\n                for(; !r[0];)r.shift();\n            } else {\n                break;\n            }\n        }\n        // Add the digit n to the result array.\n        qc[qi++] = cmp ? n : ++n;\n        // Update the remainder.\n        if (r[0] && cmp) r[rl] = a[ai] || 0;\n        else r = [\n            a[ai]\n        ];\n    }while ((ai++ < al || r[0] !== UNDEFINED) && k--);\n    // Leading zero? Do not remove if result is simply zero (qi == 1).\n    if (!qc[0] && qi != 1) {\n        // There can't be more than one zero.\n        qc.shift();\n        q.e--;\n    }\n    // Round?\n    if (qi > d) round(q, dp, Big.RM, r[0] !== UNDEFINED);\n    return q;\n};\n/*\r\n * Return true if the value of this Big is equal to the value of Big y, otherwise return false.\r\n */ P.eq = function(y) {\n    return !this.cmp(y);\n};\n/*\r\n * Return true if the value of this Big is greater than the value of Big y, otherwise return\r\n * false.\r\n */ P.gt = function(y) {\n    return this.cmp(y) > 0;\n};\n/*\r\n * Return true if the value of this Big is greater than or equal to the value of Big y, otherwise\r\n * return false.\r\n */ P.gte = function(y) {\n    return this.cmp(y) > -1;\n};\n/*\r\n * Return true if the value of this Big is less than the value of Big y, otherwise return false.\r\n */ P.lt = function(y) {\n    return this.cmp(y) < 0;\n};\n/*\r\n * Return true if the value of this Big is less than or equal to the value of Big y, otherwise\r\n * return false.\r\n */ P.lte = function(y) {\n    return this.cmp(y) < 1;\n};\n/*\r\n * Return a new Big whose value is the value of this Big minus the value of Big y.\r\n */ P.minus = P.sub = function(y) {\n    var i, j, t, xlty, x = this, Big = x.constructor, a = x.s, b = (y = new Big(y)).s;\n    // Signs differ?\n    if (a != b) {\n        y.s = -b;\n        return x.plus(y);\n    }\n    var xc = x.c.slice(), xe = x.e, yc = y.c, ye = y.e;\n    // Either zero?\n    if (!xc[0] || !yc[0]) {\n        // y is non-zero? x is non-zero? Or both are zero.\n        return yc[0] ? (y.s = -b, y) : new Big(xc[0] ? x : 0);\n    }\n    // Determine which is the bigger number. Prepend zeros to equalise exponents.\n    if (a = xe - ye) {\n        if (xlty = a < 0) {\n            a = -a;\n            t = xc;\n        } else {\n            ye = xe;\n            t = yc;\n        }\n        t.reverse();\n        for(b = a; b--;)t.push(0);\n        t.reverse();\n    } else {\n        // Exponents equal. Check digit by digit.\n        j = ((xlty = xc.length < yc.length) ? xc : yc).length;\n        for(a = b = 0; b < j; b++){\n            if (xc[b] != yc[b]) {\n                xlty = xc[b] < yc[b];\n                break;\n            }\n        }\n    }\n    // x < y? Point xc to the array of the bigger number.\n    if (xlty) {\n        t = xc;\n        xc = yc;\n        yc = t;\n        y.s = -y.s;\n    }\n    /*\r\n   * Append zeros to xc if shorter. No need to add zeros to yc if shorter as subtraction only\r\n   * needs to start at yc.length.\r\n   */ if ((b = (j = yc.length) - (i = xc.length)) > 0) for(; b--;)xc[i++] = 0;\n    // Subtract yc from xc.\n    for(b = i; j > a;){\n        if (xc[--j] < yc[j]) {\n            for(i = j; i && !xc[--i];)xc[i] = 9;\n            --xc[i];\n            xc[j] += 10;\n        }\n        xc[j] -= yc[j];\n    }\n    // Remove trailing zeros.\n    for(; xc[--b] === 0;)xc.pop();\n    // Remove leading zeros and adjust exponent accordingly.\n    for(; xc[0] === 0;){\n        xc.shift();\n        --ye;\n    }\n    if (!xc[0]) {\n        // n - n = +0\n        y.s = 1;\n        // Result must be zero.\n        xc = [\n            ye = 0\n        ];\n    }\n    y.c = xc;\n    y.e = ye;\n    return y;\n};\n/*\r\n * Return a new Big whose value is the value of this Big modulo the value of Big y.\r\n */ P.mod = function(y) {\n    var ygtx, x = this, Big = x.constructor, a = x.s, b = (y = new Big(y)).s;\n    if (!y.c[0]) throw Error(DIV_BY_ZERO);\n    x.s = y.s = 1;\n    ygtx = y.cmp(x) == 1;\n    x.s = a;\n    y.s = b;\n    if (ygtx) return new Big(x);\n    a = Big.DP;\n    b = Big.RM;\n    Big.DP = Big.RM = 0;\n    x = x.div(y);\n    Big.DP = a;\n    Big.RM = b;\n    return this.minus(x.times(y));\n};\n/*\r\n * Return a new Big whose value is the value of this Big plus the value of Big y.\r\n */ P.plus = P.add = function(y) {\n    var t, x = this, Big = x.constructor, a = x.s, b = (y = new Big(y)).s;\n    // Signs differ?\n    if (a != b) {\n        y.s = -b;\n        return x.minus(y);\n    }\n    var xe = x.e, xc = x.c, ye = y.e, yc = y.c;\n    // Either zero? y is non-zero? x is non-zero? Or both are zero.\n    if (!xc[0] || !yc[0]) return yc[0] ? y : new Big(xc[0] ? x : a * 0);\n    xc = xc.slice();\n    // Prepend zeros to equalise exponents.\n    // Note: reverse faster than unshifts.\n    if (a = xe - ye) {\n        if (a > 0) {\n            ye = xe;\n            t = yc;\n        } else {\n            a = -a;\n            t = xc;\n        }\n        t.reverse();\n        for(; a--;)t.push(0);\n        t.reverse();\n    }\n    // Point xc to the longer array.\n    if (xc.length - yc.length < 0) {\n        t = yc;\n        yc = xc;\n        xc = t;\n    }\n    a = yc.length;\n    // Only start adding at yc.length - 1 as the further digits of xc can be left as they are.\n    for(b = 0; a; xc[a] %= 10)b = (xc[--a] = xc[a] + yc[a] + b) / 10 | 0;\n    // No need to check for zero, as +x + +y != 0 && -x + -y != 0\n    if (b) {\n        xc.unshift(b);\n        ++ye;\n    }\n    // Remove trailing zeros.\n    for(a = xc.length; xc[--a] === 0;)xc.pop();\n    y.c = xc;\n    y.e = ye;\n    return y;\n};\n/*\r\n * Return a Big whose value is the value of this Big raised to the power n.\r\n * If n is negative, round to a maximum of Big.DP decimal places using rounding\r\n * mode Big.RM.\r\n *\r\n * n {number} Integer, -MAX_POWER to MAX_POWER inclusive.\r\n */ P.pow = function(n) {\n    var x = this, one = new x.constructor(1), y = one, isneg = n < 0;\n    if (n !== ~~n || n < -MAX_POWER || n > MAX_POWER) throw Error(INVALID + \"exponent\");\n    if (isneg) n = -n;\n    for(;;){\n        if (n & 1) y = y.times(x);\n        n >>= 1;\n        if (!n) break;\n        x = x.times(x);\n    }\n    return isneg ? one.div(y) : y;\n};\n/*\r\n * Return a new Big whose value is the value of this Big rounded using rounding mode rm\r\n * to a maximum of dp decimal places, or, if dp is negative, to an integer which is a\r\n * multiple of 10**-dp.\r\n * If dp is not specified, round to 0 decimal places.\r\n * If rm is not specified, use Big.RM.\r\n *\r\n * dp? {number} Integer, -MAX_DP to MAX_DP inclusive.\r\n * rm? 0, 1, 2 or 3 (ROUND_DOWN, ROUND_HALF_UP, ROUND_HALF_EVEN, ROUND_UP)\r\n */ P.round = function(dp, rm) {\n    var Big = this.constructor;\n    if (dp === UNDEFINED) dp = 0;\n    else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP) throw Error(INVALID_DP);\n    return round(new Big(this), dp, rm === UNDEFINED ? Big.RM : rm);\n};\n/*\r\n * Return a new Big whose value is the square root of the value of this Big, rounded, if\r\n * necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.\r\n */ P.sqrt = function() {\n    var r, c, t, x = this, Big = x.constructor, s = x.s, e = x.e, half = new Big(0.5);\n    // Zero?\n    if (!x.c[0]) return new Big(x);\n    // Negative?\n    if (s < 0) throw Error(NAME + \"No square root\");\n    // Estimate.\n    s = Math.sqrt(x + \"\");\n    // Math.sqrt underflow/overflow?\n    // Re-estimate: pass x coefficient to Math.sqrt as integer, then adjust the result exponent.\n    if (s === 0 || s === 1 / 0) {\n        c = x.c.join(\"\");\n        if (!(c.length + e & 1)) c += \"0\";\n        s = Math.sqrt(c);\n        e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);\n        r = new Big((s == 1 / 0 ? \"1e\" : (s = s.toExponential()).slice(0, s.indexOf(\"e\") + 1)) + e);\n    } else {\n        r = new Big(s);\n    }\n    e = r.e + (Big.DP += 4);\n    // Newton-Raphson iteration.\n    do {\n        t = r;\n        r = half.times(t.plus(x.div(t)));\n    }while (t.c.slice(0, e).join(\"\") !== r.c.slice(0, e).join(\"\"));\n    return round(r, Big.DP -= 4, Big.RM);\n};\n/*\r\n * Return a new Big whose value is the value of this Big times the value of Big y.\r\n */ P.times = P.mul = function(y) {\n    var c, x = this, Big = x.constructor, xc = x.c, yc = (y = new Big(y)).c, a = xc.length, b = yc.length, i = x.e, j = y.e;\n    // Determine sign of result.\n    y.s = x.s == y.s ? 1 : -1;\n    // Return signed 0 if either 0.\n    if (!xc[0] || !yc[0]) return new Big(y.s * 0);\n    // Initialise exponent of result as x.e + y.e.\n    y.e = i + j;\n    // If array xc has fewer digits than yc, swap xc and yc, and lengths.\n    if (a < b) {\n        c = xc;\n        xc = yc;\n        yc = c;\n        j = a;\n        a = b;\n        b = j;\n    }\n    // Initialise coefficient array of result with zeros.\n    for(c = new Array(j = a + b); j--;)c[j] = 0;\n    // Multiply.\n    // i is initially xc.length.\n    for(i = b; i--;){\n        b = 0;\n        // a is yc.length.\n        for(j = a + i; j > i;){\n            // Current sum of products at this digit position, plus carry.\n            b = c[j] + yc[i] * xc[j - i - 1] + b;\n            c[j--] = b % 10;\n            // carry\n            b = b / 10 | 0;\n        }\n        c[j] = (c[j] + b) % 10;\n    }\n    // Increment result exponent if there is a final carry, otherwise remove leading zero.\n    if (b) ++y.e;\n    else c.shift();\n    // Remove trailing zeros.\n    for(i = c.length; !c[--i];)c.pop();\n    y.c = c;\n    return y;\n};\n/*\r\n * Return a string representing the value of this Big in exponential notation to dp fixed decimal\r\n * places and rounded using Big.RM.\r\n *\r\n * dp? {number} Integer, 0 to MAX_DP inclusive.\r\n */ P.toExponential = function(dp) {\n    return stringify(this, 1, dp, dp);\n};\n/*\r\n * Return a string representing the value of this Big in normal notation to dp fixed decimal\r\n * places and rounded using Big.RM.\r\n *\r\n * dp? {number} Integer, 0 to MAX_DP inclusive.\r\n *\r\n * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.\r\n * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.\r\n */ P.toFixed = function(dp) {\n    return stringify(this, 2, dp, this.e + dp);\n};\n/*\r\n * Return a string representing the value of this Big rounded to sd significant digits using\r\n * Big.RM. Use exponential notation if sd is less than the number of digits necessary to represent\r\n * the integer part of the value in normal notation.\r\n *\r\n * sd {number} Integer, 1 to MAX_DP inclusive.\r\n */ P.toPrecision = function(sd) {\n    return stringify(this, 3, sd, sd - 1);\n};\n/*\r\n * Return a string representing the value of this Big.\r\n * Return exponential notation if this Big has a positive exponent equal to or greater than\r\n * Big.PE, or a negative exponent equal to or less than Big.NE.\r\n * Omit the sign for negative zero.\r\n */ P.toString = function() {\n    return stringify(this);\n};\n/*\r\n * Return a string representing the value of this Big.\r\n * Return exponential notation if this Big has a positive exponent equal to or greater than\r\n * Big.PE, or a negative exponent equal to or less than Big.NE.\r\n * Include the sign for negative zero.\r\n */ P.valueOf = P.toJSON = function() {\n    return stringify(this, 4);\n};\n// Export\nvar Big = _Big_();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Big);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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cy9iaWcuanMvYmlnLm1qcz9lYjc2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiAqICBiaWcuanMgdjUuMi4yXHJcbiAqICBBIHNtYWxsLCBmYXN0LCBlYXN5LXRvLXVzZSBsaWJyYXJ5IGZvciBhcmJpdHJhcnktcHJlY2lzaW9uIGRlY2ltYWwgYXJpdGhtZXRpYy5cclxuICogIENvcHlyaWdodCAoYykgMjAxOCBNaWNoYWVsIE1jbGF1Z2hsaW4gPE04Y2g4OGxAZ21haWwuY29tPlxyXG4gKiAgaHR0cHM6Ly9naXRodWIuY29tL01pa2VNY2wvYmlnLmpzL0xJQ0VOQ0VcclxuICovXHJcblxyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIEVESVRBQkxFIERFRkFVTFRTICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuXHJcbiAgLy8gVGhlIGRlZmF1bHQgdmFsdWVzIGJlbG93IG11c3QgYmUgaW50ZWdlcnMgd2l0aGluIHRoZSBzdGF0ZWQgcmFuZ2VzLlxyXG5cclxuICAvKlxyXG4gICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyAoRFApIG9mIHRoZSByZXN1bHRzIG9mIG9wZXJhdGlvbnMgaW52b2x2aW5nIGRpdmlzaW9uOlxyXG4gICAqIGRpdiBhbmQgc3FydCwgYW5kIHBvdyB3aXRoIG5lZ2F0aXZlIGV4cG9uZW50cy5cclxuICAgKi9cclxudmFyIERQID0gMjAsICAgICAgICAgIC8vIDAgdG8gTUFYX0RQXHJcblxyXG4gIC8qXHJcbiAgICogVGhlIHJvdW5kaW5nIG1vZGUgKFJNKSB1c2VkIHdoZW4gcm91bmRpbmcgdG8gdGhlIGFib3ZlIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAqXHJcbiAgICogIDAgIFRvd2FyZHMgemVybyAoaS5lLiB0cnVuY2F0ZSwgbm8gcm91bmRpbmcpLiAgICAgICAoUk9VTkRfRE9XTilcclxuICAgKiAgMSAgVG8gbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCByb3VuZCB1cC4gIChST1VORF9IQUxGX1VQKVxyXG4gICAqICAyICBUbyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvIGV2ZW4uICAgKFJPVU5EX0hBTEZfRVZFTilcclxuICAgKiAgMyAgQXdheSBmcm9tIHplcm8uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChST1VORF9VUClcclxuICAgKi9cclxuICBSTSA9IDEsICAgICAgICAgICAgIC8vIDAsIDEsIDIgb3IgM1xyXG5cclxuICAvLyBUaGUgbWF4aW11bSB2YWx1ZSBvZiBEUCBhbmQgQmlnLkRQLlxyXG4gIE1BWF9EUCA9IDFFNiwgICAgICAgLy8gMCB0byAxMDAwMDAwXHJcblxyXG4gIC8vIFRoZSBtYXhpbXVtIG1hZ25pdHVkZSBvZiB0aGUgZXhwb25lbnQgYXJndW1lbnQgdG8gdGhlIHBvdyBtZXRob2QuXHJcbiAgTUFYX1BPV0VSID0gMUU2LCAgICAvLyAxIHRvIDEwMDAwMDBcclxuXHJcbiAgLypcclxuICAgKiBUaGUgbmVnYXRpdmUgZXhwb25lbnQgKE5FKSBhdCBhbmQgYmVuZWF0aCB3aGljaCB0b1N0cmluZyByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAqIChKYXZhU2NyaXB0IG51bWJlcnM6IC03KVxyXG4gICAqIC0xMDAwMDAwIGlzIHRoZSBtaW5pbXVtIHJlY29tbWVuZGVkIGV4cG9uZW50IHZhbHVlIG9mIGEgQmlnLlxyXG4gICAqL1xyXG4gIE5FID0gLTcsICAgICAgICAgICAgLy8gMCB0byAtMTAwMDAwMFxyXG5cclxuICAvKlxyXG4gICAqIFRoZSBwb3NpdGl2ZSBleHBvbmVudCAoUEUpIGF0IGFuZCBhYm92ZSB3aGljaCB0b1N0cmluZyByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAqIChKYXZhU2NyaXB0IG51bWJlcnM6IDIxKVxyXG4gICAqIDEwMDAwMDAgaXMgdGhlIG1heGltdW0gcmVjb21tZW5kZWQgZXhwb25lbnQgdmFsdWUgb2YgYSBCaWcuXHJcbiAgICogKFRoaXMgbGltaXQgaXMgbm90IGVuZm9yY2VkIG9yIGNoZWNrZWQuKVxyXG4gICAqL1xyXG4gIFBFID0gMjEsICAgICAgICAgICAgLy8gMCB0byAxMDAwMDAwXHJcblxyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuXHJcbiAgLy8gRXJyb3IgbWVzc2FnZXMuXHJcbiAgTkFNRSA9ICdbYmlnLmpzXSAnLFxyXG4gIElOVkFMSUQgPSBOQU1FICsgJ0ludmFsaWQgJyxcclxuICBJTlZBTElEX0RQID0gSU5WQUxJRCArICdkZWNpbWFsIHBsYWNlcycsXHJcbiAgSU5WQUxJRF9STSA9IElOVkFMSUQgKyAncm91bmRpbmcgbW9kZScsXHJcbiAgRElWX0JZX1pFUk8gPSBOQU1FICsgJ0RpdmlzaW9uIGJ5IHplcm8nLFxyXG5cclxuICAvLyBUaGUgc2hhcmVkIHByb3RvdHlwZSBvYmplY3QuXHJcbiAgUCA9IHt9LFxyXG4gIFVOREVGSU5FRCA9IHZvaWQgMCxcclxuICBOVU1FUklDID0gL14tPyhcXGQrKFxcLlxcZCopP3xcXC5cXGQrKShlWystXT9cXGQrKT8kL2k7XHJcblxyXG5cclxuLypcclxuICogQ3JlYXRlIGFuZCByZXR1cm4gYSBCaWcgY29uc3RydWN0b3IuXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBfQmlnXygpIHtcclxuXHJcbiAgLypcclxuICAgKiBUaGUgQmlnIGNvbnN0cnVjdG9yIGFuZCBleHBvcnRlZCBmdW5jdGlvbi5cclxuICAgKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBpbnN0YW5jZSBvZiBhIEJpZyBudW1iZXIgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogbiB7bnVtYmVyfHN0cmluZ3xCaWd9IEEgbnVtZXJpYyB2YWx1ZS5cclxuICAgKi9cclxuICBmdW5jdGlvbiBCaWcobikge1xyXG4gICAgdmFyIHggPSB0aGlzO1xyXG5cclxuICAgIC8vIEVuYWJsZSBjb25zdHJ1Y3RvciB1c2FnZSB3aXRob3V0IG5ldy5cclxuICAgIGlmICghKHggaW5zdGFuY2VvZiBCaWcpKSByZXR1cm4gbiA9PT0gVU5ERUZJTkVEID8gX0JpZ18oKSA6IG5ldyBCaWcobik7XHJcblxyXG4gICAgLy8gRHVwbGljYXRlLlxyXG4gICAgaWYgKG4gaW5zdGFuY2VvZiBCaWcpIHtcclxuICAgICAgeC5zID0gbi5zO1xyXG4gICAgICB4LmUgPSBuLmU7XHJcbiAgICAgIHguYyA9IG4uYy5zbGljZSgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcGFyc2UoeCwgbik7XHJcbiAgICB9XHJcblxyXG4gICAgLypcclxuICAgICAqIFJldGFpbiBhIHJlZmVyZW5jZSB0byB0aGlzIEJpZyBjb25zdHJ1Y3RvciwgYW5kIHNoYWRvdyBCaWcucHJvdG90eXBlLmNvbnN0cnVjdG9yIHdoaWNoXHJcbiAgICAgKiBwb2ludHMgdG8gT2JqZWN0LlxyXG4gICAgICovXHJcbiAgICB4LmNvbnN0cnVjdG9yID0gQmlnO1xyXG4gIH1cclxuXHJcbiAgQmlnLnByb3RvdHlwZSA9IFA7XHJcbiAgQmlnLkRQID0gRFA7XHJcbiAgQmlnLlJNID0gUk07XHJcbiAgQmlnLk5FID0gTkU7XHJcbiAgQmlnLlBFID0gUEU7XHJcbiAgQmlnLnZlcnNpb24gPSAnNS4yLjInO1xyXG5cclxuICByZXR1cm4gQmlnO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUGFyc2UgdGhlIG51bWJlciBvciBzdHJpbmcgdmFsdWUgcGFzc2VkIHRvIGEgQmlnIGNvbnN0cnVjdG9yLlxyXG4gKlxyXG4gKiB4IHtCaWd9IEEgQmlnIG51bWJlciBpbnN0YW5jZS5cclxuICogbiB7bnVtYmVyfHN0cmluZ30gQSBudW1lcmljIHZhbHVlLlxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2UoeCwgbikge1xyXG4gIHZhciBlLCBpLCBubDtcclxuXHJcbiAgLy8gTWludXMgemVybz9cclxuICBpZiAobiA9PT0gMCAmJiAxIC8gbiA8IDApIG4gPSAnLTAnO1xyXG4gIGVsc2UgaWYgKCFOVU1FUklDLnRlc3QobiArPSAnJykpIHRocm93IEVycm9yKElOVkFMSUQgKyAnbnVtYmVyJyk7XHJcblxyXG4gIC8vIERldGVybWluZSBzaWduLlxyXG4gIHgucyA9IG4uY2hhckF0KDApID09ICctJyA/IChuID0gbi5zbGljZSgxKSwgLTEpIDogMTtcclxuXHJcbiAgLy8gRGVjaW1hbCBwb2ludD9cclxuICBpZiAoKGUgPSBuLmluZGV4T2YoJy4nKSkgPiAtMSkgbiA9IG4ucmVwbGFjZSgnLicsICcnKTtcclxuXHJcbiAgLy8gRXhwb25lbnRpYWwgZm9ybT9cclxuICBpZiAoKGkgPSBuLnNlYXJjaCgvZS9pKSkgPiAwKSB7XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIGV4cG9uZW50LlxyXG4gICAgaWYgKGUgPCAwKSBlID0gaTtcclxuICAgIGUgKz0gK24uc2xpY2UoaSArIDEpO1xyXG4gICAgbiA9IG4uc3Vic3RyaW5nKDAsIGkpO1xyXG4gIH0gZWxzZSBpZiAoZSA8IDApIHtcclxuXHJcbiAgICAvLyBJbnRlZ2VyLlxyXG4gICAgZSA9IG4ubGVuZ3RoO1xyXG4gIH1cclxuXHJcbiAgbmwgPSBuLmxlbmd0aDtcclxuXHJcbiAgLy8gRGV0ZXJtaW5lIGxlYWRpbmcgemVyb3MuXHJcbiAgZm9yIChpID0gMDsgaSA8IG5sICYmIG4uY2hhckF0KGkpID09ICcwJzspICsraTtcclxuXHJcbiAgaWYgKGkgPT0gbmwpIHtcclxuXHJcbiAgICAvLyBaZXJvLlxyXG4gICAgeC5jID0gW3guZSA9IDBdO1xyXG4gIH0gZWxzZSB7XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgZm9yICg7IG5sID4gMCAmJiBuLmNoYXJBdCgtLW5sKSA9PSAnMCc7KTtcclxuICAgIHguZSA9IGUgLSBpIC0gMTtcclxuICAgIHguYyA9IFtdO1xyXG5cclxuICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIGFycmF5IG9mIGRpZ2l0cyB3aXRob3V0IGxlYWRpbmcvdHJhaWxpbmcgemVyb3MuXHJcbiAgICBmb3IgKGUgPSAwOyBpIDw9IG5sOykgeC5jW2UrK10gPSArbi5jaGFyQXQoaSsrKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB4O1xyXG59XHJcblxyXG5cclxuLypcclxuICogUm91bmQgQmlnIHggdG8gYSBtYXhpbXVtIG9mIGRwIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0uXHJcbiAqIENhbGxlZCBieSBzdHJpbmdpZnksIFAuZGl2LCBQLnJvdW5kIGFuZCBQLnNxcnQuXHJcbiAqXHJcbiAqIHgge0JpZ30gVGhlIEJpZyB0byByb3VuZC5cclxuICogZHAge251bWJlcn0gSW50ZWdlciwgMCB0byBNQVhfRFAgaW5jbHVzaXZlLlxyXG4gKiBybSB7bnVtYmVyfSAwLCAxLCAyIG9yIDMgKERPV04sIEhBTEZfVVAsIEhBTEZfRVZFTiwgVVApXHJcbiAqIFttb3JlXSB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcmVzdWx0IG9mIGRpdmlzaW9uIHdhcyB0cnVuY2F0ZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiByb3VuZCh4LCBkcCwgcm0sIG1vcmUpIHtcclxuICB2YXIgeGMgPSB4LmMsXHJcbiAgICBpID0geC5lICsgZHAgKyAxO1xyXG5cclxuICBpZiAoaSA8IHhjLmxlbmd0aCkge1xyXG4gICAgaWYgKHJtID09PSAxKSB7XHJcblxyXG4gICAgICAvLyB4Y1tpXSBpcyB0aGUgZGlnaXQgYWZ0ZXIgdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXAuXHJcbiAgICAgIG1vcmUgPSB4Y1tpXSA+PSA1O1xyXG4gICAgfSBlbHNlIGlmIChybSA9PT0gMikge1xyXG4gICAgICBtb3JlID0geGNbaV0gPiA1IHx8IHhjW2ldID09IDUgJiZcclxuICAgICAgICAobW9yZSB8fCBpIDwgMCB8fCB4Y1tpICsgMV0gIT09IFVOREVGSU5FRCB8fCB4Y1tpIC0gMV0gJiAxKTtcclxuICAgIH0gZWxzZSBpZiAocm0gPT09IDMpIHtcclxuICAgICAgbW9yZSA9IG1vcmUgfHwgISF4Y1swXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG1vcmUgPSBmYWxzZTtcclxuICAgICAgaWYgKHJtICE9PSAwKSB0aHJvdyBFcnJvcihJTlZBTElEX1JNKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaSA8IDEpIHtcclxuICAgICAgeGMubGVuZ3RoID0gMTtcclxuXHJcbiAgICAgIGlmIChtb3JlKSB7XHJcblxyXG4gICAgICAgIC8vIDEsIDAuMSwgMC4wMSwgMC4wMDEsIDAuMDAwMSBldGMuXHJcbiAgICAgICAgeC5lID0gLWRwO1xyXG4gICAgICAgIHhjWzBdID0gMTtcclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gWmVyby5cclxuICAgICAgICB4Y1swXSA9IHguZSA9IDA7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAvLyBSZW1vdmUgYW55IGRpZ2l0cyBhZnRlciB0aGUgcmVxdWlyZWQgZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgIHhjLmxlbmd0aCA9IGktLTtcclxuXHJcbiAgICAgIC8vIFJvdW5kIHVwP1xyXG4gICAgICBpZiAobW9yZSkge1xyXG5cclxuICAgICAgICAvLyBSb3VuZGluZyB1cCBtYXkgbWVhbiB0aGUgcHJldmlvdXMgZGlnaXQgaGFzIHRvIGJlIHJvdW5kZWQgdXAuXHJcbiAgICAgICAgZm9yICg7ICsreGNbaV0gPiA5Oykge1xyXG4gICAgICAgICAgeGNbaV0gPSAwO1xyXG4gICAgICAgICAgaWYgKCFpLS0pIHtcclxuICAgICAgICAgICAgKyt4LmU7XHJcbiAgICAgICAgICAgIHhjLnVuc2hpZnQoMSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgIGZvciAoaSA9IHhjLmxlbmd0aDsgIXhjWy0taV07KSB4Yy5wb3AoKTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKHJtIDwgMCB8fCBybSA+IDMgfHwgcm0gIT09IH5+cm0pIHtcclxuICAgIHRocm93IEVycm9yKElOVkFMSURfUk0pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHg7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiBCaWcgeCBpbiBub3JtYWwgb3IgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAqIEhhbmRsZXMgUC50b0V4cG9uZW50aWFsLCBQLnRvRml4ZWQsIFAudG9KU09OLCBQLnRvUHJlY2lzaW9uLCBQLnRvU3RyaW5nIGFuZCBQLnZhbHVlT2YuXHJcbiAqXHJcbiAqIHgge0JpZ31cclxuICogaWQ/IHtudW1iZXJ9IENhbGxlciBpZC5cclxuICogICAgICAgICAxIHRvRXhwb25lbnRpYWxcclxuICogICAgICAgICAyIHRvRml4ZWRcclxuICogICAgICAgICAzIHRvUHJlY2lzaW9uXHJcbiAqICAgICAgICAgNCB2YWx1ZU9mXHJcbiAqIG4/IHtudW1iZXJ8dW5kZWZpbmVkfSBDYWxsZXIncyBhcmd1bWVudC5cclxuICogaz8ge251bWJlcnx1bmRlZmluZWR9XHJcbiAqL1xyXG5mdW5jdGlvbiBzdHJpbmdpZnkoeCwgaWQsIG4sIGspIHtcclxuICB2YXIgZSwgcyxcclxuICAgIEJpZyA9IHguY29uc3RydWN0b3IsXHJcbiAgICB6ID0gIXguY1swXTtcclxuXHJcbiAgaWYgKG4gIT09IFVOREVGSU5FRCkge1xyXG4gICAgaWYgKG4gIT09IH5+biB8fCBuIDwgKGlkID09IDMpIHx8IG4gPiBNQVhfRFApIHtcclxuICAgICAgdGhyb3cgRXJyb3IoaWQgPT0gMyA/IElOVkFMSUQgKyAncHJlY2lzaW9uJyA6IElOVkFMSURfRFApO1xyXG4gICAgfVxyXG5cclxuICAgIHggPSBuZXcgQmlnKHgpO1xyXG5cclxuICAgIC8vIFRoZSBpbmRleCBvZiB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cC5cclxuICAgIG4gPSBrIC0geC5lO1xyXG5cclxuICAgIC8vIFJvdW5kP1xyXG4gICAgaWYgKHguYy5sZW5ndGggPiArK2spIHJvdW5kKHgsIG4sIEJpZy5STSk7XHJcblxyXG4gICAgLy8gdG9GaXhlZDogcmVjYWxjdWxhdGUgayBhcyB4LmUgbWF5IGhhdmUgY2hhbmdlZCBpZiB2YWx1ZSByb3VuZGVkIHVwLlxyXG4gICAgaWYgKGlkID09IDIpIGsgPSB4LmUgKyBuICsgMTtcclxuXHJcbiAgICAvLyBBcHBlbmQgemVyb3M/XHJcbiAgICBmb3IgKDsgeC5jLmxlbmd0aCA8IGs7KSB4LmMucHVzaCgwKTtcclxuICB9XHJcblxyXG4gIGUgPSB4LmU7XHJcbiAgcyA9IHguYy5qb2luKCcnKTtcclxuICBuID0gcy5sZW5ndGg7XHJcblxyXG4gIC8vIEV4cG9uZW50aWFsIG5vdGF0aW9uP1xyXG4gIGlmIChpZCAhPSAyICYmIChpZCA9PSAxIHx8IGlkID09IDMgJiYgayA8PSBlIHx8IGUgPD0gQmlnLk5FIHx8IGUgPj0gQmlnLlBFKSkge1xyXG4gICAgcyA9IHMuY2hhckF0KDApICsgKG4gPiAxID8gJy4nICsgcy5zbGljZSgxKSA6ICcnKSArIChlIDwgMCA/ICdlJyA6ICdlKycpICsgZTtcclxuXHJcbiAgLy8gTm9ybWFsIG5vdGF0aW9uLlxyXG4gIH0gZWxzZSBpZiAoZSA8IDApIHtcclxuICAgIGZvciAoOyArK2U7KSBzID0gJzAnICsgcztcclxuICAgIHMgPSAnMC4nICsgcztcclxuICB9IGVsc2UgaWYgKGUgPiAwKSB7XHJcbiAgICBpZiAoKytlID4gbikgZm9yIChlIC09IG47IGUtLTspIHMgKz0gJzAnO1xyXG4gICAgZWxzZSBpZiAoZSA8IG4pIHMgPSBzLnNsaWNlKDAsIGUpICsgJy4nICsgcy5zbGljZShlKTtcclxuICB9IGVsc2UgaWYgKG4gPiAxKSB7XHJcbiAgICBzID0gcy5jaGFyQXQoMCkgKyAnLicgKyBzLnNsaWNlKDEpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHgucyA8IDAgJiYgKCF6IHx8IGlkID09IDQpID8gJy0nICsgcyA6IHM7XHJcbn1cclxuXHJcblxyXG4vLyBQcm90b3R5cGUvaW5zdGFuY2UgbWV0aG9kc1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBCaWcgd2hvc2UgdmFsdWUgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoaXMgQmlnLlxyXG4gKi9cclxuUC5hYnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHggPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKTtcclxuICB4LnMgPSAxO1xyXG4gIHJldHVybiB4O1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiAxIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZyBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIG9mIEJpZyB5LFxyXG4gKiAgICAgICAtMSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgaXMgbGVzcyB0aGFuIHRoZSB2YWx1ZSBvZiBCaWcgeSwgb3JcclxuICogICAgICAgIDAgaWYgdGhleSBoYXZlIHRoZSBzYW1lIHZhbHVlLlxyXG4qL1xyXG5QLmNtcCA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgdmFyIGlzbmVnLFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICB4YyA9IHguYyxcclxuICAgIHljID0gKHkgPSBuZXcgeC5jb25zdHJ1Y3Rvcih5KSkuYyxcclxuICAgIGkgPSB4LnMsXHJcbiAgICBqID0geS5zLFxyXG4gICAgayA9IHguZSxcclxuICAgIGwgPSB5LmU7XHJcblxyXG4gIC8vIEVpdGhlciB6ZXJvP1xyXG4gIGlmICgheGNbMF0gfHwgIXljWzBdKSByZXR1cm4gIXhjWzBdID8gIXljWzBdID8gMCA6IC1qIDogaTtcclxuXHJcbiAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gIGlmIChpICE9IGopIHJldHVybiBpO1xyXG5cclxuICBpc25lZyA9IGkgPCAwO1xyXG5cclxuICAvLyBDb21wYXJlIGV4cG9uZW50cy5cclxuICBpZiAoayAhPSBsKSByZXR1cm4gayA+IGwgXiBpc25lZyA/IDEgOiAtMTtcclxuXHJcbiAgaiA9IChrID0geGMubGVuZ3RoKSA8IChsID0geWMubGVuZ3RoKSA/IGsgOiBsO1xyXG5cclxuICAvLyBDb21wYXJlIGRpZ2l0IGJ5IGRpZ2l0LlxyXG4gIGZvciAoaSA9IC0xOyArK2kgPCBqOykge1xyXG4gICAgaWYgKHhjW2ldICE9IHljW2ldKSByZXR1cm4geGNbaV0gPiB5Y1tpXSBeIGlzbmVnID8gMSA6IC0xO1xyXG4gIH1cclxuXHJcbiAgLy8gQ29tcGFyZSBsZW5ndGhzLlxyXG4gIHJldHVybiBrID09IGwgPyAwIDogayA+IGwgXiBpc25lZyA/IDEgOiAtMTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgQmlnIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZyBkaXZpZGVkIGJ5IHRoZSB2YWx1ZSBvZiBCaWcgeSwgcm91bmRlZCxcclxuICogaWYgbmVjZXNzYXJ5LCB0byBhIG1heGltdW0gb2YgQmlnLkRQIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgQmlnLlJNLlxyXG4gKi9cclxuUC5kaXYgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHZhciB4ID0gdGhpcyxcclxuICAgIEJpZyA9IHguY29uc3RydWN0b3IsXHJcbiAgICBhID0geC5jLCAgICAgICAgICAgICAgICAgIC8vIGRpdmlkZW5kXHJcbiAgICBiID0gKHkgPSBuZXcgQmlnKHkpKS5jLCAgIC8vIGRpdmlzb3JcclxuICAgIGsgPSB4LnMgPT0geS5zID8gMSA6IC0xLFxyXG4gICAgZHAgPSBCaWcuRFA7XHJcblxyXG4gIGlmIChkcCAhPT0gfn5kcCB8fCBkcCA8IDAgfHwgZHAgPiBNQVhfRFApIHRocm93IEVycm9yKElOVkFMSURfRFApO1xyXG5cclxuICAvLyBEaXZpc29yIGlzIHplcm8/XHJcbiAgaWYgKCFiWzBdKSB0aHJvdyBFcnJvcihESVZfQllfWkVSTyk7XHJcblxyXG4gIC8vIERpdmlkZW5kIGlzIDA/IFJldHVybiArLTAuXHJcbiAgaWYgKCFhWzBdKSByZXR1cm4gbmV3IEJpZyhrICogMCk7XHJcblxyXG4gIHZhciBibCwgYnQsIG4sIGNtcCwgcmksXHJcbiAgICBieiA9IGIuc2xpY2UoKSxcclxuICAgIGFpID0gYmwgPSBiLmxlbmd0aCxcclxuICAgIGFsID0gYS5sZW5ndGgsXHJcbiAgICByID0gYS5zbGljZSgwLCBibCksICAgLy8gcmVtYWluZGVyXHJcbiAgICBybCA9IHIubGVuZ3RoLFxyXG4gICAgcSA9IHksICAgICAgICAgICAgICAgIC8vIHF1b3RpZW50XHJcbiAgICBxYyA9IHEuYyA9IFtdLFxyXG4gICAgcWkgPSAwLFxyXG4gICAgZCA9IGRwICsgKHEuZSA9IHguZSAtIHkuZSkgKyAxOyAgICAvLyBudW1iZXIgb2YgZGlnaXRzIG9mIHRoZSByZXN1bHRcclxuXHJcbiAgcS5zID0gaztcclxuICBrID0gZCA8IDAgPyAwIDogZDtcclxuXHJcbiAgLy8gQ3JlYXRlIHZlcnNpb24gb2YgZGl2aXNvciB3aXRoIGxlYWRpbmcgemVyby5cclxuICBiei51bnNoaWZ0KDApO1xyXG5cclxuICAvLyBBZGQgemVyb3MgdG8gbWFrZSByZW1haW5kZXIgYXMgbG9uZyBhcyBkaXZpc29yLlxyXG4gIGZvciAoOyBybCsrIDwgYmw7KSByLnB1c2goMCk7XHJcblxyXG4gIGRvIHtcclxuXHJcbiAgICAvLyBuIGlzIGhvdyBtYW55IHRpbWVzIHRoZSBkaXZpc29yIGdvZXMgaW50byBjdXJyZW50IHJlbWFpbmRlci5cclxuICAgIGZvciAobiA9IDA7IG4gPCAxMDsgbisrKSB7XHJcblxyXG4gICAgICAvLyBDb21wYXJlIGRpdmlzb3IgYW5kIHJlbWFpbmRlci5cclxuICAgICAgaWYgKGJsICE9IChybCA9IHIubGVuZ3RoKSkge1xyXG4gICAgICAgIGNtcCA9IGJsID4gcmwgPyAxIDogLTE7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZm9yIChyaSA9IC0xLCBjbXAgPSAwOyArK3JpIDwgYmw7KSB7XHJcbiAgICAgICAgICBpZiAoYltyaV0gIT0gcltyaV0pIHtcclxuICAgICAgICAgICAgY21wID0gYltyaV0gPiByW3JpXSA/IDEgOiAtMTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJZiBkaXZpc29yIDwgcmVtYWluZGVyLCBzdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLlxyXG4gICAgICBpZiAoY21wIDwgMCkge1xyXG5cclxuICAgICAgICAvLyBSZW1haW5kZXIgY2FuJ3QgYmUgbW9yZSB0aGFuIDEgZGlnaXQgbG9uZ2VyIHRoYW4gZGl2aXNvci5cclxuICAgICAgICAvLyBFcXVhbGlzZSBsZW5ndGhzIHVzaW5nIGRpdmlzb3Igd2l0aCBleHRyYSBsZWFkaW5nIHplcm8/XHJcbiAgICAgICAgZm9yIChidCA9IHJsID09IGJsID8gYiA6IGJ6OyBybDspIHtcclxuICAgICAgICAgIGlmIChyWy0tcmxdIDwgYnRbcmxdKSB7XHJcbiAgICAgICAgICAgIHJpID0gcmw7XHJcbiAgICAgICAgICAgIGZvciAoOyByaSAmJiAhclstLXJpXTspIHJbcmldID0gOTtcclxuICAgICAgICAgICAgLS1yW3JpXTtcclxuICAgICAgICAgICAgcltybF0gKz0gMTA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByW3JsXSAtPSBidFtybF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKDsgIXJbMF07KSByLnNoaWZ0KCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGQgdGhlIGRpZ2l0IG4gdG8gdGhlIHJlc3VsdCBhcnJheS5cclxuICAgIHFjW3FpKytdID0gY21wID8gbiA6ICsrbjtcclxuXHJcbiAgICAvLyBVcGRhdGUgdGhlIHJlbWFpbmRlci5cclxuICAgIGlmIChyWzBdICYmIGNtcCkgcltybF0gPSBhW2FpXSB8fCAwO1xyXG4gICAgZWxzZSByID0gW2FbYWldXTtcclxuXHJcbiAgfSB3aGlsZSAoKGFpKysgPCBhbCB8fCByWzBdICE9PSBVTkRFRklORUQpICYmIGstLSk7XHJcblxyXG4gIC8vIExlYWRpbmcgemVybz8gRG8gbm90IHJlbW92ZSBpZiByZXN1bHQgaXMgc2ltcGx5IHplcm8gKHFpID09IDEpLlxyXG4gIGlmICghcWNbMF0gJiYgcWkgIT0gMSkge1xyXG5cclxuICAgIC8vIFRoZXJlIGNhbid0IGJlIG1vcmUgdGhhbiBvbmUgemVyby5cclxuICAgIHFjLnNoaWZ0KCk7XHJcbiAgICBxLmUtLTtcclxuICB9XHJcblxyXG4gIC8vIFJvdW5kP1xyXG4gIGlmIChxaSA+IGQpIHJvdW5kKHEsIGRwLCBCaWcuUk0sIHJbMF0gIT09IFVOREVGSU5FRCk7XHJcblxyXG4gIHJldHVybiBxO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZyBpcyBlcXVhbCB0byB0aGUgdmFsdWUgb2YgQmlnIHksIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAqL1xyXG5QLmVxID0gZnVuY3Rpb24gKHkpIHtcclxuICByZXR1cm4gIXRoaXMuY21wKHkpO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZyBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIG9mIEJpZyB5LCBvdGhlcndpc2UgcmV0dXJuXHJcbiAqIGZhbHNlLlxyXG4gKi9cclxuUC5ndCA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgcmV0dXJuIHRoaXMuY21wKHkpID4gMDtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZiBCaWcgeSwgb3RoZXJ3aXNlXHJcbiAqIHJldHVybiBmYWxzZS5cclxuICovXHJcblAuZ3RlID0gZnVuY3Rpb24gKHkpIHtcclxuICByZXR1cm4gdGhpcy5jbXAoeSkgPiAtMTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgaXMgbGVzcyB0aGFuIHRoZSB2YWx1ZSBvZiBCaWcgeSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICovXHJcblAubHQgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHJldHVybiB0aGlzLmNtcCh5KSA8IDA7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgdmFsdWUgb2YgQmlnIHksIG90aGVyd2lzZVxyXG4gKiByZXR1cm4gZmFsc2UuXHJcbiAqL1xyXG5QLmx0ZSA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgcmV0dXJuIHRoaXMuY21wKHkpIDwgMTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgQmlnIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZyBtaW51cyB0aGUgdmFsdWUgb2YgQmlnIHkuXHJcbiAqL1xyXG5QLm1pbnVzID0gUC5zdWIgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHZhciBpLCBqLCB0LCB4bHR5LFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICBCaWcgPSB4LmNvbnN0cnVjdG9yLFxyXG4gICAgYSA9IHgucyxcclxuICAgIGIgPSAoeSA9IG5ldyBCaWcoeSkpLnM7XHJcblxyXG4gIC8vIFNpZ25zIGRpZmZlcj9cclxuICBpZiAoYSAhPSBiKSB7XHJcbiAgICB5LnMgPSAtYjtcclxuICAgIHJldHVybiB4LnBsdXMoeSk7XHJcbiAgfVxyXG5cclxuICB2YXIgeGMgPSB4LmMuc2xpY2UoKSxcclxuICAgIHhlID0geC5lLFxyXG4gICAgeWMgPSB5LmMsXHJcbiAgICB5ZSA9IHkuZTtcclxuXHJcbiAgLy8gRWl0aGVyIHplcm8/XHJcbiAgaWYgKCF4Y1swXSB8fCAheWNbMF0pIHtcclxuXHJcbiAgICAvLyB5IGlzIG5vbi16ZXJvPyB4IGlzIG5vbi16ZXJvPyBPciBib3RoIGFyZSB6ZXJvLlxyXG4gICAgcmV0dXJuIHljWzBdID8gKHkucyA9IC1iLCB5KSA6IG5ldyBCaWcoeGNbMF0gPyB4IDogMCk7XHJcbiAgfVxyXG5cclxuICAvLyBEZXRlcm1pbmUgd2hpY2ggaXMgdGhlIGJpZ2dlciBudW1iZXIuIFByZXBlbmQgemVyb3MgdG8gZXF1YWxpc2UgZXhwb25lbnRzLlxyXG4gIGlmIChhID0geGUgLSB5ZSkge1xyXG5cclxuICAgIGlmICh4bHR5ID0gYSA8IDApIHtcclxuICAgICAgYSA9IC1hO1xyXG4gICAgICB0ID0geGM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB5ZSA9IHhlO1xyXG4gICAgICB0ID0geWM7XHJcbiAgICB9XHJcblxyXG4gICAgdC5yZXZlcnNlKCk7XHJcbiAgICBmb3IgKGIgPSBhOyBiLS07KSB0LnB1c2goMCk7XHJcbiAgICB0LnJldmVyc2UoKTtcclxuICB9IGVsc2Uge1xyXG5cclxuICAgIC8vIEV4cG9uZW50cyBlcXVhbC4gQ2hlY2sgZGlnaXQgYnkgZGlnaXQuXHJcbiAgICBqID0gKCh4bHR5ID0geGMubGVuZ3RoIDwgeWMubGVuZ3RoKSA/IHhjIDogeWMpLmxlbmd0aDtcclxuXHJcbiAgICBmb3IgKGEgPSBiID0gMDsgYiA8IGo7IGIrKykge1xyXG4gICAgICBpZiAoeGNbYl0gIT0geWNbYl0pIHtcclxuICAgICAgICB4bHR5ID0geGNbYl0gPCB5Y1tiXTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8geCA8IHk/IFBvaW50IHhjIHRvIHRoZSBhcnJheSBvZiB0aGUgYmlnZ2VyIG51bWJlci5cclxuICBpZiAoeGx0eSkge1xyXG4gICAgdCA9IHhjO1xyXG4gICAgeGMgPSB5YztcclxuICAgIHljID0gdDtcclxuICAgIHkucyA9IC15LnM7XHJcbiAgfVxyXG5cclxuICAvKlxyXG4gICAqIEFwcGVuZCB6ZXJvcyB0byB4YyBpZiBzaG9ydGVyLiBObyBuZWVkIHRvIGFkZCB6ZXJvcyB0byB5YyBpZiBzaG9ydGVyIGFzIHN1YnRyYWN0aW9uIG9ubHlcclxuICAgKiBuZWVkcyB0byBzdGFydCBhdCB5Yy5sZW5ndGguXHJcbiAgICovXHJcbiAgaWYgKChiID0gKGogPSB5Yy5sZW5ndGgpIC0gKGkgPSB4Yy5sZW5ndGgpKSA+IDApIGZvciAoOyBiLS07KSB4Y1tpKytdID0gMDtcclxuXHJcbiAgLy8gU3VidHJhY3QgeWMgZnJvbSB4Yy5cclxuICBmb3IgKGIgPSBpOyBqID4gYTspIHtcclxuICAgIGlmICh4Y1stLWpdIDwgeWNbal0pIHtcclxuICAgICAgZm9yIChpID0gajsgaSAmJiAheGNbLS1pXTspIHhjW2ldID0gOTtcclxuICAgICAgLS14Y1tpXTtcclxuICAgICAgeGNbal0gKz0gMTA7XHJcbiAgICB9XHJcblxyXG4gICAgeGNbal0gLT0geWNbal07XHJcbiAgfVxyXG5cclxuICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgZm9yICg7IHhjWy0tYl0gPT09IDA7KSB4Yy5wb3AoKTtcclxuXHJcbiAgLy8gUmVtb3ZlIGxlYWRpbmcgemVyb3MgYW5kIGFkanVzdCBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICBmb3IgKDsgeGNbMF0gPT09IDA7KSB7XHJcbiAgICB4Yy5zaGlmdCgpO1xyXG4gICAgLS15ZTtcclxuICB9XHJcblxyXG4gIGlmICgheGNbMF0pIHtcclxuXHJcbiAgICAvLyBuIC0gbiA9ICswXHJcbiAgICB5LnMgPSAxO1xyXG5cclxuICAgIC8vIFJlc3VsdCBtdXN0IGJlIHplcm8uXHJcbiAgICB4YyA9IFt5ZSA9IDBdO1xyXG4gIH1cclxuXHJcbiAgeS5jID0geGM7XHJcbiAgeS5lID0geWU7XHJcblxyXG4gIHJldHVybiB5O1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBCaWcgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIG1vZHVsbyB0aGUgdmFsdWUgb2YgQmlnIHkuXHJcbiAqL1xyXG5QLm1vZCA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgdmFyIHlndHgsXHJcbiAgICB4ID0gdGhpcyxcclxuICAgIEJpZyA9IHguY29uc3RydWN0b3IsXHJcbiAgICBhID0geC5zLFxyXG4gICAgYiA9ICh5ID0gbmV3IEJpZyh5KSkucztcclxuXHJcbiAgaWYgKCF5LmNbMF0pIHRocm93IEVycm9yKERJVl9CWV9aRVJPKTtcclxuXHJcbiAgeC5zID0geS5zID0gMTtcclxuICB5Z3R4ID0geS5jbXAoeCkgPT0gMTtcclxuICB4LnMgPSBhO1xyXG4gIHkucyA9IGI7XHJcblxyXG4gIGlmICh5Z3R4KSByZXR1cm4gbmV3IEJpZyh4KTtcclxuXHJcbiAgYSA9IEJpZy5EUDtcclxuICBiID0gQmlnLlJNO1xyXG4gIEJpZy5EUCA9IEJpZy5STSA9IDA7XHJcbiAgeCA9IHguZGl2KHkpO1xyXG4gIEJpZy5EUCA9IGE7XHJcbiAgQmlnLlJNID0gYjtcclxuXHJcbiAgcmV0dXJuIHRoaXMubWludXMoeC50aW1lcyh5KSk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IEJpZyB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgcGx1cyB0aGUgdmFsdWUgb2YgQmlnIHkuXHJcbiAqL1xyXG5QLnBsdXMgPSBQLmFkZCA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgdmFyIHQsXHJcbiAgICB4ID0gdGhpcyxcclxuICAgIEJpZyA9IHguY29uc3RydWN0b3IsXHJcbiAgICBhID0geC5zLFxyXG4gICAgYiA9ICh5ID0gbmV3IEJpZyh5KSkucztcclxuXHJcbiAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gIGlmIChhICE9IGIpIHtcclxuICAgIHkucyA9IC1iO1xyXG4gICAgcmV0dXJuIHgubWludXMoeSk7XHJcbiAgfVxyXG5cclxuICB2YXIgeGUgPSB4LmUsXHJcbiAgICB4YyA9IHguYyxcclxuICAgIHllID0geS5lLFxyXG4gICAgeWMgPSB5LmM7XHJcblxyXG4gIC8vIEVpdGhlciB6ZXJvPyB5IGlzIG5vbi16ZXJvPyB4IGlzIG5vbi16ZXJvPyBPciBib3RoIGFyZSB6ZXJvLlxyXG4gIGlmICgheGNbMF0gfHwgIXljWzBdKSByZXR1cm4geWNbMF0gPyB5IDogbmV3IEJpZyh4Y1swXSA/IHggOiBhICogMCk7XHJcblxyXG4gIHhjID0geGMuc2xpY2UoKTtcclxuXHJcbiAgLy8gUHJlcGVuZCB6ZXJvcyB0byBlcXVhbGlzZSBleHBvbmVudHMuXHJcbiAgLy8gTm90ZTogcmV2ZXJzZSBmYXN0ZXIgdGhhbiB1bnNoaWZ0cy5cclxuICBpZiAoYSA9IHhlIC0geWUpIHtcclxuICAgIGlmIChhID4gMCkge1xyXG4gICAgICB5ZSA9IHhlO1xyXG4gICAgICB0ID0geWM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBhID0gLWE7XHJcbiAgICAgIHQgPSB4YztcclxuICAgIH1cclxuXHJcbiAgICB0LnJldmVyc2UoKTtcclxuICAgIGZvciAoOyBhLS07KSB0LnB1c2goMCk7XHJcbiAgICB0LnJldmVyc2UoKTtcclxuICB9XHJcblxyXG4gIC8vIFBvaW50IHhjIHRvIHRoZSBsb25nZXIgYXJyYXkuXHJcbiAgaWYgKHhjLmxlbmd0aCAtIHljLmxlbmd0aCA8IDApIHtcclxuICAgIHQgPSB5YztcclxuICAgIHljID0geGM7XHJcbiAgICB4YyA9IHQ7XHJcbiAgfVxyXG5cclxuICBhID0geWMubGVuZ3RoO1xyXG5cclxuICAvLyBPbmx5IHN0YXJ0IGFkZGluZyBhdCB5Yy5sZW5ndGggLSAxIGFzIHRoZSBmdXJ0aGVyIGRpZ2l0cyBvZiB4YyBjYW4gYmUgbGVmdCBhcyB0aGV5IGFyZS5cclxuICBmb3IgKGIgPSAwOyBhOyB4Y1thXSAlPSAxMCkgYiA9ICh4Y1stLWFdID0geGNbYV0gKyB5Y1thXSArIGIpIC8gMTAgfCAwO1xyXG5cclxuICAvLyBObyBuZWVkIHRvIGNoZWNrIGZvciB6ZXJvLCBhcyAreCArICt5ICE9IDAgJiYgLXggKyAteSAhPSAwXHJcblxyXG4gIGlmIChiKSB7XHJcbiAgICB4Yy51bnNoaWZ0KGIpO1xyXG4gICAgKyt5ZTtcclxuICB9XHJcblxyXG4gIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICBmb3IgKGEgPSB4Yy5sZW5ndGg7IHhjWy0tYV0gPT09IDA7KSB4Yy5wb3AoKTtcclxuXHJcbiAgeS5jID0geGM7XHJcbiAgeS5lID0geWU7XHJcblxyXG4gIHJldHVybiB5O1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIEJpZyB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgcmFpc2VkIHRvIHRoZSBwb3dlciBuLlxyXG4gKiBJZiBuIGlzIG5lZ2F0aXZlLCByb3VuZCB0byBhIG1heGltdW0gb2YgQmlnLkRQIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nXHJcbiAqIG1vZGUgQmlnLlJNLlxyXG4gKlxyXG4gKiBuIHtudW1iZXJ9IEludGVnZXIsIC1NQVhfUE9XRVIgdG8gTUFYX1BPV0VSIGluY2x1c2l2ZS5cclxuICovXHJcblAucG93ID0gZnVuY3Rpb24gKG4pIHtcclxuICB2YXIgeCA9IHRoaXMsXHJcbiAgICBvbmUgPSBuZXcgeC5jb25zdHJ1Y3RvcigxKSxcclxuICAgIHkgPSBvbmUsXHJcbiAgICBpc25lZyA9IG4gPCAwO1xyXG5cclxuICBpZiAobiAhPT0gfn5uIHx8IG4gPCAtTUFYX1BPV0VSIHx8IG4gPiBNQVhfUE9XRVIpIHRocm93IEVycm9yKElOVkFMSUQgKyAnZXhwb25lbnQnKTtcclxuICBpZiAoaXNuZWcpIG4gPSAtbjtcclxuXHJcbiAgZm9yICg7Oykge1xyXG4gICAgaWYgKG4gJiAxKSB5ID0geS50aW1lcyh4KTtcclxuICAgIG4gPj49IDE7XHJcbiAgICBpZiAoIW4pIGJyZWFrO1xyXG4gICAgeCA9IHgudGltZXMoeCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gaXNuZWcgPyBvbmUuZGl2KHkpIDogeTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgQmlnIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZyByb3VuZGVkIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm1cclxuICogdG8gYSBtYXhpbXVtIG9mIGRwIGRlY2ltYWwgcGxhY2VzLCBvciwgaWYgZHAgaXMgbmVnYXRpdmUsIHRvIGFuIGludGVnZXIgd2hpY2ggaXMgYVxyXG4gKiBtdWx0aXBsZSBvZiAxMCoqLWRwLlxyXG4gKiBJZiBkcCBpcyBub3Qgc3BlY2lmaWVkLCByb3VuZCB0byAwIGRlY2ltYWwgcGxhY2VzLlxyXG4gKiBJZiBybSBpcyBub3Qgc3BlY2lmaWVkLCB1c2UgQmlnLlJNLlxyXG4gKlxyXG4gKiBkcD8ge251bWJlcn0gSW50ZWdlciwgLU1BWF9EUCB0byBNQVhfRFAgaW5jbHVzaXZlLlxyXG4gKiBybT8gMCwgMSwgMiBvciAzIChST1VORF9ET1dOLCBST1VORF9IQUxGX1VQLCBST1VORF9IQUxGX0VWRU4sIFJPVU5EX1VQKVxyXG4gKi9cclxuUC5yb3VuZCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICB2YXIgQmlnID0gdGhpcy5jb25zdHJ1Y3RvcjtcclxuICBpZiAoZHAgPT09IFVOREVGSU5FRCkgZHAgPSAwO1xyXG4gIGVsc2UgaWYgKGRwICE9PSB+fmRwIHx8IGRwIDwgLU1BWF9EUCB8fCBkcCA+IE1BWF9EUCkgdGhyb3cgRXJyb3IoSU5WQUxJRF9EUCk7XHJcbiAgcmV0dXJuIHJvdW5kKG5ldyBCaWcodGhpcyksIGRwLCBybSA9PT0gVU5ERUZJTkVEID8gQmlnLlJNIDogcm0pO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBCaWcgd2hvc2UgdmFsdWUgaXMgdGhlIHNxdWFyZSByb290IG9mIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZywgcm91bmRlZCwgaWZcclxuICogbmVjZXNzYXJ5LCB0byBhIG1heGltdW0gb2YgQmlnLkRQIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgQmlnLlJNLlxyXG4gKi9cclxuUC5zcXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciByLCBjLCB0LFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICBCaWcgPSB4LmNvbnN0cnVjdG9yLFxyXG4gICAgcyA9IHgucyxcclxuICAgIGUgPSB4LmUsXHJcbiAgICBoYWxmID0gbmV3IEJpZygwLjUpO1xyXG5cclxuICAvLyBaZXJvP1xyXG4gIGlmICgheC5jWzBdKSByZXR1cm4gbmV3IEJpZyh4KTtcclxuXHJcbiAgLy8gTmVnYXRpdmU/XHJcbiAgaWYgKHMgPCAwKSB0aHJvdyBFcnJvcihOQU1FICsgJ05vIHNxdWFyZSByb290Jyk7XHJcblxyXG4gIC8vIEVzdGltYXRlLlxyXG4gIHMgPSBNYXRoLnNxcnQoeCArICcnKTtcclxuXHJcbiAgLy8gTWF0aC5zcXJ0IHVuZGVyZmxvdy9vdmVyZmxvdz9cclxuICAvLyBSZS1lc3RpbWF0ZTogcGFzcyB4IGNvZWZmaWNpZW50IHRvIE1hdGguc3FydCBhcyBpbnRlZ2VyLCB0aGVuIGFkanVzdCB0aGUgcmVzdWx0IGV4cG9uZW50LlxyXG4gIGlmIChzID09PSAwIHx8IHMgPT09IDEgLyAwKSB7XHJcbiAgICBjID0geC5jLmpvaW4oJycpO1xyXG4gICAgaWYgKCEoYy5sZW5ndGggKyBlICYgMSkpIGMgKz0gJzAnO1xyXG4gICAgcyA9IE1hdGguc3FydChjKTtcclxuICAgIGUgPSAoKGUgKyAxKSAvIDIgfCAwKSAtIChlIDwgMCB8fCBlICYgMSk7XHJcbiAgICByID0gbmV3IEJpZygocyA9PSAxIC8gMCA/ICcxZScgOiAocyA9IHMudG9FeHBvbmVudGlhbCgpKS5zbGljZSgwLCBzLmluZGV4T2YoJ2UnKSArIDEpKSArIGUpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByID0gbmV3IEJpZyhzKTtcclxuICB9XHJcblxyXG4gIGUgPSByLmUgKyAoQmlnLkRQICs9IDQpO1xyXG5cclxuICAvLyBOZXd0b24tUmFwaHNvbiBpdGVyYXRpb24uXHJcbiAgZG8ge1xyXG4gICAgdCA9IHI7XHJcbiAgICByID0gaGFsZi50aW1lcyh0LnBsdXMoeC5kaXYodCkpKTtcclxuICB9IHdoaWxlICh0LmMuc2xpY2UoMCwgZSkuam9pbignJykgIT09IHIuYy5zbGljZSgwLCBlKS5qb2luKCcnKSk7XHJcblxyXG4gIHJldHVybiByb3VuZChyLCBCaWcuRFAgLT0gNCwgQmlnLlJNKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgQmlnIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZyB0aW1lcyB0aGUgdmFsdWUgb2YgQmlnIHkuXHJcbiAqL1xyXG5QLnRpbWVzID0gUC5tdWwgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHZhciBjLFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICBCaWcgPSB4LmNvbnN0cnVjdG9yLFxyXG4gICAgeGMgPSB4LmMsXHJcbiAgICB5YyA9ICh5ID0gbmV3IEJpZyh5KSkuYyxcclxuICAgIGEgPSB4Yy5sZW5ndGgsXHJcbiAgICBiID0geWMubGVuZ3RoLFxyXG4gICAgaSA9IHguZSxcclxuICAgIGogPSB5LmU7XHJcblxyXG4gIC8vIERldGVybWluZSBzaWduIG9mIHJlc3VsdC5cclxuICB5LnMgPSB4LnMgPT0geS5zID8gMSA6IC0xO1xyXG5cclxuICAvLyBSZXR1cm4gc2lnbmVkIDAgaWYgZWl0aGVyIDAuXHJcbiAgaWYgKCF4Y1swXSB8fCAheWNbMF0pIHJldHVybiBuZXcgQmlnKHkucyAqIDApO1xyXG5cclxuICAvLyBJbml0aWFsaXNlIGV4cG9uZW50IG9mIHJlc3VsdCBhcyB4LmUgKyB5LmUuXHJcbiAgeS5lID0gaSArIGo7XHJcblxyXG4gIC8vIElmIGFycmF5IHhjIGhhcyBmZXdlciBkaWdpdHMgdGhhbiB5Yywgc3dhcCB4YyBhbmQgeWMsIGFuZCBsZW5ndGhzLlxyXG4gIGlmIChhIDwgYikge1xyXG4gICAgYyA9IHhjO1xyXG4gICAgeGMgPSB5YztcclxuICAgIHljID0gYztcclxuICAgIGogPSBhO1xyXG4gICAgYSA9IGI7XHJcbiAgICBiID0gajtcclxuICB9XHJcblxyXG4gIC8vIEluaXRpYWxpc2UgY29lZmZpY2llbnQgYXJyYXkgb2YgcmVzdWx0IHdpdGggemVyb3MuXHJcbiAgZm9yIChjID0gbmV3IEFycmF5KGogPSBhICsgYik7IGotLTspIGNbal0gPSAwO1xyXG5cclxuICAvLyBNdWx0aXBseS5cclxuXHJcbiAgLy8gaSBpcyBpbml0aWFsbHkgeGMubGVuZ3RoLlxyXG4gIGZvciAoaSA9IGI7IGktLTspIHtcclxuICAgIGIgPSAwO1xyXG5cclxuICAgIC8vIGEgaXMgeWMubGVuZ3RoLlxyXG4gICAgZm9yIChqID0gYSArIGk7IGogPiBpOykge1xyXG5cclxuICAgICAgLy8gQ3VycmVudCBzdW0gb2YgcHJvZHVjdHMgYXQgdGhpcyBkaWdpdCBwb3NpdGlvbiwgcGx1cyBjYXJyeS5cclxuICAgICAgYiA9IGNbal0gKyB5Y1tpXSAqIHhjW2ogLSBpIC0gMV0gKyBiO1xyXG4gICAgICBjW2otLV0gPSBiICUgMTA7XHJcblxyXG4gICAgICAvLyBjYXJyeVxyXG4gICAgICBiID0gYiAvIDEwIHwgMDtcclxuICAgIH1cclxuXHJcbiAgICBjW2pdID0gKGNbal0gKyBiKSAlIDEwO1xyXG4gIH1cclxuXHJcbiAgLy8gSW5jcmVtZW50IHJlc3VsdCBleHBvbmVudCBpZiB0aGVyZSBpcyBhIGZpbmFsIGNhcnJ5LCBvdGhlcndpc2UgcmVtb3ZlIGxlYWRpbmcgemVyby5cclxuICBpZiAoYikgKyt5LmU7XHJcbiAgZWxzZSBjLnNoaWZ0KCk7XHJcblxyXG4gIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICBmb3IgKGkgPSBjLmxlbmd0aDsgIWNbLS1pXTspIGMucG9wKCk7XHJcbiAgeS5jID0gYztcclxuXHJcbiAgcmV0dXJuIHk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgaW4gZXhwb25lbnRpYWwgbm90YXRpb24gdG8gZHAgZml4ZWQgZGVjaW1hbFxyXG4gKiBwbGFjZXMgYW5kIHJvdW5kZWQgdXNpbmcgQmlnLlJNLlxyXG4gKlxyXG4gKiBkcD8ge251bWJlcn0gSW50ZWdlciwgMCB0byBNQVhfRFAgaW5jbHVzaXZlLlxyXG4gKi9cclxuUC50b0V4cG9uZW50aWFsID0gZnVuY3Rpb24gKGRwKSB7XHJcbiAgcmV0dXJuIHN0cmluZ2lmeSh0aGlzLCAxLCBkcCwgZHApO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIGluIG5vcm1hbCBub3RhdGlvbiB0byBkcCBmaXhlZCBkZWNpbWFsXHJcbiAqIHBsYWNlcyBhbmQgcm91bmRlZCB1c2luZyBCaWcuUk0uXHJcbiAqXHJcbiAqIGRwPyB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIE1BWF9EUCBpbmNsdXNpdmUuXHJcbiAqXHJcbiAqICgtMCkudG9GaXhlZCgwKSBpcyAnMCcsIGJ1dCAoLTAuMSkudG9GaXhlZCgwKSBpcyAnLTAnLlxyXG4gKiAoLTApLnRvRml4ZWQoMSkgaXMgJzAuMCcsIGJ1dCAoLTAuMDEpLnRvRml4ZWQoMSkgaXMgJy0wLjAnLlxyXG4gKi9cclxuUC50b0ZpeGVkID0gZnVuY3Rpb24gKGRwKSB7XHJcbiAgcmV0dXJuIHN0cmluZ2lmeSh0aGlzLCAyLCBkcCwgdGhpcy5lICsgZHApO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIHJvdW5kZWQgdG8gc2Qgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nXHJcbiAqIEJpZy5STS4gVXNlIGV4cG9uZW50aWFsIG5vdGF0aW9uIGlmIHNkIGlzIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBuZWNlc3NhcnkgdG8gcmVwcmVzZW50XHJcbiAqIHRoZSBpbnRlZ2VyIHBhcnQgb2YgdGhlIHZhbHVlIGluIG5vcm1hbCBub3RhdGlvbi5cclxuICpcclxuICogc2Qge251bWJlcn0gSW50ZWdlciwgMSB0byBNQVhfRFAgaW5jbHVzaXZlLlxyXG4gKi9cclxuUC50b1ByZWNpc2lvbiA9IGZ1bmN0aW9uIChzZCkge1xyXG4gIHJldHVybiBzdHJpbmdpZnkodGhpcywgMywgc2QsIHNkIC0gMSk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWcuXHJcbiAqIFJldHVybiBleHBvbmVudGlhbCBub3RhdGlvbiBpZiB0aGlzIEJpZyBoYXMgYSBwb3NpdGl2ZSBleHBvbmVudCBlcXVhbCB0byBvciBncmVhdGVyIHRoYW5cclxuICogQmlnLlBFLCBvciBhIG5lZ2F0aXZlIGV4cG9uZW50IGVxdWFsIHRvIG9yIGxlc3MgdGhhbiBCaWcuTkUuXHJcbiAqIE9taXQgdGhlIHNpZ24gZm9yIG5lZ2F0aXZlIHplcm8uXHJcbiAqL1xyXG5QLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiBzdHJpbmdpZnkodGhpcyk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWcuXHJcbiAqIFJldHVybiBleHBvbmVudGlhbCBub3RhdGlvbiBpZiB0aGlzIEJpZyBoYXMgYSBwb3NpdGl2ZSBleHBvbmVudCBlcXVhbCB0byBvciBncmVhdGVyIHRoYW5cclxuICogQmlnLlBFLCBvciBhIG5lZ2F0aXZlIGV4cG9uZW50IGVxdWFsIHRvIG9yIGxlc3MgdGhhbiBCaWcuTkUuXHJcbiAqIEluY2x1ZGUgdGhlIHNpZ24gZm9yIG5lZ2F0aXZlIHplcm8uXHJcbiAqL1xyXG5QLnZhbHVlT2YgPSBQLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gc3RyaW5naWZ5KHRoaXMsIDQpO1xyXG59O1xyXG5cclxuXHJcbi8vIEV4cG9ydFxyXG5cclxuXHJcbmV4cG9ydCB2YXIgQmlnID0gX0JpZ18oKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEJpZztcclxuIl0sIm5hbWVzIjpbIkRQIiwiUk0iLCJNQVhfRFAiLCJNQVhfUE9XRVIiLCJORSIsIlBFIiwiTkFNRSIsIklOVkFMSUQiLCJJTlZBTElEX0RQIiwiSU5WQUxJRF9STSIsIkRJVl9CWV9aRVJPIiwiUCIsIlVOREVGSU5FRCIsIk5VTUVSSUMiLCJfQmlnXyIsIkJpZyIsIm4iLCJ4IiwicyIsImUiLCJjIiwic2xpY2UiLCJwYXJzZSIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwidmVyc2lvbiIsImkiLCJubCIsInRlc3QiLCJFcnJvciIsImNoYXJBdCIsImluZGV4T2YiLCJyZXBsYWNlIiwic2VhcmNoIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwicm91bmQiLCJkcCIsInJtIiwibW9yZSIsInhjIiwidW5zaGlmdCIsInBvcCIsInN0cmluZ2lmeSIsImlkIiwiayIsInoiLCJwdXNoIiwiam9pbiIsImFicyIsImNtcCIsInkiLCJpc25lZyIsInljIiwiaiIsImwiLCJkaXYiLCJhIiwiYiIsImJsIiwiYnQiLCJyaSIsImJ6IiwiYWkiLCJhbCIsInIiLCJybCIsInEiLCJxYyIsInFpIiwiZCIsInNoaWZ0IiwiZXEiLCJndCIsImd0ZSIsImx0IiwibHRlIiwibWludXMiLCJzdWIiLCJ0IiwieGx0eSIsInBsdXMiLCJ4ZSIsInllIiwicmV2ZXJzZSIsIm1vZCIsInlndHgiLCJ0aW1lcyIsImFkZCIsInBvdyIsIm9uZSIsInNxcnQiLCJoYWxmIiwiTWF0aCIsInRvRXhwb25lbnRpYWwiLCJtdWwiLCJBcnJheSIsInRvRml4ZWQiLCJ0b1ByZWNpc2lvbiIsInNkIiwidG9TdHJpbmciLCJ2YWx1ZU9mIiwidG9KU09OIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/big.js/big.mjs\n");

/***/ })

};
;