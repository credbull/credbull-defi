"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/qrcode.react";
exports.ids = ["vendor-chunks/qrcode.react"];
exports.modules = {

/***/ "(ssr)/./node_modules/qrcode.react/lib/esm/index.js":
/*!****************************************************!*\
  !*** ./node_modules/qrcode.react/lib/esm/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QRCodeCanvas: () => (/* binding */ QRCodeCanvas),\n/* harmony export */   QRCodeSVG: () => (/* binding */ QRCodeSVG),\n/* harmony export */   \"default\": () => (/* binding */ QRCode)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __spreadValues = (a, b)=>{\n    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){\n        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    }\n    return a;\n};\nvar __objRest = (source, exclude)=>{\n    var target = {};\n    for(var prop in source)if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n    if (source != null && __getOwnPropSymbols) for (var prop of __getOwnPropSymbols(source)){\n        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];\n    }\n    return target;\n};\n// src/index.tsx\n\n// src/third-party/qrcodegen/index.ts\n/**\n * @license QR Code generator library (TypeScript)\n * Copyright (c) Project Nayuki.\n * SPDX-License-Identifier: MIT\n */ var qrcodegen;\n((qrcodegen2)=>{\n    const _QrCode = class {\n        constructor(version, errorCorrectionLevel, dataCodewords, msk){\n            this.version = version;\n            this.errorCorrectionLevel = errorCorrectionLevel;\n            this.modules = [];\n            this.isFunction = [];\n            if (version < _QrCode.MIN_VERSION || version > _QrCode.MAX_VERSION) throw new RangeError(\"Version value out of range\");\n            if (msk < -1 || msk > 7) throw new RangeError(\"Mask value out of range\");\n            this.size = version * 4 + 17;\n            let row = [];\n            for(let i = 0; i < this.size; i++)row.push(false);\n            for(let i = 0; i < this.size; i++){\n                this.modules.push(row.slice());\n                this.isFunction.push(row.slice());\n            }\n            this.drawFunctionPatterns();\n            const allCodewords = this.addEccAndInterleave(dataCodewords);\n            this.drawCodewords(allCodewords);\n            if (msk == -1) {\n                let minPenalty = 1e9;\n                for(let i = 0; i < 8; i++){\n                    this.applyMask(i);\n                    this.drawFormatBits(i);\n                    const penalty = this.getPenaltyScore();\n                    if (penalty < minPenalty) {\n                        msk = i;\n                        minPenalty = penalty;\n                    }\n                    this.applyMask(i);\n                }\n            }\n            assert(0 <= msk && msk <= 7);\n            this.mask = msk;\n            this.applyMask(msk);\n            this.drawFormatBits(msk);\n            this.isFunction = [];\n        }\n        static encodeText(text, ecl) {\n            const segs = qrcodegen2.QrSegment.makeSegments(text);\n            return _QrCode.encodeSegments(segs, ecl);\n        }\n        static encodeBinary(data, ecl) {\n            const seg = qrcodegen2.QrSegment.makeBytes(data);\n            return _QrCode.encodeSegments([\n                seg\n            ], ecl);\n        }\n        static encodeSegments(segs, ecl, minVersion = 1, maxVersion = 40, mask = -1, boostEcl = true) {\n            if (!(_QrCode.MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= _QrCode.MAX_VERSION) || mask < -1 || mask > 7) throw new RangeError(\"Invalid value\");\n            let version;\n            let dataUsedBits;\n            for(version = minVersion;; version++){\n                const dataCapacityBits2 = _QrCode.getNumDataCodewords(version, ecl) * 8;\n                const usedBits = QrSegment.getTotalBits(segs, version);\n                if (usedBits <= dataCapacityBits2) {\n                    dataUsedBits = usedBits;\n                    break;\n                }\n                if (version >= maxVersion) throw new RangeError(\"Data too long\");\n            }\n            for (const newEcl of [\n                _QrCode.Ecc.MEDIUM,\n                _QrCode.Ecc.QUARTILE,\n                _QrCode.Ecc.HIGH\n            ]){\n                if (boostEcl && dataUsedBits <= _QrCode.getNumDataCodewords(version, newEcl) * 8) ecl = newEcl;\n            }\n            let bb = [];\n            for (const seg of segs){\n                appendBits(seg.mode.modeBits, 4, bb);\n                appendBits(seg.numChars, seg.mode.numCharCountBits(version), bb);\n                for (const b of seg.getData())bb.push(b);\n            }\n            assert(bb.length == dataUsedBits);\n            const dataCapacityBits = _QrCode.getNumDataCodewords(version, ecl) * 8;\n            assert(bb.length <= dataCapacityBits);\n            appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);\n            appendBits(0, (8 - bb.length % 8) % 8, bb);\n            assert(bb.length % 8 == 0);\n            for(let padByte = 236; bb.length < dataCapacityBits; padByte ^= 236 ^ 17)appendBits(padByte, 8, bb);\n            let dataCodewords = [];\n            while(dataCodewords.length * 8 < bb.length)dataCodewords.push(0);\n            bb.forEach((b, i)=>dataCodewords[i >>> 3] |= b << 7 - (i & 7));\n            return new _QrCode(version, ecl, dataCodewords, mask);\n        }\n        getModule(x, y) {\n            return 0 <= x && x < this.size && 0 <= y && y < this.size && this.modules[y][x];\n        }\n        getModules() {\n            return this.modules;\n        }\n        drawFunctionPatterns() {\n            for(let i = 0; i < this.size; i++){\n                this.setFunctionModule(6, i, i % 2 == 0);\n                this.setFunctionModule(i, 6, i % 2 == 0);\n            }\n            this.drawFinderPattern(3, 3);\n            this.drawFinderPattern(this.size - 4, 3);\n            this.drawFinderPattern(3, this.size - 4);\n            const alignPatPos = this.getAlignmentPatternPositions();\n            const numAlign = alignPatPos.length;\n            for(let i = 0; i < numAlign; i++){\n                for(let j = 0; j < numAlign; j++){\n                    if (!(i == 0 && j == 0 || i == 0 && j == numAlign - 1 || i == numAlign - 1 && j == 0)) this.drawAlignmentPattern(alignPatPos[i], alignPatPos[j]);\n                }\n            }\n            this.drawFormatBits(0);\n            this.drawVersion();\n        }\n        drawFormatBits(mask) {\n            const data = this.errorCorrectionLevel.formatBits << 3 | mask;\n            let rem = data;\n            for(let i = 0; i < 10; i++)rem = rem << 1 ^ (rem >>> 9) * 1335;\n            const bits = (data << 10 | rem) ^ 21522;\n            assert(bits >>> 15 == 0);\n            for(let i = 0; i <= 5; i++)this.setFunctionModule(8, i, getBit(bits, i));\n            this.setFunctionModule(8, 7, getBit(bits, 6));\n            this.setFunctionModule(8, 8, getBit(bits, 7));\n            this.setFunctionModule(7, 8, getBit(bits, 8));\n            for(let i = 9; i < 15; i++)this.setFunctionModule(14 - i, 8, getBit(bits, i));\n            for(let i = 0; i < 8; i++)this.setFunctionModule(this.size - 1 - i, 8, getBit(bits, i));\n            for(let i = 8; i < 15; i++)this.setFunctionModule(8, this.size - 15 + i, getBit(bits, i));\n            this.setFunctionModule(8, this.size - 8, true);\n        }\n        drawVersion() {\n            if (this.version < 7) return;\n            let rem = this.version;\n            for(let i = 0; i < 12; i++)rem = rem << 1 ^ (rem >>> 11) * 7973;\n            const bits = this.version << 12 | rem;\n            assert(bits >>> 18 == 0);\n            for(let i = 0; i < 18; i++){\n                const color = getBit(bits, i);\n                const a = this.size - 11 + i % 3;\n                const b = Math.floor(i / 3);\n                this.setFunctionModule(a, b, color);\n                this.setFunctionModule(b, a, color);\n            }\n        }\n        drawFinderPattern(x, y) {\n            for(let dy = -4; dy <= 4; dy++){\n                for(let dx = -4; dx <= 4; dx++){\n                    const dist = Math.max(Math.abs(dx), Math.abs(dy));\n                    const xx = x + dx;\n                    const yy = y + dy;\n                    if (0 <= xx && xx < this.size && 0 <= yy && yy < this.size) this.setFunctionModule(xx, yy, dist != 2 && dist != 4);\n                }\n            }\n        }\n        drawAlignmentPattern(x, y) {\n            for(let dy = -2; dy <= 2; dy++){\n                for(let dx = -2; dx <= 2; dx++)this.setFunctionModule(x + dx, y + dy, Math.max(Math.abs(dx), Math.abs(dy)) != 1);\n            }\n        }\n        setFunctionModule(x, y, isDark) {\n            this.modules[y][x] = isDark;\n            this.isFunction[y][x] = true;\n        }\n        addEccAndInterleave(data) {\n            const ver = this.version;\n            const ecl = this.errorCorrectionLevel;\n            if (data.length != _QrCode.getNumDataCodewords(ver, ecl)) throw new RangeError(\"Invalid argument\");\n            const numBlocks = _QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];\n            const blockEccLen = _QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver];\n            const rawCodewords = Math.floor(_QrCode.getNumRawDataModules(ver) / 8);\n            const numShortBlocks = numBlocks - rawCodewords % numBlocks;\n            const shortBlockLen = Math.floor(rawCodewords / numBlocks);\n            let blocks = [];\n            const rsDiv = _QrCode.reedSolomonComputeDivisor(blockEccLen);\n            for(let i = 0, k = 0; i < numBlocks; i++){\n                let dat = data.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));\n                k += dat.length;\n                const ecc = _QrCode.reedSolomonComputeRemainder(dat, rsDiv);\n                if (i < numShortBlocks) dat.push(0);\n                blocks.push(dat.concat(ecc));\n            }\n            let result = [];\n            for(let i = 0; i < blocks[0].length; i++){\n                blocks.forEach((block, j)=>{\n                    if (i != shortBlockLen - blockEccLen || j >= numShortBlocks) result.push(block[i]);\n                });\n            }\n            assert(result.length == rawCodewords);\n            return result;\n        }\n        drawCodewords(data) {\n            if (data.length != Math.floor(_QrCode.getNumRawDataModules(this.version) / 8)) throw new RangeError(\"Invalid argument\");\n            let i = 0;\n            for(let right = this.size - 1; right >= 1; right -= 2){\n                if (right == 6) right = 5;\n                for(let vert = 0; vert < this.size; vert++){\n                    for(let j = 0; j < 2; j++){\n                        const x = right - j;\n                        const upward = (right + 1 & 2) == 0;\n                        const y = upward ? this.size - 1 - vert : vert;\n                        if (!this.isFunction[y][x] && i < data.length * 8) {\n                            this.modules[y][x] = getBit(data[i >>> 3], 7 - (i & 7));\n                            i++;\n                        }\n                    }\n                }\n            }\n            assert(i == data.length * 8);\n        }\n        applyMask(mask) {\n            if (mask < 0 || mask > 7) throw new RangeError(\"Mask value out of range\");\n            for(let y = 0; y < this.size; y++){\n                for(let x = 0; x < this.size; x++){\n                    let invert;\n                    switch(mask){\n                        case 0:\n                            invert = (x + y) % 2 == 0;\n                            break;\n                        case 1:\n                            invert = y % 2 == 0;\n                            break;\n                        case 2:\n                            invert = x % 3 == 0;\n                            break;\n                        case 3:\n                            invert = (x + y) % 3 == 0;\n                            break;\n                        case 4:\n                            invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 == 0;\n                            break;\n                        case 5:\n                            invert = x * y % 2 + x * y % 3 == 0;\n                            break;\n                        case 6:\n                            invert = (x * y % 2 + x * y % 3) % 2 == 0;\n                            break;\n                        case 7:\n                            invert = ((x + y) % 2 + x * y % 3) % 2 == 0;\n                            break;\n                        default:\n                            throw new Error(\"Unreachable\");\n                    }\n                    if (!this.isFunction[y][x] && invert) this.modules[y][x] = !this.modules[y][x];\n                }\n            }\n        }\n        getPenaltyScore() {\n            let result = 0;\n            for(let y = 0; y < this.size; y++){\n                let runColor = false;\n                let runX = 0;\n                let runHistory = [\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0\n                ];\n                for(let x = 0; x < this.size; x++){\n                    if (this.modules[y][x] == runColor) {\n                        runX++;\n                        if (runX == 5) result += _QrCode.PENALTY_N1;\n                        else if (runX > 5) result++;\n                    } else {\n                        this.finderPenaltyAddHistory(runX, runHistory);\n                        if (!runColor) result += this.finderPenaltyCountPatterns(runHistory) * _QrCode.PENALTY_N3;\n                        runColor = this.modules[y][x];\n                        runX = 1;\n                    }\n                }\n                result += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * _QrCode.PENALTY_N3;\n            }\n            for(let x = 0; x < this.size; x++){\n                let runColor = false;\n                let runY = 0;\n                let runHistory = [\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0\n                ];\n                for(let y = 0; y < this.size; y++){\n                    if (this.modules[y][x] == runColor) {\n                        runY++;\n                        if (runY == 5) result += _QrCode.PENALTY_N1;\n                        else if (runY > 5) result++;\n                    } else {\n                        this.finderPenaltyAddHistory(runY, runHistory);\n                        if (!runColor) result += this.finderPenaltyCountPatterns(runHistory) * _QrCode.PENALTY_N3;\n                        runColor = this.modules[y][x];\n                        runY = 1;\n                    }\n                }\n                result += this.finderPenaltyTerminateAndCount(runColor, runY, runHistory) * _QrCode.PENALTY_N3;\n            }\n            for(let y = 0; y < this.size - 1; y++){\n                for(let x = 0; x < this.size - 1; x++){\n                    const color = this.modules[y][x];\n                    if (color == this.modules[y][x + 1] && color == this.modules[y + 1][x] && color == this.modules[y + 1][x + 1]) result += _QrCode.PENALTY_N2;\n                }\n            }\n            let dark = 0;\n            for (const row of this.modules)dark = row.reduce((sum, color)=>sum + (color ? 1 : 0), dark);\n            const total = this.size * this.size;\n            const k = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1;\n            assert(0 <= k && k <= 9);\n            result += k * _QrCode.PENALTY_N4;\n            assert(0 <= result && result <= 2568888);\n            return result;\n        }\n        getAlignmentPatternPositions() {\n            if (this.version == 1) return [];\n            else {\n                const numAlign = Math.floor(this.version / 7) + 2;\n                const step = this.version == 32 ? 26 : Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;\n                let result = [\n                    6\n                ];\n                for(let pos = this.size - 7; result.length < numAlign; pos -= step)result.splice(1, 0, pos);\n                return result;\n            }\n        }\n        static getNumRawDataModules(ver) {\n            if (ver < _QrCode.MIN_VERSION || ver > _QrCode.MAX_VERSION) throw new RangeError(\"Version number out of range\");\n            let result = (16 * ver + 128) * ver + 64;\n            if (ver >= 2) {\n                const numAlign = Math.floor(ver / 7) + 2;\n                result -= (25 * numAlign - 10) * numAlign - 55;\n                if (ver >= 7) result -= 36;\n            }\n            assert(208 <= result && result <= 29648);\n            return result;\n        }\n        static getNumDataCodewords(ver, ecl) {\n            return Math.floor(_QrCode.getNumRawDataModules(ver) / 8) - _QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver] * _QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];\n        }\n        static reedSolomonComputeDivisor(degree) {\n            if (degree < 1 || degree > 255) throw new RangeError(\"Degree out of range\");\n            let result = [];\n            for(let i = 0; i < degree - 1; i++)result.push(0);\n            result.push(1);\n            let root = 1;\n            for(let i = 0; i < degree; i++){\n                for(let j = 0; j < result.length; j++){\n                    result[j] = _QrCode.reedSolomonMultiply(result[j], root);\n                    if (j + 1 < result.length) result[j] ^= result[j + 1];\n                }\n                root = _QrCode.reedSolomonMultiply(root, 2);\n            }\n            return result;\n        }\n        static reedSolomonComputeRemainder(data, divisor) {\n            let result = divisor.map((_)=>0);\n            for (const b of data){\n                const factor = b ^ result.shift();\n                result.push(0);\n                divisor.forEach((coef, i)=>result[i] ^= _QrCode.reedSolomonMultiply(coef, factor));\n            }\n            return result;\n        }\n        static reedSolomonMultiply(x, y) {\n            if (x >>> 8 != 0 || y >>> 8 != 0) throw new RangeError(\"Byte out of range\");\n            let z = 0;\n            for(let i = 7; i >= 0; i--){\n                z = z << 1 ^ (z >>> 7) * 285;\n                z ^= (y >>> i & 1) * x;\n            }\n            assert(z >>> 8 == 0);\n            return z;\n        }\n        finderPenaltyCountPatterns(runHistory) {\n            const n = runHistory[1];\n            assert(n <= this.size * 3);\n            const core = n > 0 && runHistory[2] == n && runHistory[3] == n * 3 && runHistory[4] == n && runHistory[5] == n;\n            return (core && runHistory[0] >= n * 4 && runHistory[6] >= n ? 1 : 0) + (core && runHistory[6] >= n * 4 && runHistory[0] >= n ? 1 : 0);\n        }\n        finderPenaltyTerminateAndCount(currentRunColor, currentRunLength, runHistory) {\n            if (currentRunColor) {\n                this.finderPenaltyAddHistory(currentRunLength, runHistory);\n                currentRunLength = 0;\n            }\n            currentRunLength += this.size;\n            this.finderPenaltyAddHistory(currentRunLength, runHistory);\n            return this.finderPenaltyCountPatterns(runHistory);\n        }\n        finderPenaltyAddHistory(currentRunLength, runHistory) {\n            if (runHistory[0] == 0) currentRunLength += this.size;\n            runHistory.pop();\n            runHistory.unshift(currentRunLength);\n        }\n    };\n    let QrCode = _QrCode;\n    QrCode.MIN_VERSION = 1;\n    QrCode.MAX_VERSION = 40;\n    QrCode.PENALTY_N1 = 3;\n    QrCode.PENALTY_N2 = 3;\n    QrCode.PENALTY_N3 = 40;\n    QrCode.PENALTY_N4 = 10;\n    QrCode.ECC_CODEWORDS_PER_BLOCK = [\n        [\n            -1,\n            7,\n            10,\n            15,\n            20,\n            26,\n            18,\n            20,\n            24,\n            30,\n            18,\n            20,\n            24,\n            26,\n            30,\n            22,\n            24,\n            28,\n            30,\n            28,\n            28,\n            28,\n            28,\n            30,\n            30,\n            26,\n            28,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30\n        ],\n        [\n            -1,\n            10,\n            16,\n            26,\n            18,\n            24,\n            16,\n            18,\n            22,\n            22,\n            26,\n            30,\n            22,\n            22,\n            24,\n            24,\n            28,\n            28,\n            26,\n            26,\n            26,\n            26,\n            28,\n            28,\n            28,\n            28,\n            28,\n            28,\n            28,\n            28,\n            28,\n            28,\n            28,\n            28,\n            28,\n            28,\n            28,\n            28,\n            28,\n            28,\n            28\n        ],\n        [\n            -1,\n            13,\n            22,\n            18,\n            26,\n            18,\n            24,\n            18,\n            22,\n            20,\n            24,\n            28,\n            26,\n            24,\n            20,\n            30,\n            24,\n            28,\n            28,\n            26,\n            30,\n            28,\n            30,\n            30,\n            30,\n            30,\n            28,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30\n        ],\n        [\n            -1,\n            17,\n            28,\n            22,\n            16,\n            22,\n            28,\n            26,\n            26,\n            24,\n            28,\n            24,\n            28,\n            22,\n            24,\n            24,\n            30,\n            28,\n            28,\n            26,\n            28,\n            30,\n            24,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30\n        ]\n    ];\n    QrCode.NUM_ERROR_CORRECTION_BLOCKS = [\n        [\n            -1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            2,\n            2,\n            2,\n            2,\n            4,\n            4,\n            4,\n            4,\n            4,\n            6,\n            6,\n            6,\n            6,\n            7,\n            8,\n            8,\n            9,\n            9,\n            10,\n            12,\n            12,\n            12,\n            13,\n            14,\n            15,\n            16,\n            17,\n            18,\n            19,\n            19,\n            20,\n            21,\n            22,\n            24,\n            25\n        ],\n        [\n            -1,\n            1,\n            1,\n            1,\n            2,\n            2,\n            4,\n            4,\n            4,\n            5,\n            5,\n            5,\n            8,\n            9,\n            9,\n            10,\n            10,\n            11,\n            13,\n            14,\n            16,\n            17,\n            17,\n            18,\n            20,\n            21,\n            23,\n            25,\n            26,\n            28,\n            29,\n            31,\n            33,\n            35,\n            37,\n            38,\n            40,\n            43,\n            45,\n            47,\n            49\n        ],\n        [\n            -1,\n            1,\n            1,\n            2,\n            2,\n            4,\n            4,\n            6,\n            6,\n            8,\n            8,\n            8,\n            10,\n            12,\n            16,\n            12,\n            17,\n            16,\n            18,\n            21,\n            20,\n            23,\n            23,\n            25,\n            27,\n            29,\n            34,\n            34,\n            35,\n            38,\n            40,\n            43,\n            45,\n            48,\n            51,\n            53,\n            56,\n            59,\n            62,\n            65,\n            68\n        ],\n        [\n            -1,\n            1,\n            1,\n            2,\n            4,\n            4,\n            4,\n            5,\n            6,\n            8,\n            8,\n            11,\n            11,\n            16,\n            16,\n            18,\n            16,\n            19,\n            21,\n            25,\n            25,\n            25,\n            34,\n            30,\n            32,\n            35,\n            37,\n            40,\n            42,\n            45,\n            48,\n            51,\n            54,\n            57,\n            60,\n            63,\n            66,\n            70,\n            74,\n            77,\n            81\n        ]\n    ];\n    qrcodegen2.QrCode = QrCode;\n    function appendBits(val, len, bb) {\n        if (len < 0 || len > 31 || val >>> len != 0) throw new RangeError(\"Value out of range\");\n        for(let i = len - 1; i >= 0; i--)bb.push(val >>> i & 1);\n    }\n    function getBit(x, i) {\n        return (x >>> i & 1) != 0;\n    }\n    function assert(cond) {\n        if (!cond) throw new Error(\"Assertion error\");\n    }\n    const _QrSegment = class {\n        constructor(mode, numChars, bitData){\n            this.mode = mode;\n            this.numChars = numChars;\n            this.bitData = bitData;\n            if (numChars < 0) throw new RangeError(\"Invalid argument\");\n            this.bitData = bitData.slice();\n        }\n        static makeBytes(data) {\n            let bb = [];\n            for (const b of data)appendBits(b, 8, bb);\n            return new _QrSegment(_QrSegment.Mode.BYTE, data.length, bb);\n        }\n        static makeNumeric(digits) {\n            if (!_QrSegment.isNumeric(digits)) throw new RangeError(\"String contains non-numeric characters\");\n            let bb = [];\n            for(let i = 0; i < digits.length;){\n                const n = Math.min(digits.length - i, 3);\n                appendBits(parseInt(digits.substr(i, n), 10), n * 3 + 1, bb);\n                i += n;\n            }\n            return new _QrSegment(_QrSegment.Mode.NUMERIC, digits.length, bb);\n        }\n        static makeAlphanumeric(text) {\n            if (!_QrSegment.isAlphanumeric(text)) throw new RangeError(\"String contains unencodable characters in alphanumeric mode\");\n            let bb = [];\n            let i;\n            for(i = 0; i + 2 <= text.length; i += 2){\n                let temp = _QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45;\n                temp += _QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1));\n                appendBits(temp, 11, bb);\n            }\n            if (i < text.length) appendBits(_QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6, bb);\n            return new _QrSegment(_QrSegment.Mode.ALPHANUMERIC, text.length, bb);\n        }\n        static makeSegments(text) {\n            if (text == \"\") return [];\n            else if (_QrSegment.isNumeric(text)) return [\n                _QrSegment.makeNumeric(text)\n            ];\n            else if (_QrSegment.isAlphanumeric(text)) return [\n                _QrSegment.makeAlphanumeric(text)\n            ];\n            else return [\n                _QrSegment.makeBytes(_QrSegment.toUtf8ByteArray(text))\n            ];\n        }\n        static makeEci(assignVal) {\n            let bb = [];\n            if (assignVal < 0) throw new RangeError(\"ECI assignment value out of range\");\n            else if (assignVal < 1 << 7) appendBits(assignVal, 8, bb);\n            else if (assignVal < 1 << 14) {\n                appendBits(2, 2, bb);\n                appendBits(assignVal, 14, bb);\n            } else if (assignVal < 1e6) {\n                appendBits(6, 3, bb);\n                appendBits(assignVal, 21, bb);\n            } else throw new RangeError(\"ECI assignment value out of range\");\n            return new _QrSegment(_QrSegment.Mode.ECI, 0, bb);\n        }\n        static isNumeric(text) {\n            return _QrSegment.NUMERIC_REGEX.test(text);\n        }\n        static isAlphanumeric(text) {\n            return _QrSegment.ALPHANUMERIC_REGEX.test(text);\n        }\n        getData() {\n            return this.bitData.slice();\n        }\n        static getTotalBits(segs, version) {\n            let result = 0;\n            for (const seg of segs){\n                const ccbits = seg.mode.numCharCountBits(version);\n                if (seg.numChars >= 1 << ccbits) return Infinity;\n                result += 4 + ccbits + seg.bitData.length;\n            }\n            return result;\n        }\n        static toUtf8ByteArray(str) {\n            str = encodeURI(str);\n            let result = [];\n            for(let i = 0; i < str.length; i++){\n                if (str.charAt(i) != \"%\") result.push(str.charCodeAt(i));\n                else {\n                    result.push(parseInt(str.substr(i + 1, 2), 16));\n                    i += 2;\n                }\n            }\n            return result;\n        }\n    };\n    let QrSegment = _QrSegment;\n    QrSegment.NUMERIC_REGEX = /^[0-9]*$/;\n    QrSegment.ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\\/:-]*$/;\n    QrSegment.ALPHANUMERIC_CHARSET = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:\";\n    qrcodegen2.QrSegment = QrSegment;\n})(qrcodegen || (qrcodegen = {}));\n((qrcodegen2)=>{\n    let QrCode;\n    ((QrCode2)=>{\n        const _Ecc = class {\n            constructor(ordinal, formatBits){\n                this.ordinal = ordinal;\n                this.formatBits = formatBits;\n            }\n        };\n        let Ecc = _Ecc;\n        Ecc.LOW = new _Ecc(0, 1);\n        Ecc.MEDIUM = new _Ecc(1, 0);\n        Ecc.QUARTILE = new _Ecc(2, 3);\n        Ecc.HIGH = new _Ecc(3, 2);\n        QrCode2.Ecc = Ecc;\n    })(QrCode = qrcodegen2.QrCode || (qrcodegen2.QrCode = {}));\n})(qrcodegen || (qrcodegen = {}));\n((qrcodegen2)=>{\n    let QrSegment;\n    ((QrSegment2)=>{\n        const _Mode = class {\n            constructor(modeBits, numBitsCharCount){\n                this.modeBits = modeBits;\n                this.numBitsCharCount = numBitsCharCount;\n            }\n            numCharCountBits(ver) {\n                return this.numBitsCharCount[Math.floor((ver + 7) / 17)];\n            }\n        };\n        let Mode = _Mode;\n        Mode.NUMERIC = new _Mode(1, [\n            10,\n            12,\n            14\n        ]);\n        Mode.ALPHANUMERIC = new _Mode(2, [\n            9,\n            11,\n            13\n        ]);\n        Mode.BYTE = new _Mode(4, [\n            8,\n            16,\n            16\n        ]);\n        Mode.KANJI = new _Mode(8, [\n            8,\n            10,\n            12\n        ]);\n        Mode.ECI = new _Mode(7, [\n            0,\n            0,\n            0\n        ]);\n        QrSegment2.Mode = Mode;\n    })(QrSegment = qrcodegen2.QrSegment || (qrcodegen2.QrSegment = {}));\n})(qrcodegen || (qrcodegen = {}));\nvar qrcodegen_default = qrcodegen;\n// src/index.tsx\n/**\n * @license qrcode.react\n * Copyright (c) Paul O'Shannessy\n * SPDX-License-Identifier: ISC\n */ var ERROR_LEVEL_MAP = {\n    L: qrcodegen_default.QrCode.Ecc.LOW,\n    M: qrcodegen_default.QrCode.Ecc.MEDIUM,\n    Q: qrcodegen_default.QrCode.Ecc.QUARTILE,\n    H: qrcodegen_default.QrCode.Ecc.HIGH\n};\nvar DEFAULT_SIZE = 128;\nvar DEFAULT_LEVEL = \"L\";\nvar DEFAULT_BGCOLOR = \"#FFFFFF\";\nvar DEFAULT_FGCOLOR = \"#000000\";\nvar DEFAULT_INCLUDEMARGIN = false;\nvar MARGIN_SIZE = 4;\nvar DEFAULT_IMG_SCALE = 0.1;\nfunction generatePath(modules, margin = 0) {\n    const ops = [];\n    modules.forEach(function(row, y) {\n        let start = null;\n        row.forEach(function(cell, x) {\n            if (!cell && start !== null) {\n                ops.push(`M${start + margin} ${y + margin}h${x - start}v1H${start + margin}z`);\n                start = null;\n                return;\n            }\n            if (x === row.length - 1) {\n                if (!cell) {\n                    return;\n                }\n                if (start === null) {\n                    ops.push(`M${x + margin},${y + margin} h1v1H${x + margin}z`);\n                } else {\n                    ops.push(`M${start + margin},${y + margin} h${x + 1 - start}v1H${start + margin}z`);\n                }\n                return;\n            }\n            if (cell && start === null) {\n                start = x;\n            }\n        });\n    });\n    return ops.join(\"\");\n}\nfunction excavateModules(modules, excavation) {\n    return modules.slice().map((row, y)=>{\n        if (y < excavation.y || y >= excavation.y + excavation.h) {\n            return row;\n        }\n        return row.map((cell, x)=>{\n            if (x < excavation.x || x >= excavation.x + excavation.w) {\n                return cell;\n            }\n            return false;\n        });\n    });\n}\nfunction getImageSettings(cells, size, includeMargin, imageSettings) {\n    if (imageSettings == null) {\n        return null;\n    }\n    const margin = includeMargin ? MARGIN_SIZE : 0;\n    const numCells = cells.length + margin * 2;\n    const defaultSize = Math.floor(size * DEFAULT_IMG_SCALE);\n    const scale = numCells / size;\n    const w = (imageSettings.width || defaultSize) * scale;\n    const h = (imageSettings.height || defaultSize) * scale;\n    const x = imageSettings.x == null ? cells.length / 2 - w / 2 : imageSettings.x * scale;\n    const y = imageSettings.y == null ? cells.length / 2 - h / 2 : imageSettings.y * scale;\n    let excavation = null;\n    if (imageSettings.excavate) {\n        let floorX = Math.floor(x);\n        let floorY = Math.floor(y);\n        let ceilW = Math.ceil(w + x - floorX);\n        let ceilH = Math.ceil(h + y - floorY);\n        excavation = {\n            x: floorX,\n            y: floorY,\n            w: ceilW,\n            h: ceilH\n        };\n    }\n    return {\n        x,\n        y,\n        h,\n        w,\n        excavation\n    };\n}\nvar SUPPORTS_PATH2D = function() {\n    try {\n        new Path2D().addPath(new Path2D());\n    } catch (e) {\n        return false;\n    }\n    return true;\n}();\nfunction QRCodeCanvas(props) {\n    const _a = props, { value, size = DEFAULT_SIZE, level = DEFAULT_LEVEL, bgColor = DEFAULT_BGCOLOR, fgColor = DEFAULT_FGCOLOR, includeMargin = DEFAULT_INCLUDEMARGIN, style, imageSettings } = _a, otherProps = __objRest(_a, [\n        \"value\",\n        \"size\",\n        \"level\",\n        \"bgColor\",\n        \"fgColor\",\n        \"includeMargin\",\n        \"style\",\n        \"imageSettings\"\n    ]);\n    const imgSrc = imageSettings == null ? void 0 : imageSettings.src;\n    const _canvas = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const _image = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const [isImgLoaded, setIsImageLoaded] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (_canvas.current != null) {\n            const canvas = _canvas.current;\n            const ctx = canvas.getContext(\"2d\");\n            if (!ctx) {\n                return;\n            }\n            let cells = qrcodegen_default.QrCode.encodeText(value, ERROR_LEVEL_MAP[level]).getModules();\n            const margin = includeMargin ? MARGIN_SIZE : 0;\n            const numCells = cells.length + margin * 2;\n            const calculatedImageSettings = getImageSettings(cells, size, includeMargin, imageSettings);\n            const image = _image.current;\n            const haveImageToRender = calculatedImageSettings != null && image !== null && image.complete && image.naturalHeight !== 0 && image.naturalWidth !== 0;\n            if (haveImageToRender) {\n                if (calculatedImageSettings.excavation != null) {\n                    cells = excavateModules(cells, calculatedImageSettings.excavation);\n                }\n            }\n            const pixelRatio = window.devicePixelRatio || 1;\n            canvas.height = canvas.width = size * pixelRatio;\n            const scale = size / numCells * pixelRatio;\n            ctx.scale(scale, scale);\n            ctx.fillStyle = bgColor;\n            ctx.fillRect(0, 0, numCells, numCells);\n            ctx.fillStyle = fgColor;\n            if (SUPPORTS_PATH2D) {\n                ctx.fill(new Path2D(generatePath(cells, margin)));\n            } else {\n                cells.forEach(function(row, rdx) {\n                    row.forEach(function(cell, cdx) {\n                        if (cell) {\n                            ctx.fillRect(cdx + margin, rdx + margin, 1, 1);\n                        }\n                    });\n                });\n            }\n            if (haveImageToRender) {\n                ctx.drawImage(image, calculatedImageSettings.x + margin, calculatedImageSettings.y + margin, calculatedImageSettings.w, calculatedImageSettings.h);\n            }\n        }\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        setIsImageLoaded(false);\n    }, [\n        imgSrc\n    ]);\n    const canvasStyle = __spreadValues({\n        height: size,\n        width: size\n    }, style);\n    let img = null;\n    if (imgSrc != null) {\n        img = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"img\", {\n            src: imgSrc,\n            key: imgSrc,\n            style: {\n                display: \"none\"\n            },\n            onLoad: ()=>{\n                setIsImageLoaded(true);\n            },\n            ref: _image\n        });\n    }\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"canvas\", __spreadValues({\n        style: canvasStyle,\n        height: size,\n        width: size,\n        ref: _canvas\n    }, otherProps)), img);\n}\nfunction QRCodeSVG(props) {\n    const _a = props, { value, size = DEFAULT_SIZE, level = DEFAULT_LEVEL, bgColor = DEFAULT_BGCOLOR, fgColor = DEFAULT_FGCOLOR, includeMargin = DEFAULT_INCLUDEMARGIN, imageSettings } = _a, otherProps = __objRest(_a, [\n        \"value\",\n        \"size\",\n        \"level\",\n        \"bgColor\",\n        \"fgColor\",\n        \"includeMargin\",\n        \"imageSettings\"\n    ]);\n    let cells = qrcodegen_default.QrCode.encodeText(value, ERROR_LEVEL_MAP[level]).getModules();\n    const margin = includeMargin ? MARGIN_SIZE : 0;\n    const numCells = cells.length + margin * 2;\n    const calculatedImageSettings = getImageSettings(cells, size, includeMargin, imageSettings);\n    let image = null;\n    if (imageSettings != null && calculatedImageSettings != null) {\n        if (calculatedImageSettings.excavation != null) {\n            cells = excavateModules(cells, calculatedImageSettings.excavation);\n        }\n        image = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"image\", {\n            xlinkHref: imageSettings.src,\n            height: calculatedImageSettings.h,\n            width: calculatedImageSettings.w,\n            x: calculatedImageSettings.x + margin,\n            y: calculatedImageSettings.y + margin,\n            preserveAspectRatio: \"none\"\n        });\n    }\n    const fgPath = generatePath(cells, margin);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"svg\", __spreadValues({\n        height: size,\n        width: size,\n        viewBox: `0 0 ${numCells} ${numCells}`\n    }, otherProps), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"path\", {\n        fill: bgColor,\n        d: `M0,0 h${numCells}v${numCells}H0z`,\n        shapeRendering: \"crispEdges\"\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"path\", {\n        fill: fgColor,\n        d: fgPath,\n        shapeRendering: \"crispEdges\"\n    }), image);\n}\nvar QRCode = (props)=>{\n    const _a = props, { renderAs } = _a, otherProps = __objRest(_a, [\n        \"renderAs\"\n    ]);\n    if (renderAs === \"svg\") {\n        return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(QRCodeSVG, __spreadValues({}, otherProps));\n    }\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(QRCodeCanvas, __spreadValues({}, otherProps));\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcXJjb2RlLnJlYWN0L2xpYi9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSxJQUFJQSxZQUFZQyxPQUFPQyxjQUFjO0FBQ3JDLElBQUlDLHNCQUFzQkYsT0FBT0cscUJBQXFCO0FBQ3RELElBQUlDLGVBQWVKLE9BQU9LLFNBQVMsQ0FBQ0MsY0FBYztBQUNsRCxJQUFJQyxlQUFlUCxPQUFPSyxTQUFTLENBQUNHLG9CQUFvQjtBQUN4RCxJQUFJQyxrQkFBa0IsQ0FBQ0MsS0FBS0MsS0FBS0MsUUFBVUQsT0FBT0QsTUFBTVgsVUFBVVcsS0FBS0MsS0FBSztRQUFFRSxZQUFZO1FBQU1DLGNBQWM7UUFBTUMsVUFBVTtRQUFNSDtJQUFNLEtBQUtGLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHQztBQUMxSixJQUFJSSxpQkFBaUIsQ0FBQ0MsR0FBR0M7SUFDdkIsSUFBSyxJQUFJQyxRQUFRRCxLQUFNQSxDQUFBQSxJQUFJLENBQUMsR0FDMUIsSUFBSWQsYUFBYWdCLElBQUksQ0FBQ0YsR0FBR0MsT0FDdkJWLGdCQUFnQlEsR0FBR0UsTUFBTUQsQ0FBQyxDQUFDQyxLQUFLO0lBQ3BDLElBQUlqQixxQkFDRixLQUFLLElBQUlpQixRQUFRakIsb0JBQW9CZ0IsR0FBSTtRQUN2QyxJQUFJWCxhQUFhYSxJQUFJLENBQUNGLEdBQUdDLE9BQ3ZCVixnQkFBZ0JRLEdBQUdFLE1BQU1ELENBQUMsQ0FBQ0MsS0FBSztJQUNwQztJQUNGLE9BQU9GO0FBQ1Q7QUFDQSxJQUFJSSxZQUFZLENBQUNDLFFBQVFDO0lBQ3ZCLElBQUlDLFNBQVMsQ0FBQztJQUNkLElBQUssSUFBSUwsUUFBUUcsT0FDZixJQUFJbEIsYUFBYWdCLElBQUksQ0FBQ0UsUUFBUUgsU0FBU0ksUUFBUUUsT0FBTyxDQUFDTixRQUFRLEdBQzdESyxNQUFNLENBQUNMLEtBQUssR0FBR0csTUFBTSxDQUFDSCxLQUFLO0lBQy9CLElBQUlHLFVBQVUsUUFBUXBCLHFCQUNwQixL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QUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1NBQUc7S0FDcks7SUFDRHVELE9BQU8xRCwyQkFBMkIsR0FBRztRQUNuQztZQUFDLENBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtTQUFHO1FBQzdJO1lBQUMsQ0FBQztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1NBQUc7UUFDdEo7WUFBQyxDQUFDO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7U0FBRztRQUN6SjtZQUFDLENBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtTQUFHO0tBQzNKO0lBQ0Q3RixXQUFXdUosTUFBTSxHQUFHQTtJQUNwQixTQUFTbEcsV0FBV21HLEdBQUcsRUFBRUMsR0FBRyxFQUFFckcsRUFBRTtRQUM5QixJQUFJcUcsTUFBTSxLQUFLQSxNQUFNLE1BQU1ELFFBQVFDLE9BQU8sR0FDeEMsTUFBTSxJQUFJOUksV0FBVztRQUN2QixJQUFLLElBQUlHLElBQUkySSxNQUFNLEdBQUczSSxLQUFLLEdBQUdBLElBQzVCc0MsR0FBR3JDLElBQUksQ0FBQ3lJLFFBQVExSSxJQUFJO0lBQ3hCO0lBQ0EsU0FBU2tFLE9BQU9kLENBQUMsRUFBRXBELENBQUM7UUFDbEIsT0FBTyxDQUFDb0QsTUFBTXBELElBQUksTUFBTTtJQUMxQjtJQUNBLFNBQVNZLE9BQU9nSSxJQUFJO1FBQ2xCLElBQUksQ0FBQ0EsTUFDSCxNQUFNLElBQUl2QyxNQUFNO0lBQ3BCO0lBQ0EsTUFBTXdDLGFBQWE7UUFDakJ6SixZQUFZb0QsSUFBSSxFQUFFRSxRQUFRLEVBQUVvRyxPQUFPLENBQUU7WUFDbkMsSUFBSSxDQUFDdEcsSUFBSSxHQUFHQTtZQUNaLElBQUksQ0FBQ0UsUUFBUSxHQUFHQTtZQUNoQixJQUFJLENBQUNvRyxPQUFPLEdBQUdBO1lBQ2YsSUFBSXBHLFdBQVcsR0FDYixNQUFNLElBQUk3QyxXQUFXO1lBQ3ZCLElBQUksQ0FBQ2lKLE9BQU8sR0FBR0EsUUFBUTVJLEtBQUs7UUFDOUI7UUFDQSxPQUFPc0IsVUFBVUYsSUFBSSxFQUFFO1lBQ3JCLElBQUlnQixLQUFLLEVBQUU7WUFDWCxLQUFLLE1BQU1qRSxLQUFLaUQsS0FDZGlCLFdBQVdsRSxHQUFHLEdBQUdpRTtZQUNuQixPQUFPLElBQUl1RyxXQUFXQSxXQUFXRSxJQUFJLENBQUNDLElBQUksRUFBRTFILEtBQUt1QixNQUFNLEVBQUVQO1FBQzNEO1FBQ0EsT0FBTzJHLFlBQVlDLE1BQU0sRUFBRTtZQUN6QixJQUFJLENBQUNMLFdBQVdNLFNBQVMsQ0FBQ0QsU0FDeEIsTUFBTSxJQUFJckosV0FBVztZQUN2QixJQUFJeUMsS0FBSyxFQUFFO1lBQ1gsSUFBSyxJQUFJdEMsSUFBSSxHQUFHQSxJQUFJa0osT0FBT3JHLE1BQU0sRUFBSTtnQkFDbkMsTUFBTXNGLElBQUlwRixLQUFLQyxHQUFHLENBQUNrRyxPQUFPckcsTUFBTSxHQUFHN0MsR0FBRztnQkFDdEN1QyxXQUFXNkcsU0FBU0YsT0FBT0csTUFBTSxDQUFDckosR0FBR21JLElBQUksS0FBS0EsSUFBSSxJQUFJLEdBQUc3RjtnQkFDekR0QyxLQUFLbUk7WUFDUDtZQUNBLE9BQU8sSUFBSVUsV0FBV0EsV0FBV0UsSUFBSSxDQUFDTyxPQUFPLEVBQUVKLE9BQU9yRyxNQUFNLEVBQUVQO1FBQ2hFO1FBQ0EsT0FBT2lILGlCQUFpQnhJLElBQUksRUFBRTtZQUM1QixJQUFJLENBQUM4SCxXQUFXVyxjQUFjLENBQUN6SSxPQUM3QixNQUFNLElBQUlsQixXQUFXO1lBQ3ZCLElBQUl5QyxLQUFLLEVBQUU7WUFDWCxJQUFJdEM7WUFDSixJQUFLQSxJQUFJLEdBQUdBLElBQUksS0FBS2UsS0FBSzhCLE1BQU0sRUFBRTdDLEtBQUssRUFBRztnQkFDeEMsSUFBSXlKLE9BQU9aLFdBQVdhLG9CQUFvQixDQUFDOUssT0FBTyxDQUFDbUMsS0FBSzRJLE1BQU0sQ0FBQzNKLE1BQU07Z0JBQ3JFeUosUUFBUVosV0FBV2Esb0JBQW9CLENBQUM5SyxPQUFPLENBQUNtQyxLQUFLNEksTUFBTSxDQUFDM0osSUFBSTtnQkFDaEV1QyxXQUFXa0gsTUFBTSxJQUFJbkg7WUFDdkI7WUFDQSxJQUFJdEMsSUFBSWUsS0FBSzhCLE1BQU0sRUFDakJOLFdBQVdzRyxXQUFXYSxvQkFBb0IsQ0FBQzlLLE9BQU8sQ0FBQ21DLEtBQUs0SSxNQUFNLENBQUMzSixLQUFLLEdBQUdzQztZQUN6RSxPQUFPLElBQUl1RyxXQUFXQSxXQUFXRSxJQUFJLENBQUNhLFlBQVksRUFBRTdJLEtBQUs4QixNQUFNLEVBQUVQO1FBQ25FO1FBQ0EsT0FBT25CLGFBQWFKLElBQUksRUFBRTtZQUN4QixJQUFJQSxRQUFRLElBQ1YsT0FBTyxFQUFFO2lCQUNOLElBQUk4SCxXQUFXTSxTQUFTLENBQUNwSSxPQUM1QixPQUFPO2dCQUFDOEgsV0FBV0ksV0FBVyxDQUFDbEk7YUFBTTtpQkFDbEMsSUFBSThILFdBQVdXLGNBQWMsQ0FBQ3pJLE9BQ2pDLE9BQU87Z0JBQUM4SCxXQUFXVSxnQkFBZ0IsQ0FBQ3hJO2FBQU07aUJBRTFDLE9BQU87Z0JBQUM4SCxXQUFXckgsU0FBUyxDQUFDcUgsV0FBV2dCLGVBQWUsQ0FBQzlJO2FBQU87UUFDbkU7UUFDQSxPQUFPK0ksUUFBUUMsU0FBUyxFQUFFO1lBQ3hCLElBQUl6SCxLQUFLLEVBQUU7WUFDWCxJQUFJeUgsWUFBWSxHQUNkLE1BQU0sSUFBSWxLLFdBQVc7aUJBQ2xCLElBQUlrSyxZQUFZLEtBQUssR0FDeEJ4SCxXQUFXd0gsV0FBVyxHQUFHekg7aUJBQ3RCLElBQUl5SCxZQUFZLEtBQUssSUFBSTtnQkFDNUJ4SCxXQUFXLEdBQUcsR0FBR0Q7Z0JBQ2pCQyxXQUFXd0gsV0FBVyxJQUFJekg7WUFDNUIsT0FBTyxJQUFJeUgsWUFBWSxLQUFLO2dCQUMxQnhILFdBQVcsR0FBRyxHQUFHRDtnQkFDakJDLFdBQVd3SCxXQUFXLElBQUl6SDtZQUM1QixPQUNFLE1BQU0sSUFBSXpDLFdBQVc7WUFDdkIsT0FBTyxJQUFJZ0osV0FBV0EsV0FBV0UsSUFBSSxDQUFDaUIsR0FBRyxFQUFFLEdBQUcxSDtRQUNoRDtRQUNBLE9BQU82RyxVQUFVcEksSUFBSSxFQUFFO1lBQ3JCLE9BQU84SCxXQUFXb0IsYUFBYSxDQUFDQyxJQUFJLENBQUNuSjtRQUN2QztRQUNBLE9BQU95SSxlQUFlekksSUFBSSxFQUFFO1lBQzFCLE9BQU84SCxXQUFXc0Isa0JBQWtCLENBQUNELElBQUksQ0FBQ25KO1FBQzVDO1FBQ0E2QixVQUFVO1lBQ1IsT0FBTyxJQUFJLENBQUNrRyxPQUFPLENBQUM1SSxLQUFLO1FBQzNCO1FBQ0EsT0FBTzhCLGFBQWFmLElBQUksRUFBRTVCLE9BQU8sRUFBRTtZQUNqQyxJQUFJMEcsU0FBUztZQUNiLEtBQUssTUFBTXhFLE9BQU9OLEtBQU07Z0JBQ3RCLE1BQU1tSixTQUFTN0ksSUFBSWlCLElBQUksQ0FBQ0csZ0JBQWdCLENBQUN0RDtnQkFDekMsSUFBSWtDLElBQUltQixRQUFRLElBQUksS0FBSzBILFFBQ3ZCLE9BQU9DO2dCQUNUdEUsVUFBVSxJQUFJcUUsU0FBUzdJLElBQUl1SCxPQUFPLENBQUNqRyxNQUFNO1lBQzNDO1lBQ0EsT0FBT2tEO1FBQ1Q7UUFDQSxPQUFPOEQsZ0JBQWdCUyxHQUFHLEVBQUU7WUFDMUJBLE1BQU1DLFVBQVVEO1lBQ2hCLElBQUl2RSxTQUFTLEVBQUU7WUFDZixJQUFLLElBQUkvRixJQUFJLEdBQUdBLElBQUlzSyxJQUFJekgsTUFBTSxFQUFFN0MsSUFBSztnQkFDbkMsSUFBSXNLLElBQUlYLE1BQU0sQ0FBQzNKLE1BQU0sS0FDbkIrRixPQUFPOUYsSUFBSSxDQUFDcUssSUFBSUUsVUFBVSxDQUFDeEs7cUJBQ3hCO29CQUNIK0YsT0FBTzlGLElBQUksQ0FBQ21KLFNBQVNrQixJQUFJakIsTUFBTSxDQUFDckosSUFBSSxHQUFHLElBQUk7b0JBQzNDQSxLQUFLO2dCQUNQO1lBQ0Y7WUFDQSxPQUFPK0Y7UUFDVDtJQUNGO0lBQ0EsSUFBSTdFLFlBQVkySDtJQUNoQjNILFVBQVUrSSxhQUFhLEdBQUc7SUFDMUIvSSxVQUFVaUosa0JBQWtCLEdBQUc7SUFDL0JqSixVQUFVd0ksb0JBQW9CLEdBQUc7SUFDakN4SyxXQUFXZ0MsU0FBUyxHQUFHQTtBQUN6QixHQUFHakMsYUFBY0EsQ0FBQUEsWUFBWSxDQUFDO0FBQzdCLEVBQUNDO0lBQ0EsSUFBSXVKO0lBQ0gsRUFBQ2dDO1FBQ0EsTUFBTUMsT0FBTztZQUNYdEwsWUFBWTRGLE9BQU8sRUFBRWpCLFVBQVUsQ0FBRTtnQkFDL0IsSUFBSSxDQUFDaUIsT0FBTyxHQUFHQTtnQkFDZixJQUFJLENBQUNqQixVQUFVLEdBQUdBO1lBQ3BCO1FBQ0Y7UUFDQSxJQUFJN0IsTUFBTXdJO1FBQ1Z4SSxJQUFJeUksR0FBRyxHQUFHLElBQUlELEtBQUssR0FBRztRQUN0QnhJLElBQUlDLE1BQU0sR0FBRyxJQUFJdUksS0FBSyxHQUFHO1FBQ3pCeEksSUFBSUUsUUFBUSxHQUFHLElBQUlzSSxLQUFLLEdBQUc7UUFDM0J4SSxJQUFJRyxJQUFJLEdBQUcsSUFBSXFJLEtBQUssR0FBRztRQUN2QkQsUUFBUXZJLEdBQUcsR0FBR0E7SUFDaEIsR0FBR3VHLFNBQVN2SixXQUFXdUosTUFBTSxJQUFLdkosQ0FBQUEsV0FBV3VKLE1BQU0sR0FBRyxDQUFDO0FBQ3pELEdBQUd4SixhQUFjQSxDQUFBQSxZQUFZLENBQUM7QUFDN0IsRUFBQ0M7SUFDQSxJQUFJZ0M7SUFDSCxFQUFDMEo7UUFDQSxNQUFNQyxRQUFRO1lBQ1p6TCxZQUFZcUQsUUFBUSxFQUFFcUksZ0JBQWdCLENBQUU7Z0JBQ3RDLElBQUksQ0FBQ3JJLFFBQVEsR0FBR0E7Z0JBQ2hCLElBQUksQ0FBQ3FJLGdCQUFnQixHQUFHQTtZQUMxQjtZQUNBbkksaUJBQWlCa0MsR0FBRyxFQUFFO2dCQUNwQixPQUFPLElBQUksQ0FBQ2lHLGdCQUFnQixDQUFDL0gsS0FBS3FCLEtBQUssQ0FBQyxDQUFDUyxNQUFNLEtBQUssSUFBSTtZQUMxRDtRQUNGO1FBQ0EsSUFBSWtFLE9BQU84QjtRQUNYOUIsS0FBS08sT0FBTyxHQUFHLElBQUl1QixNQUFNLEdBQUc7WUFBQztZQUFJO1lBQUk7U0FBRztRQUN4QzlCLEtBQUthLFlBQVksR0FBRyxJQUFJaUIsTUFBTSxHQUFHO1lBQUM7WUFBRztZQUFJO1NBQUc7UUFDNUM5QixLQUFLQyxJQUFJLEdBQUcsSUFBSTZCLE1BQU0sR0FBRztZQUFDO1lBQUc7WUFBSTtTQUFHO1FBQ3BDOUIsS0FBS2dDLEtBQUssR0FBRyxJQUFJRixNQUFNLEdBQUc7WUFBQztZQUFHO1lBQUk7U0FBRztRQUNyQzlCLEtBQUtpQixHQUFHLEdBQUcsSUFBSWEsTUFBTSxHQUFHO1lBQUM7WUFBRztZQUFHO1NBQUU7UUFDakNELFdBQVc3QixJQUFJLEdBQUdBO0lBQ3BCLEdBQUc3SCxZQUFZaEMsV0FBV2dDLFNBQVMsSUFBS2hDLENBQUFBLFdBQVdnQyxTQUFTLEdBQUcsQ0FBQztBQUNsRSxHQUFHakMsYUFBY0EsQ0FBQUEsWUFBWSxDQUFDO0FBQzlCLElBQUkrTCxvQkFBb0IvTDtBQUV4QixnQkFBZ0I7QUFDaEI7Ozs7Q0FJQyxHQUNELElBQUlnTSxrQkFBa0I7SUFDcEJDLEdBQUdGLGtCQUFrQnZDLE1BQU0sQ0FBQ3ZHLEdBQUcsQ0FBQ3lJLEdBQUc7SUFDbkNRLEdBQUdILGtCQUFrQnZDLE1BQU0sQ0FBQ3ZHLEdBQUcsQ0FBQ0MsTUFBTTtJQUN0Q2lKLEdBQUdKLGtCQUFrQnZDLE1BQU0sQ0FBQ3ZHLEdBQUcsQ0FBQ0UsUUFBUTtJQUN4Q2lKLEdBQUdMLGtCQUFrQnZDLE1BQU0sQ0FBQ3ZHLEdBQUcsQ0FBQ0csSUFBSTtBQUN0QztBQUNBLElBQUlpSixlQUFlO0FBQ25CLElBQUlDLGdCQUFnQjtBQUNwQixJQUFJQyxrQkFBa0I7QUFDdEIsSUFBSUMsa0JBQWtCO0FBQ3RCLElBQUlDLHdCQUF3QjtBQUM1QixJQUFJQyxjQUFjO0FBQ2xCLElBQUlDLG9CQUFvQjtBQUN4QixTQUFTQyxhQUFhcE0sT0FBTyxFQUFFcU0sU0FBUyxDQUFDO0lBQ3ZDLE1BQU1DLE1BQU0sRUFBRTtJQUNkdE0sUUFBUXlELE9BQU8sQ0FBQyxTQUFTbkQsR0FBRyxFQUFFc0QsQ0FBQztRQUM3QixJQUFJMkksUUFBUTtRQUNaak0sSUFBSW1ELE9BQU8sQ0FBQyxTQUFTK0ksSUFBSSxFQUFFN0ksQ0FBQztZQUMxQixJQUFJLENBQUM2SSxRQUFRRCxVQUFVLE1BQU07Z0JBQzNCRCxJQUFJOUwsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFK0wsUUFBUUYsT0FBTyxDQUFDLEVBQUV6SSxJQUFJeUksT0FBTyxDQUFDLEVBQUUxSSxJQUFJNEksTUFBTSxHQUFHLEVBQUVBLFFBQVFGLE9BQU8sQ0FBQyxDQUFDO2dCQUM3RUUsUUFBUTtnQkFDUjtZQUNGO1lBQ0EsSUFBSTVJLE1BQU1yRCxJQUFJOEMsTUFBTSxHQUFHLEdBQUc7Z0JBQ3hCLElBQUksQ0FBQ29KLE1BQU07b0JBQ1Q7Z0JBQ0Y7Z0JBQ0EsSUFBSUQsVUFBVSxNQUFNO29CQUNsQkQsSUFBSTlMLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRW1ELElBQUkwSSxPQUFPLENBQUMsRUFBRXpJLElBQUl5SSxPQUFPLE1BQU0sRUFBRTFJLElBQUkwSSxPQUFPLENBQUMsQ0FBQztnQkFDN0QsT0FBTztvQkFDTEMsSUFBSTlMLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRStMLFFBQVFGLE9BQU8sQ0FBQyxFQUFFekksSUFBSXlJLE9BQU8sRUFBRSxFQUFFMUksSUFBSSxJQUFJNEksTUFBTSxHQUFHLEVBQUVBLFFBQVFGLE9BQU8sQ0FBQyxDQUFDO2dCQUNwRjtnQkFDQTtZQUNGO1lBQ0EsSUFBSUcsUUFBUUQsVUFBVSxNQUFNO2dCQUMxQkEsUUFBUTVJO1lBQ1Y7UUFDRjtJQUNGO0lBQ0EsT0FBTzJJLElBQUlHLElBQUksQ0FBQztBQUNsQjtBQUNBLFNBQVNDLGdCQUFnQjFNLE9BQU8sRUFBRTJNLFVBQVU7SUFDMUMsT0FBTzNNLFFBQVFTLEtBQUssR0FBRzJILEdBQUcsQ0FBQyxDQUFDOUgsS0FBS3NEO1FBQy9CLElBQUlBLElBQUkrSSxXQUFXL0ksQ0FBQyxJQUFJQSxLQUFLK0ksV0FBVy9JLENBQUMsR0FBRytJLFdBQVdDLENBQUMsRUFBRTtZQUN4RCxPQUFPdE07UUFDVDtRQUNBLE9BQU9BLElBQUk4SCxHQUFHLENBQUMsQ0FBQ29FLE1BQU03STtZQUNwQixJQUFJQSxJQUFJZ0osV0FBV2hKLENBQUMsSUFBSUEsS0FBS2dKLFdBQVdoSixDQUFDLEdBQUdnSixXQUFXRSxDQUFDLEVBQUU7Z0JBQ3hELE9BQU9MO1lBQ1Q7WUFDQSxPQUFPO1FBQ1Q7SUFDRjtBQUNGO0FBQ0EsU0FBU00saUJBQWlCQyxLQUFLLEVBQUUxTSxJQUFJLEVBQUUyTSxhQUFhLEVBQUVDLGFBQWE7SUFDakUsSUFBSUEsaUJBQWlCLE1BQU07UUFDekIsT0FBTztJQUNUO0lBQ0EsTUFBTVosU0FBU1csZ0JBQWdCZCxjQUFjO0lBQzdDLE1BQU1nQixXQUFXSCxNQUFNM0osTUFBTSxHQUFHaUosU0FBUztJQUN6QyxNQUFNYyxjQUFjN0osS0FBS3FCLEtBQUssQ0FBQ3RFLE9BQU84TDtJQUN0QyxNQUFNaUIsUUFBUUYsV0FBVzdNO0lBQ3pCLE1BQU13TSxJQUFJLENBQUNJLGNBQWNJLEtBQUssSUFBSUYsV0FBVSxJQUFLQztJQUNqRCxNQUFNUixJQUFJLENBQUNLLGNBQWNLLE1BQU0sSUFBSUgsV0FBVSxJQUFLQztJQUNsRCxNQUFNekosSUFBSXNKLGNBQWN0SixDQUFDLElBQUksT0FBT29KLE1BQU0zSixNQUFNLEdBQUcsSUFBSXlKLElBQUksSUFBSUksY0FBY3RKLENBQUMsR0FBR3lKO0lBQ2pGLE1BQU14SixJQUFJcUosY0FBY3JKLENBQUMsSUFBSSxPQUFPbUosTUFBTTNKLE1BQU0sR0FBRyxJQUFJd0osSUFBSSxJQUFJSyxjQUFjckosQ0FBQyxHQUFHd0o7SUFDakYsSUFBSVQsYUFBYTtJQUNqQixJQUFJTSxjQUFjTSxRQUFRLEVBQUU7UUFDMUIsSUFBSUMsU0FBU2xLLEtBQUtxQixLQUFLLENBQUNoQjtRQUN4QixJQUFJOEosU0FBU25LLEtBQUtxQixLQUFLLENBQUNmO1FBQ3hCLElBQUk4SixRQUFRcEssS0FBS3FFLElBQUksQ0FBQ2tGLElBQUlsSixJQUFJNko7UUFDOUIsSUFBSUcsUUFBUXJLLEtBQUtxRSxJQUFJLENBQUNpRixJQUFJaEosSUFBSTZKO1FBQzlCZCxhQUFhO1lBQUVoSixHQUFHNko7WUFBUTVKLEdBQUc2SjtZQUFRWixHQUFHYTtZQUFPZCxHQUFHZTtRQUFNO0lBQzFEO0lBQ0EsT0FBTztRQUFFaEs7UUFBR0M7UUFBR2dKO1FBQUdDO1FBQUdGO0lBQVc7QUFDbEM7QUFDQSxJQUFJaUIsa0JBQWtCO0lBQ3BCLElBQUk7UUFDRixJQUFJQyxTQUFTQyxPQUFPLENBQUMsSUFBSUQ7SUFDM0IsRUFBRSxPQUFPRSxHQUFHO1FBQ1YsT0FBTztJQUNUO0lBQ0EsT0FBTztBQUNUO0FBQ0EsU0FBU0MsYUFBYUMsS0FBSztJQUN6QixNQUFNQyxLQUFLRCxPQUFPLEVBQ2hCM1AsS0FBSyxFQUNMK0IsT0FBT3dMLFlBQVksRUFDbkJzQyxRQUFRckMsYUFBYSxFQUNyQnNDLFVBQVVyQyxlQUFlLEVBQ3pCc0MsVUFBVXJDLGVBQWUsRUFDekJnQixnQkFBZ0JmLHFCQUFxQixFQUNyQ3FDLEtBQUssRUFDTHJCLGFBQWEsRUFDZCxHQUFHaUIsSUFBSUssYUFBYXhQLFVBQVVtUCxJQUFJO1FBQ2pDO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7S0FDRDtJQUNELE1BQU1NLFNBQVN2QixpQkFBaUIsT0FBTyxLQUFLLElBQUlBLGNBQWN3QixHQUFHO0lBQ2pFLE1BQU1DLFVBQVVyUCw2Q0FBTUEsQ0FBQztJQUN2QixNQUFNc1AsU0FBU3RQLDZDQUFNQSxDQUFDO0lBQ3RCLE1BQU0sQ0FBQ3VQLGFBQWFDLGlCQUFpQixHQUFHdFAsK0NBQVFBLENBQUM7SUFDakRELGdEQUFTQSxDQUFDO1FBQ1IsSUFBSW9QLFFBQVFJLE9BQU8sSUFBSSxNQUFNO1lBQzNCLE1BQU1DLFNBQVNMLFFBQVFJLE9BQU87WUFDOUIsTUFBTUUsTUFBTUQsT0FBT0UsVUFBVSxDQUFDO1lBQzlCLElBQUksQ0FBQ0QsS0FBSztnQkFDUjtZQUNGO1lBQ0EsSUFBSWpDLFFBQVF4QixrQkFBa0J2QyxNQUFNLENBQUMzSCxVQUFVLENBQUMvQyxPQUFPa04sZUFBZSxDQUFDMkMsTUFBTSxFQUFFdEssVUFBVTtZQUN6RixNQUFNd0ksU0FBU1csZ0JBQWdCZCxjQUFjO1lBQzdDLE1BQU1nQixXQUFXSCxNQUFNM0osTUFBTSxHQUFHaUosU0FBUztZQUN6QyxNQUFNNkMsMEJBQTBCcEMsaUJBQWlCQyxPQUFPMU0sTUFBTTJNLGVBQWVDO1lBQzdFLE1BQU1rQyxRQUFRUixPQUFPRyxPQUFPO1lBQzVCLE1BQU1NLG9CQUFvQkYsMkJBQTJCLFFBQVFDLFVBQVUsUUFBUUEsTUFBTUUsUUFBUSxJQUFJRixNQUFNRyxhQUFhLEtBQUssS0FBS0gsTUFBTUksWUFBWSxLQUFLO1lBQ3JKLElBQUlILG1CQUFtQjtnQkFDckIsSUFBSUYsd0JBQXdCdkMsVUFBVSxJQUFJLE1BQU07b0JBQzlDSSxRQUFRTCxnQkFBZ0JLLE9BQU9tQyx3QkFBd0J2QyxVQUFVO2dCQUNuRTtZQUNGO1lBQ0EsTUFBTTZDLGFBQWFDLE9BQU9DLGdCQUFnQixJQUFJO1lBQzlDWCxPQUFPekIsTUFBTSxHQUFHeUIsT0FBTzFCLEtBQUssR0FBR2hOLE9BQU9tUDtZQUN0QyxNQUFNcEMsUUFBUS9NLE9BQU82TSxXQUFXc0M7WUFDaENSLElBQUk1QixLQUFLLENBQUNBLE9BQU9BO1lBQ2pCNEIsSUFBSVcsU0FBUyxHQUFHdkI7WUFDaEJZLElBQUlZLFFBQVEsQ0FBQyxHQUFHLEdBQUcxQyxVQUFVQTtZQUM3QjhCLElBQUlXLFNBQVMsR0FBR3RCO1lBQ2hCLElBQUlULGlCQUFpQjtnQkFDbkJvQixJQUFJYSxJQUFJLENBQUMsSUFBSWhDLE9BQU96QixhQUFhVyxPQUFPVjtZQUMxQyxPQUFPO2dCQUNMVSxNQUFNdEosT0FBTyxDQUFDLFNBQVNuRCxHQUFHLEVBQUV3UCxHQUFHO29CQUM3QnhQLElBQUltRCxPQUFPLENBQUMsU0FBUytJLElBQUksRUFBRXVELEdBQUc7d0JBQzVCLElBQUl2RCxNQUFNOzRCQUNSd0MsSUFBSVksUUFBUSxDQUFDRyxNQUFNMUQsUUFBUXlELE1BQU16RCxRQUFRLEdBQUc7d0JBQzlDO29CQUNGO2dCQUNGO1lBQ0Y7WUFDQSxJQUFJK0MsbUJBQW1CO2dCQUNyQkosSUFBSWdCLFNBQVMsQ0FBQ2IsT0FBT0Qsd0JBQXdCdkwsQ0FBQyxHQUFHMEksUUFBUTZDLHdCQUF3QnRMLENBQUMsR0FBR3lJLFFBQVE2Qyx3QkFBd0JyQyxDQUFDLEVBQUVxQyx3QkFBd0J0QyxDQUFDO1lBQ25KO1FBQ0Y7SUFDRjtJQUNBdE4sZ0RBQVNBLENBQUM7UUFDUnVQLGlCQUFpQjtJQUNuQixHQUFHO1FBQUNMO0tBQU87SUFDWCxNQUFNeUIsY0FBY3ZSLGVBQWU7UUFBRTRPLFFBQVFqTjtRQUFNZ04sT0FBT2hOO0lBQUssR0FBR2lPO0lBQ2xFLElBQUk0QixNQUFNO0lBQ1YsSUFBSTFCLFVBQVUsTUFBTTtRQUNsQjBCLE1BQU0sYUFBYSxpQkFBRzlRLDBEQUFtQixDQUFDLE9BQU87WUFDL0NxUCxLQUFLRDtZQUNMblEsS0FBS21RO1lBQ0xGLE9BQU87Z0JBQUU4QixTQUFTO1lBQU87WUFDekJDLFFBQVE7Z0JBQ054QixpQkFBaUI7WUFDbkI7WUFDQXlCLEtBQUszQjtRQUNQO0lBQ0Y7SUFDQSxPQUFPLGFBQWEsaUJBQUd2UCwwREFBbUIsQ0FBQ0EsdURBQWMsRUFBRSxNQUFNLGFBQWEsaUJBQUdBLDBEQUFtQixDQUFDLFVBQVVWLGVBQWU7UUFDNUg0UCxPQUFPMkI7UUFDUDNDLFFBQVFqTjtRQUNSZ04sT0FBT2hOO1FBQ1BpUSxLQUFLNUI7SUFDUCxHQUFHSCxjQUFjMkI7QUFDbkI7QUFDQSxTQUFTTSxVQUFVdkMsS0FBSztJQUN0QixNQUFNQyxLQUFLRCxPQUFPLEVBQ2hCM1AsS0FBSyxFQUNMK0IsT0FBT3dMLFlBQVksRUFDbkJzQyxRQUFRckMsYUFBYSxFQUNyQnNDLFVBQVVyQyxlQUFlLEVBQ3pCc0MsVUFBVXJDLGVBQWUsRUFDekJnQixnQkFBZ0JmLHFCQUFxQixFQUNyQ2dCLGFBQWEsRUFDZCxHQUFHaUIsSUFBSUssYUFBYXhQLFVBQVVtUCxJQUFJO1FBQ2pDO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO0tBQ0Q7SUFDRCxJQUFJbkIsUUFBUXhCLGtCQUFrQnZDLE1BQU0sQ0FBQzNILFVBQVUsQ0FBQy9DLE9BQU9rTixlQUFlLENBQUMyQyxNQUFNLEVBQUV0SyxVQUFVO0lBQ3pGLE1BQU13SSxTQUFTVyxnQkFBZ0JkLGNBQWM7SUFDN0MsTUFBTWdCLFdBQVdILE1BQU0zSixNQUFNLEdBQUdpSixTQUFTO0lBQ3pDLE1BQU02QywwQkFBMEJwQyxpQkFBaUJDLE9BQU8xTSxNQUFNMk0sZUFBZUM7SUFDN0UsSUFBSWtDLFFBQVE7SUFDWixJQUFJbEMsaUJBQWlCLFFBQVFpQywyQkFBMkIsTUFBTTtRQUM1RCxJQUFJQSx3QkFBd0J2QyxVQUFVLElBQUksTUFBTTtZQUM5Q0ksUUFBUUwsZ0JBQWdCSyxPQUFPbUMsd0JBQXdCdkMsVUFBVTtRQUNuRTtRQUNBd0MsUUFBUSxhQUFhLGlCQUFHL1AsMERBQW1CLENBQUMsU0FBUztZQUNuRHFSLFdBQVd4RCxjQUFjd0IsR0FBRztZQUM1Qm5CLFFBQVE0Qix3QkFBd0J0QyxDQUFDO1lBQ2pDUyxPQUFPNkIsd0JBQXdCckMsQ0FBQztZQUNoQ2xKLEdBQUd1TCx3QkFBd0J2TCxDQUFDLEdBQUcwSTtZQUMvQnpJLEdBQUdzTCx3QkFBd0J0TCxDQUFDLEdBQUd5STtZQUMvQnFFLHFCQUFxQjtRQUN2QjtJQUNGO0lBQ0EsTUFBTUMsU0FBU3ZFLGFBQWFXLE9BQU9WO0lBQ25DLE9BQU8sYUFBYSxpQkFBR2pOLDBEQUFtQixDQUFDLE9BQU9WLGVBQWU7UUFDL0Q0TyxRQUFRak47UUFDUmdOLE9BQU9oTjtRQUNQdVEsU0FBUyxDQUFDLElBQUksRUFBRTFELFNBQVMsQ0FBQyxFQUFFQSxTQUFTLENBQUM7SUFDeEMsR0FBR3FCLGFBQWEsYUFBYSxpQkFBR25QLDBEQUFtQixDQUFDLFFBQVE7UUFDMUR5USxNQUFNekI7UUFDTnlDLEdBQUcsQ0FBQyxNQUFNLEVBQUUzRCxTQUFTLENBQUMsRUFBRUEsU0FBUyxHQUFHLENBQUM7UUFDckM0RCxnQkFBZ0I7SUFDbEIsSUFBSSxhQUFhLGlCQUFHMVIsMERBQW1CLENBQUMsUUFBUTtRQUM5Q3lRLE1BQU14QjtRQUNOd0MsR0FBR0Y7UUFDSEcsZ0JBQWdCO0lBQ2xCLElBQUkzQjtBQUNOO0FBQ0EsSUFBSTRCLFNBQVMsQ0FBQzlDO0lBQ1osTUFBTUMsS0FBS0QsT0FBTyxFQUFFK0MsUUFBUSxFQUFFLEdBQUc5QyxJQUFJSyxhQUFheFAsVUFBVW1QLElBQUk7UUFBQztLQUFXO0lBQzVFLElBQUk4QyxhQUFhLE9BQU87UUFDdEIsT0FBTyxhQUFhLGlCQUFHNVIsMERBQW1CLENBQUNvUixXQUFXOVIsZUFBZSxDQUFDLEdBQUc2UDtJQUMzRTtJQUNBLE9BQU8sYUFBYSxpQkFBR25QLDBEQUFtQixDQUFDNE8sY0FBY3RQLGVBQWUsQ0FBQyxHQUFHNlA7QUFDOUU7QUFLRSIsInNvdXJjZXMiOlsid2VicGFjazovL0BzZS0yL25leHRqcy8uL25vZGVfbW9kdWxlcy9xcmNvZGUucmVhY3QvbGliL2VzbS9pbmRleC5qcz9jNGFhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX29ialJlc3QgPSAoc291cmNlLCBleGNsdWRlKSA9PiB7XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKHNvdXJjZSwgcHJvcCkgJiYgZXhjbHVkZS5pbmRleE9mKHByb3ApIDwgMClcbiAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgaWYgKHNvdXJjZSAhPSBudWxsICYmIF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKHNvdXJjZSkpIHtcbiAgICAgIGlmIChleGNsdWRlLmluZGV4T2YocHJvcCkgPCAwICYmIF9fcHJvcElzRW51bS5jYWxsKHNvdXJjZSwgcHJvcCkpXG4gICAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vLyBzcmMvaW5kZXgudHN4XG5pbXBvcnQgUmVhY3QsIHsgdXNlUmVmLCB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy90aGlyZC1wYXJ0eS9xcmNvZGVnZW4vaW5kZXgudHNcbi8qKlxuICogQGxpY2Vuc2UgUVIgQ29kZSBnZW5lcmF0b3IgbGlicmFyeSAoVHlwZVNjcmlwdClcbiAqIENvcHlyaWdodCAoYykgUHJvamVjdCBOYXl1a2kuXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlUXG4gKi9cbnZhciBxcmNvZGVnZW47XG4oKHFyY29kZWdlbjIpID0+IHtcbiAgY29uc3QgX1FyQ29kZSA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2ZXJzaW9uLCBlcnJvckNvcnJlY3Rpb25MZXZlbCwgZGF0YUNvZGV3b3JkcywgbXNrKSB7XG4gICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgdGhpcy5lcnJvckNvcnJlY3Rpb25MZXZlbCA9IGVycm9yQ29ycmVjdGlvbkxldmVsO1xuICAgICAgdGhpcy5tb2R1bGVzID0gW107XG4gICAgICB0aGlzLmlzRnVuY3Rpb24gPSBbXTtcbiAgICAgIGlmICh2ZXJzaW9uIDwgX1FyQ29kZS5NSU5fVkVSU0lPTiB8fCB2ZXJzaW9uID4gX1FyQ29kZS5NQVhfVkVSU0lPTilcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJWZXJzaW9uIHZhbHVlIG91dCBvZiByYW5nZVwiKTtcbiAgICAgIGlmIChtc2sgPCAtMSB8fCBtc2sgPiA3KVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk1hc2sgdmFsdWUgb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgdGhpcy5zaXplID0gdmVyc2lvbiAqIDQgKyAxNztcbiAgICAgIGxldCByb3cgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zaXplOyBpKyspXG4gICAgICAgIHJvdy5wdXNoKGZhbHNlKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zaXplOyBpKyspIHtcbiAgICAgICAgdGhpcy5tb2R1bGVzLnB1c2gocm93LnNsaWNlKCkpO1xuICAgICAgICB0aGlzLmlzRnVuY3Rpb24ucHVzaChyb3cuc2xpY2UoKSk7XG4gICAgICB9XG4gICAgICB0aGlzLmRyYXdGdW5jdGlvblBhdHRlcm5zKCk7XG4gICAgICBjb25zdCBhbGxDb2Rld29yZHMgPSB0aGlzLmFkZEVjY0FuZEludGVybGVhdmUoZGF0YUNvZGV3b3Jkcyk7XG4gICAgICB0aGlzLmRyYXdDb2Rld29yZHMoYWxsQ29kZXdvcmRzKTtcbiAgICAgIGlmIChtc2sgPT0gLTEpIHtcbiAgICAgICAgbGV0IG1pblBlbmFsdHkgPSAxZTk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5hcHBseU1hc2soaSk7XG4gICAgICAgICAgdGhpcy5kcmF3Rm9ybWF0Qml0cyhpKTtcbiAgICAgICAgICBjb25zdCBwZW5hbHR5ID0gdGhpcy5nZXRQZW5hbHR5U2NvcmUoKTtcbiAgICAgICAgICBpZiAocGVuYWx0eSA8IG1pblBlbmFsdHkpIHtcbiAgICAgICAgICAgIG1zayA9IGk7XG4gICAgICAgICAgICBtaW5QZW5hbHR5ID0gcGVuYWx0eTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5hcHBseU1hc2soaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFzc2VydCgwIDw9IG1zayAmJiBtc2sgPD0gNyk7XG4gICAgICB0aGlzLm1hc2sgPSBtc2s7XG4gICAgICB0aGlzLmFwcGx5TWFzayhtc2spO1xuICAgICAgdGhpcy5kcmF3Rm9ybWF0Qml0cyhtc2spO1xuICAgICAgdGhpcy5pc0Z1bmN0aW9uID0gW107XG4gICAgfVxuICAgIHN0YXRpYyBlbmNvZGVUZXh0KHRleHQsIGVjbCkge1xuICAgICAgY29uc3Qgc2VncyA9IHFyY29kZWdlbjIuUXJTZWdtZW50Lm1ha2VTZWdtZW50cyh0ZXh0KTtcbiAgICAgIHJldHVybiBfUXJDb2RlLmVuY29kZVNlZ21lbnRzKHNlZ3MsIGVjbCk7XG4gICAgfVxuICAgIHN0YXRpYyBlbmNvZGVCaW5hcnkoZGF0YSwgZWNsKSB7XG4gICAgICBjb25zdCBzZWcgPSBxcmNvZGVnZW4yLlFyU2VnbWVudC5tYWtlQnl0ZXMoZGF0YSk7XG4gICAgICByZXR1cm4gX1FyQ29kZS5lbmNvZGVTZWdtZW50cyhbc2VnXSwgZWNsKTtcbiAgICB9XG4gICAgc3RhdGljIGVuY29kZVNlZ21lbnRzKHNlZ3MsIGVjbCwgbWluVmVyc2lvbiA9IDEsIG1heFZlcnNpb24gPSA0MCwgbWFzayA9IC0xLCBib29zdEVjbCA9IHRydWUpIHtcbiAgICAgIGlmICghKF9RckNvZGUuTUlOX1ZFUlNJT04gPD0gbWluVmVyc2lvbiAmJiBtaW5WZXJzaW9uIDw9IG1heFZlcnNpb24gJiYgbWF4VmVyc2lvbiA8PSBfUXJDb2RlLk1BWF9WRVJTSU9OKSB8fCBtYXNrIDwgLTEgfHwgbWFzayA+IDcpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCB2YWx1ZVwiKTtcbiAgICAgIGxldCB2ZXJzaW9uO1xuICAgICAgbGV0IGRhdGFVc2VkQml0cztcbiAgICAgIGZvciAodmVyc2lvbiA9IG1pblZlcnNpb247IDsgdmVyc2lvbisrKSB7XG4gICAgICAgIGNvbnN0IGRhdGFDYXBhY2l0eUJpdHMyID0gX1FyQ29kZS5nZXROdW1EYXRhQ29kZXdvcmRzKHZlcnNpb24sIGVjbCkgKiA4O1xuICAgICAgICBjb25zdCB1c2VkQml0cyA9IFFyU2VnbWVudC5nZXRUb3RhbEJpdHMoc2VncywgdmVyc2lvbik7XG4gICAgICAgIGlmICh1c2VkQml0cyA8PSBkYXRhQ2FwYWNpdHlCaXRzMikge1xuICAgICAgICAgIGRhdGFVc2VkQml0cyA9IHVzZWRCaXRzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2ZXJzaW9uID49IG1heFZlcnNpb24pXG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJEYXRhIHRvbyBsb25nXCIpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBuZXdFY2wgb2YgW19RckNvZGUuRWNjLk1FRElVTSwgX1FyQ29kZS5FY2MuUVVBUlRJTEUsIF9RckNvZGUuRWNjLkhJR0hdKSB7XG4gICAgICAgIGlmIChib29zdEVjbCAmJiBkYXRhVXNlZEJpdHMgPD0gX1FyQ29kZS5nZXROdW1EYXRhQ29kZXdvcmRzKHZlcnNpb24sIG5ld0VjbCkgKiA4KVxuICAgICAgICAgIGVjbCA9IG5ld0VjbDtcbiAgICAgIH1cbiAgICAgIGxldCBiYiA9IFtdO1xuICAgICAgZm9yIChjb25zdCBzZWcgb2Ygc2Vncykge1xuICAgICAgICBhcHBlbmRCaXRzKHNlZy5tb2RlLm1vZGVCaXRzLCA0LCBiYik7XG4gICAgICAgIGFwcGVuZEJpdHMoc2VnLm51bUNoYXJzLCBzZWcubW9kZS5udW1DaGFyQ291bnRCaXRzKHZlcnNpb24pLCBiYik7XG4gICAgICAgIGZvciAoY29uc3QgYiBvZiBzZWcuZ2V0RGF0YSgpKVxuICAgICAgICAgIGJiLnB1c2goYik7XG4gICAgICB9XG4gICAgICBhc3NlcnQoYmIubGVuZ3RoID09IGRhdGFVc2VkQml0cyk7XG4gICAgICBjb25zdCBkYXRhQ2FwYWNpdHlCaXRzID0gX1FyQ29kZS5nZXROdW1EYXRhQ29kZXdvcmRzKHZlcnNpb24sIGVjbCkgKiA4O1xuICAgICAgYXNzZXJ0KGJiLmxlbmd0aCA8PSBkYXRhQ2FwYWNpdHlCaXRzKTtcbiAgICAgIGFwcGVuZEJpdHMoMCwgTWF0aC5taW4oNCwgZGF0YUNhcGFjaXR5Qml0cyAtIGJiLmxlbmd0aCksIGJiKTtcbiAgICAgIGFwcGVuZEJpdHMoMCwgKDggLSBiYi5sZW5ndGggJSA4KSAlIDgsIGJiKTtcbiAgICAgIGFzc2VydChiYi5sZW5ndGggJSA4ID09IDApO1xuICAgICAgZm9yIChsZXQgcGFkQnl0ZSA9IDIzNjsgYmIubGVuZ3RoIDwgZGF0YUNhcGFjaXR5Qml0czsgcGFkQnl0ZSBePSAyMzYgXiAxNylcbiAgICAgICAgYXBwZW5kQml0cyhwYWRCeXRlLCA4LCBiYik7XG4gICAgICBsZXQgZGF0YUNvZGV3b3JkcyA9IFtdO1xuICAgICAgd2hpbGUgKGRhdGFDb2Rld29yZHMubGVuZ3RoICogOCA8IGJiLmxlbmd0aClcbiAgICAgICAgZGF0YUNvZGV3b3Jkcy5wdXNoKDApO1xuICAgICAgYmIuZm9yRWFjaCgoYiwgaSkgPT4gZGF0YUNvZGV3b3Jkc1tpID4+PiAzXSB8PSBiIDw8IDcgLSAoaSAmIDcpKTtcbiAgICAgIHJldHVybiBuZXcgX1FyQ29kZSh2ZXJzaW9uLCBlY2wsIGRhdGFDb2Rld29yZHMsIG1hc2spO1xuICAgIH1cbiAgICBnZXRNb2R1bGUoeCwgeSkge1xuICAgICAgcmV0dXJuIDAgPD0geCAmJiB4IDwgdGhpcy5zaXplICYmIDAgPD0geSAmJiB5IDwgdGhpcy5zaXplICYmIHRoaXMubW9kdWxlc1t5XVt4XTtcbiAgICB9XG4gICAgZ2V0TW9kdWxlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLm1vZHVsZXM7XG4gICAgfVxuICAgIGRyYXdGdW5jdGlvblBhdHRlcm5zKCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNpemU7IGkrKykge1xuICAgICAgICB0aGlzLnNldEZ1bmN0aW9uTW9kdWxlKDYsIGksIGkgJSAyID09IDApO1xuICAgICAgICB0aGlzLnNldEZ1bmN0aW9uTW9kdWxlKGksIDYsIGkgJSAyID09IDApO1xuICAgICAgfVxuICAgICAgdGhpcy5kcmF3RmluZGVyUGF0dGVybigzLCAzKTtcbiAgICAgIHRoaXMuZHJhd0ZpbmRlclBhdHRlcm4odGhpcy5zaXplIC0gNCwgMyk7XG4gICAgICB0aGlzLmRyYXdGaW5kZXJQYXR0ZXJuKDMsIHRoaXMuc2l6ZSAtIDQpO1xuICAgICAgY29uc3QgYWxpZ25QYXRQb3MgPSB0aGlzLmdldEFsaWdubWVudFBhdHRlcm5Qb3NpdGlvbnMoKTtcbiAgICAgIGNvbnN0IG51bUFsaWduID0gYWxpZ25QYXRQb3MubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1BbGlnbjsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtQWxpZ247IGorKykge1xuICAgICAgICAgIGlmICghKGkgPT0gMCAmJiBqID09IDAgfHwgaSA9PSAwICYmIGogPT0gbnVtQWxpZ24gLSAxIHx8IGkgPT0gbnVtQWxpZ24gLSAxICYmIGogPT0gMCkpXG4gICAgICAgICAgICB0aGlzLmRyYXdBbGlnbm1lbnRQYXR0ZXJuKGFsaWduUGF0UG9zW2ldLCBhbGlnblBhdFBvc1tqXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZHJhd0Zvcm1hdEJpdHMoMCk7XG4gICAgICB0aGlzLmRyYXdWZXJzaW9uKCk7XG4gICAgfVxuICAgIGRyYXdGb3JtYXRCaXRzKG1hc2spIHtcbiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmVycm9yQ29ycmVjdGlvbkxldmVsLmZvcm1hdEJpdHMgPDwgMyB8IG1hc2s7XG4gICAgICBsZXQgcmVtID0gZGF0YTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKylcbiAgICAgICAgcmVtID0gcmVtIDw8IDEgXiAocmVtID4+PiA5KSAqIDEzMzU7XG4gICAgICBjb25zdCBiaXRzID0gKGRhdGEgPDwgMTAgfCByZW0pIF4gMjE1MjI7XG4gICAgICBhc3NlcnQoYml0cyA+Pj4gMTUgPT0gMCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSA1OyBpKyspXG4gICAgICAgIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUoOCwgaSwgZ2V0Qml0KGJpdHMsIGkpKTtcbiAgICAgIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUoOCwgNywgZ2V0Qml0KGJpdHMsIDYpKTtcbiAgICAgIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUoOCwgOCwgZ2V0Qml0KGJpdHMsIDcpKTtcbiAgICAgIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUoNywgOCwgZ2V0Qml0KGJpdHMsIDgpKTtcbiAgICAgIGZvciAobGV0IGkgPSA5OyBpIDwgMTU7IGkrKylcbiAgICAgICAgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZSgxNCAtIGksIDgsIGdldEJpdChiaXRzLCBpKSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkrKylcbiAgICAgICAgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZSh0aGlzLnNpemUgLSAxIC0gaSwgOCwgZ2V0Qml0KGJpdHMsIGkpKTtcbiAgICAgIGZvciAobGV0IGkgPSA4OyBpIDwgMTU7IGkrKylcbiAgICAgICAgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZSg4LCB0aGlzLnNpemUgLSAxNSArIGksIGdldEJpdChiaXRzLCBpKSk7XG4gICAgICB0aGlzLnNldEZ1bmN0aW9uTW9kdWxlKDgsIHRoaXMuc2l6ZSAtIDgsIHRydWUpO1xuICAgIH1cbiAgICBkcmF3VmVyc2lvbigpIHtcbiAgICAgIGlmICh0aGlzLnZlcnNpb24gPCA3KVxuICAgICAgICByZXR1cm47XG4gICAgICBsZXQgcmVtID0gdGhpcy52ZXJzaW9uO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMjsgaSsrKVxuICAgICAgICByZW0gPSByZW0gPDwgMSBeIChyZW0gPj4+IDExKSAqIDc5NzM7XG4gICAgICBjb25zdCBiaXRzID0gdGhpcy52ZXJzaW9uIDw8IDEyIHwgcmVtO1xuICAgICAgYXNzZXJ0KGJpdHMgPj4+IDE4ID09IDApO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxODsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNvbG9yID0gZ2V0Qml0KGJpdHMsIGkpO1xuICAgICAgICBjb25zdCBhID0gdGhpcy5zaXplIC0gMTEgKyBpICUgMztcbiAgICAgICAgY29uc3QgYiA9IE1hdGguZmxvb3IoaSAvIDMpO1xuICAgICAgICB0aGlzLnNldEZ1bmN0aW9uTW9kdWxlKGEsIGIsIGNvbG9yKTtcbiAgICAgICAgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZShiLCBhLCBjb2xvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGRyYXdGaW5kZXJQYXR0ZXJuKHgsIHkpIHtcbiAgICAgIGZvciAobGV0IGR5ID0gLTQ7IGR5IDw9IDQ7IGR5KyspIHtcbiAgICAgICAgZm9yIChsZXQgZHggPSAtNDsgZHggPD0gNDsgZHgrKykge1xuICAgICAgICAgIGNvbnN0IGRpc3QgPSBNYXRoLm1heChNYXRoLmFicyhkeCksIE1hdGguYWJzKGR5KSk7XG4gICAgICAgICAgY29uc3QgeHggPSB4ICsgZHg7XG4gICAgICAgICAgY29uc3QgeXkgPSB5ICsgZHk7XG4gICAgICAgICAgaWYgKDAgPD0geHggJiYgeHggPCB0aGlzLnNpemUgJiYgMCA8PSB5eSAmJiB5eSA8IHRoaXMuc2l6ZSlcbiAgICAgICAgICAgIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUoeHgsIHl5LCBkaXN0ICE9IDIgJiYgZGlzdCAhPSA0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBkcmF3QWxpZ25tZW50UGF0dGVybih4LCB5KSB7XG4gICAgICBmb3IgKGxldCBkeSA9IC0yOyBkeSA8PSAyOyBkeSsrKSB7XG4gICAgICAgIGZvciAobGV0IGR4ID0gLTI7IGR4IDw9IDI7IGR4KyspXG4gICAgICAgICAgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZSh4ICsgZHgsIHkgKyBkeSwgTWF0aC5tYXgoTWF0aC5hYnMoZHgpLCBNYXRoLmFicyhkeSkpICE9IDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBzZXRGdW5jdGlvbk1vZHVsZSh4LCB5LCBpc0RhcmspIHtcbiAgICAgIHRoaXMubW9kdWxlc1t5XVt4XSA9IGlzRGFyaztcbiAgICAgIHRoaXMuaXNGdW5jdGlvblt5XVt4XSA9IHRydWU7XG4gICAgfVxuICAgIGFkZEVjY0FuZEludGVybGVhdmUoZGF0YSkge1xuICAgICAgY29uc3QgdmVyID0gdGhpcy52ZXJzaW9uO1xuICAgICAgY29uc3QgZWNsID0gdGhpcy5lcnJvckNvcnJlY3Rpb25MZXZlbDtcbiAgICAgIGlmIChkYXRhLmxlbmd0aCAhPSBfUXJDb2RlLmdldE51bURhdGFDb2Rld29yZHModmVyLCBlY2wpKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgYXJndW1lbnRcIik7XG4gICAgICBjb25zdCBudW1CbG9ja3MgPSBfUXJDb2RlLk5VTV9FUlJPUl9DT1JSRUNUSU9OX0JMT0NLU1tlY2wub3JkaW5hbF1bdmVyXTtcbiAgICAgIGNvbnN0IGJsb2NrRWNjTGVuID0gX1FyQ29kZS5FQ0NfQ09ERVdPUkRTX1BFUl9CTE9DS1tlY2wub3JkaW5hbF1bdmVyXTtcbiAgICAgIGNvbnN0IHJhd0NvZGV3b3JkcyA9IE1hdGguZmxvb3IoX1FyQ29kZS5nZXROdW1SYXdEYXRhTW9kdWxlcyh2ZXIpIC8gOCk7XG4gICAgICBjb25zdCBudW1TaG9ydEJsb2NrcyA9IG51bUJsb2NrcyAtIHJhd0NvZGV3b3JkcyAlIG51bUJsb2NrcztcbiAgICAgIGNvbnN0IHNob3J0QmxvY2tMZW4gPSBNYXRoLmZsb29yKHJhd0NvZGV3b3JkcyAvIG51bUJsb2Nrcyk7XG4gICAgICBsZXQgYmxvY2tzID0gW107XG4gICAgICBjb25zdCByc0RpdiA9IF9RckNvZGUucmVlZFNvbG9tb25Db21wdXRlRGl2aXNvcihibG9ja0VjY0xlbik7XG4gICAgICBmb3IgKGxldCBpID0gMCwgayA9IDA7IGkgPCBudW1CbG9ja3M7IGkrKykge1xuICAgICAgICBsZXQgZGF0ID0gZGF0YS5zbGljZShrLCBrICsgc2hvcnRCbG9ja0xlbiAtIGJsb2NrRWNjTGVuICsgKGkgPCBudW1TaG9ydEJsb2NrcyA/IDAgOiAxKSk7XG4gICAgICAgIGsgKz0gZGF0Lmxlbmd0aDtcbiAgICAgICAgY29uc3QgZWNjID0gX1FyQ29kZS5yZWVkU29sb21vbkNvbXB1dGVSZW1haW5kZXIoZGF0LCByc0Rpdik7XG4gICAgICAgIGlmIChpIDwgbnVtU2hvcnRCbG9ja3MpXG4gICAgICAgICAgZGF0LnB1c2goMCk7XG4gICAgICAgIGJsb2Nrcy5wdXNoKGRhdC5jb25jYXQoZWNjKSk7XG4gICAgICB9XG4gICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2Nrc1swXS5sZW5ndGg7IGkrKykge1xuICAgICAgICBibG9ja3MuZm9yRWFjaCgoYmxvY2ssIGopID0+IHtcbiAgICAgICAgICBpZiAoaSAhPSBzaG9ydEJsb2NrTGVuIC0gYmxvY2tFY2NMZW4gfHwgaiA+PSBudW1TaG9ydEJsb2NrcylcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJsb2NrW2ldKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBhc3NlcnQocmVzdWx0Lmxlbmd0aCA9PSByYXdDb2Rld29yZHMpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZHJhd0NvZGV3b3JkcyhkYXRhKSB7XG4gICAgICBpZiAoZGF0YS5sZW5ndGggIT0gTWF0aC5mbG9vcihfUXJDb2RlLmdldE51bVJhd0RhdGFNb2R1bGVzKHRoaXMudmVyc2lvbikgLyA4KSlcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50XCIpO1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgZm9yIChsZXQgcmlnaHQgPSB0aGlzLnNpemUgLSAxOyByaWdodCA+PSAxOyByaWdodCAtPSAyKSB7XG4gICAgICAgIGlmIChyaWdodCA9PSA2KVxuICAgICAgICAgIHJpZ2h0ID0gNTtcbiAgICAgICAgZm9yIChsZXQgdmVydCA9IDA7IHZlcnQgPCB0aGlzLnNpemU7IHZlcnQrKykge1xuICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMjsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCB4ID0gcmlnaHQgLSBqO1xuICAgICAgICAgICAgY29uc3QgdXB3YXJkID0gKHJpZ2h0ICsgMSAmIDIpID09IDA7XG4gICAgICAgICAgICBjb25zdCB5ID0gdXB3YXJkID8gdGhpcy5zaXplIC0gMSAtIHZlcnQgOiB2ZXJ0O1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRnVuY3Rpb25beV1beF0gJiYgaSA8IGRhdGEubGVuZ3RoICogOCkge1xuICAgICAgICAgICAgICB0aGlzLm1vZHVsZXNbeV1beF0gPSBnZXRCaXQoZGF0YVtpID4+PiAzXSwgNyAtIChpICYgNykpO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhc3NlcnQoaSA9PSBkYXRhLmxlbmd0aCAqIDgpO1xuICAgIH1cbiAgICBhcHBseU1hc2sobWFzaykge1xuICAgICAgaWYgKG1hc2sgPCAwIHx8IG1hc2sgPiA3KVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk1hc2sgdmFsdWUgb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCB0aGlzLnNpemU7IHkrKykge1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMuc2l6ZTsgeCsrKSB7XG4gICAgICAgICAgbGV0IGludmVydDtcbiAgICAgICAgICBzd2l0Y2ggKG1hc2spIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgaW52ZXJ0ID0gKHggKyB5KSAlIDIgPT0gMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGludmVydCA9IHkgJSAyID09IDA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBpbnZlcnQgPSB4ICUgMyA9PSAwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgaW52ZXJ0ID0gKHggKyB5KSAlIDMgPT0gMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIGludmVydCA9IChNYXRoLmZsb29yKHggLyAzKSArIE1hdGguZmxvb3IoeSAvIDIpKSAlIDIgPT0gMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIGludmVydCA9IHggKiB5ICUgMiArIHggKiB5ICUgMyA9PSAwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgaW52ZXJ0ID0gKHggKiB5ICUgMiArIHggKiB5ICUgMykgJSAyID09IDA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBpbnZlcnQgPSAoKHggKyB5KSAlIDIgKyB4ICogeSAlIDMpICUgMiA9PSAwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVhY2hhYmxlXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMuaXNGdW5jdGlvblt5XVt4XSAmJiBpbnZlcnQpXG4gICAgICAgICAgICB0aGlzLm1vZHVsZXNbeV1beF0gPSAhdGhpcy5tb2R1bGVzW3ldW3hdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGdldFBlbmFsdHlTY29yZSgpIHtcbiAgICAgIGxldCByZXN1bHQgPSAwO1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCB0aGlzLnNpemU7IHkrKykge1xuICAgICAgICBsZXQgcnVuQ29sb3IgPSBmYWxzZTtcbiAgICAgICAgbGV0IHJ1blggPSAwO1xuICAgICAgICBsZXQgcnVuSGlzdG9yeSA9IFswLCAwLCAwLCAwLCAwLCAwLCAwXTtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLnNpemU7IHgrKykge1xuICAgICAgICAgIGlmICh0aGlzLm1vZHVsZXNbeV1beF0gPT0gcnVuQ29sb3IpIHtcbiAgICAgICAgICAgIHJ1blgrKztcbiAgICAgICAgICAgIGlmIChydW5YID09IDUpXG4gICAgICAgICAgICAgIHJlc3VsdCArPSBfUXJDb2RlLlBFTkFMVFlfTjE7XG4gICAgICAgICAgICBlbHNlIGlmIChydW5YID4gNSlcbiAgICAgICAgICAgICAgcmVzdWx0Kys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmluZGVyUGVuYWx0eUFkZEhpc3RvcnkocnVuWCwgcnVuSGlzdG9yeSk7XG4gICAgICAgICAgICBpZiAoIXJ1bkNvbG9yKVxuICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5maW5kZXJQZW5hbHR5Q291bnRQYXR0ZXJucyhydW5IaXN0b3J5KSAqIF9RckNvZGUuUEVOQUxUWV9OMztcbiAgICAgICAgICAgIHJ1bkNvbG9yID0gdGhpcy5tb2R1bGVzW3ldW3hdO1xuICAgICAgICAgICAgcnVuWCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSB0aGlzLmZpbmRlclBlbmFsdHlUZXJtaW5hdGVBbmRDb3VudChydW5Db2xvciwgcnVuWCwgcnVuSGlzdG9yeSkgKiBfUXJDb2RlLlBFTkFMVFlfTjM7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMuc2l6ZTsgeCsrKSB7XG4gICAgICAgIGxldCBydW5Db2xvciA9IGZhbHNlO1xuICAgICAgICBsZXQgcnVuWSA9IDA7XG4gICAgICAgIGxldCBydW5IaXN0b3J5ID0gWzAsIDAsIDAsIDAsIDAsIDAsIDBdO1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMuc2l6ZTsgeSsrKSB7XG4gICAgICAgICAgaWYgKHRoaXMubW9kdWxlc1t5XVt4XSA9PSBydW5Db2xvcikge1xuICAgICAgICAgICAgcnVuWSsrO1xuICAgICAgICAgICAgaWYgKHJ1blkgPT0gNSlcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IF9RckNvZGUuUEVOQUxUWV9OMTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHJ1blkgPiA1KVxuICAgICAgICAgICAgICByZXN1bHQrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5maW5kZXJQZW5hbHR5QWRkSGlzdG9yeShydW5ZLCBydW5IaXN0b3J5KTtcbiAgICAgICAgICAgIGlmICghcnVuQ29sb3IpXG4gICAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLmZpbmRlclBlbmFsdHlDb3VudFBhdHRlcm5zKHJ1bkhpc3RvcnkpICogX1FyQ29kZS5QRU5BTFRZX04zO1xuICAgICAgICAgICAgcnVuQ29sb3IgPSB0aGlzLm1vZHVsZXNbeV1beF07XG4gICAgICAgICAgICBydW5ZID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IHRoaXMuZmluZGVyUGVuYWx0eVRlcm1pbmF0ZUFuZENvdW50KHJ1bkNvbG9yLCBydW5ZLCBydW5IaXN0b3J5KSAqIF9RckNvZGUuUEVOQUxUWV9OMztcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5zaXplIC0gMTsgeSsrKSB7XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy5zaXplIC0gMTsgeCsrKSB7XG4gICAgICAgICAgY29uc3QgY29sb3IgPSB0aGlzLm1vZHVsZXNbeV1beF07XG4gICAgICAgICAgaWYgKGNvbG9yID09IHRoaXMubW9kdWxlc1t5XVt4ICsgMV0gJiYgY29sb3IgPT0gdGhpcy5tb2R1bGVzW3kgKyAxXVt4XSAmJiBjb2xvciA9PSB0aGlzLm1vZHVsZXNbeSArIDFdW3ggKyAxXSlcbiAgICAgICAgICAgIHJlc3VsdCArPSBfUXJDb2RlLlBFTkFMVFlfTjI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBkYXJrID0gMDtcbiAgICAgIGZvciAoY29uc3Qgcm93IG9mIHRoaXMubW9kdWxlcylcbiAgICAgICAgZGFyayA9IHJvdy5yZWR1Y2UoKHN1bSwgY29sb3IpID0+IHN1bSArIChjb2xvciA/IDEgOiAwKSwgZGFyayk7XG4gICAgICBjb25zdCB0b3RhbCA9IHRoaXMuc2l6ZSAqIHRoaXMuc2l6ZTtcbiAgICAgIGNvbnN0IGsgPSBNYXRoLmNlaWwoTWF0aC5hYnMoZGFyayAqIDIwIC0gdG90YWwgKiAxMCkgLyB0b3RhbCkgLSAxO1xuICAgICAgYXNzZXJ0KDAgPD0gayAmJiBrIDw9IDkpO1xuICAgICAgcmVzdWx0ICs9IGsgKiBfUXJDb2RlLlBFTkFMVFlfTjQ7XG4gICAgICBhc3NlcnQoMCA8PSByZXN1bHQgJiYgcmVzdWx0IDw9IDI1Njg4ODgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZ2V0QWxpZ25tZW50UGF0dGVyblBvc2l0aW9ucygpIHtcbiAgICAgIGlmICh0aGlzLnZlcnNpb24gPT0gMSlcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG51bUFsaWduID0gTWF0aC5mbG9vcih0aGlzLnZlcnNpb24gLyA3KSArIDI7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSB0aGlzLnZlcnNpb24gPT0gMzIgPyAyNiA6IE1hdGguY2VpbCgodGhpcy52ZXJzaW9uICogNCArIDQpIC8gKG51bUFsaWduICogMiAtIDIpKSAqIDI7XG4gICAgICAgIGxldCByZXN1bHQgPSBbNl07XG4gICAgICAgIGZvciAobGV0IHBvcyA9IHRoaXMuc2l6ZSAtIDc7IHJlc3VsdC5sZW5ndGggPCBudW1BbGlnbjsgcG9zIC09IHN0ZXApXG4gICAgICAgICAgcmVzdWx0LnNwbGljZSgxLCAwLCBwb3MpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZ2V0TnVtUmF3RGF0YU1vZHVsZXModmVyKSB7XG4gICAgICBpZiAodmVyIDwgX1FyQ29kZS5NSU5fVkVSU0lPTiB8fCB2ZXIgPiBfUXJDb2RlLk1BWF9WRVJTSU9OKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlZlcnNpb24gbnVtYmVyIG91dCBvZiByYW5nZVwiKTtcbiAgICAgIGxldCByZXN1bHQgPSAoMTYgKiB2ZXIgKyAxMjgpICogdmVyICsgNjQ7XG4gICAgICBpZiAodmVyID49IDIpIHtcbiAgICAgICAgY29uc3QgbnVtQWxpZ24gPSBNYXRoLmZsb29yKHZlciAvIDcpICsgMjtcbiAgICAgICAgcmVzdWx0IC09ICgyNSAqIG51bUFsaWduIC0gMTApICogbnVtQWxpZ24gLSA1NTtcbiAgICAgICAgaWYgKHZlciA+PSA3KVxuICAgICAgICAgIHJlc3VsdCAtPSAzNjtcbiAgICAgIH1cbiAgICAgIGFzc2VydCgyMDggPD0gcmVzdWx0ICYmIHJlc3VsdCA8PSAyOTY0OCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0TnVtRGF0YUNvZGV3b3Jkcyh2ZXIsIGVjbCkge1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoX1FyQ29kZS5nZXROdW1SYXdEYXRhTW9kdWxlcyh2ZXIpIC8gOCkgLSBfUXJDb2RlLkVDQ19DT0RFV09SRFNfUEVSX0JMT0NLW2VjbC5vcmRpbmFsXVt2ZXJdICogX1FyQ29kZS5OVU1fRVJST1JfQ09SUkVDVElPTl9CTE9DS1NbZWNsLm9yZGluYWxdW3Zlcl07XG4gICAgfVxuICAgIHN0YXRpYyByZWVkU29sb21vbkNvbXB1dGVEaXZpc29yKGRlZ3JlZSkge1xuICAgICAgaWYgKGRlZ3JlZSA8IDEgfHwgZGVncmVlID4gMjU1KVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkRlZ3JlZSBvdXQgb2YgcmFuZ2VcIik7XG4gICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlZ3JlZSAtIDE7IGkrKylcbiAgICAgICAgcmVzdWx0LnB1c2goMCk7XG4gICAgICByZXN1bHQucHVzaCgxKTtcbiAgICAgIGxldCByb290ID0gMTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVncmVlOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByZXN1bHQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICByZXN1bHRbal0gPSBfUXJDb2RlLnJlZWRTb2xvbW9uTXVsdGlwbHkocmVzdWx0W2pdLCByb290KTtcbiAgICAgICAgICBpZiAoaiArIDEgPCByZXN1bHQubGVuZ3RoKVxuICAgICAgICAgICAgcmVzdWx0W2pdIF49IHJlc3VsdFtqICsgMV07XG4gICAgICAgIH1cbiAgICAgICAgcm9vdCA9IF9RckNvZGUucmVlZFNvbG9tb25NdWx0aXBseShyb290LCAyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHN0YXRpYyByZWVkU29sb21vbkNvbXB1dGVSZW1haW5kZXIoZGF0YSwgZGl2aXNvcikge1xuICAgICAgbGV0IHJlc3VsdCA9IGRpdmlzb3IubWFwKChfKSA9PiAwKTtcbiAgICAgIGZvciAoY29uc3QgYiBvZiBkYXRhKSB7XG4gICAgICAgIGNvbnN0IGZhY3RvciA9IGIgXiByZXN1bHQuc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0LnB1c2goMCk7XG4gICAgICAgIGRpdmlzb3IuZm9yRWFjaCgoY29lZiwgaSkgPT4gcmVzdWx0W2ldIF49IF9RckNvZGUucmVlZFNvbG9tb25NdWx0aXBseShjb2VmLCBmYWN0b3IpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHN0YXRpYyByZWVkU29sb21vbk11bHRpcGx5KHgsIHkpIHtcbiAgICAgIGlmICh4ID4+PiA4ICE9IDAgfHwgeSA+Pj4gOCAhPSAwKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ5dGUgb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgbGV0IHogPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDc7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHogPSB6IDw8IDEgXiAoeiA+Pj4gNykgKiAyODU7XG4gICAgICAgIHogXj0gKHkgPj4+IGkgJiAxKSAqIHg7XG4gICAgICB9XG4gICAgICBhc3NlcnQoeiA+Pj4gOCA9PSAwKTtcbiAgICAgIHJldHVybiB6O1xuICAgIH1cbiAgICBmaW5kZXJQZW5hbHR5Q291bnRQYXR0ZXJucyhydW5IaXN0b3J5KSB7XG4gICAgICBjb25zdCBuID0gcnVuSGlzdG9yeVsxXTtcbiAgICAgIGFzc2VydChuIDw9IHRoaXMuc2l6ZSAqIDMpO1xuICAgICAgY29uc3QgY29yZSA9IG4gPiAwICYmIHJ1bkhpc3RvcnlbMl0gPT0gbiAmJiBydW5IaXN0b3J5WzNdID09IG4gKiAzICYmIHJ1bkhpc3RvcnlbNF0gPT0gbiAmJiBydW5IaXN0b3J5WzVdID09IG47XG4gICAgICByZXR1cm4gKGNvcmUgJiYgcnVuSGlzdG9yeVswXSA+PSBuICogNCAmJiBydW5IaXN0b3J5WzZdID49IG4gPyAxIDogMCkgKyAoY29yZSAmJiBydW5IaXN0b3J5WzZdID49IG4gKiA0ICYmIHJ1bkhpc3RvcnlbMF0gPj0gbiA/IDEgOiAwKTtcbiAgICB9XG4gICAgZmluZGVyUGVuYWx0eVRlcm1pbmF0ZUFuZENvdW50KGN1cnJlbnRSdW5Db2xvciwgY3VycmVudFJ1bkxlbmd0aCwgcnVuSGlzdG9yeSkge1xuICAgICAgaWYgKGN1cnJlbnRSdW5Db2xvcikge1xuICAgICAgICB0aGlzLmZpbmRlclBlbmFsdHlBZGRIaXN0b3J5KGN1cnJlbnRSdW5MZW5ndGgsIHJ1bkhpc3RvcnkpO1xuICAgICAgICBjdXJyZW50UnVuTGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRSdW5MZW5ndGggKz0gdGhpcy5zaXplO1xuICAgICAgdGhpcy5maW5kZXJQZW5hbHR5QWRkSGlzdG9yeShjdXJyZW50UnVuTGVuZ3RoLCBydW5IaXN0b3J5KTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmRlclBlbmFsdHlDb3VudFBhdHRlcm5zKHJ1bkhpc3RvcnkpO1xuICAgIH1cbiAgICBmaW5kZXJQZW5hbHR5QWRkSGlzdG9yeShjdXJyZW50UnVuTGVuZ3RoLCBydW5IaXN0b3J5KSB7XG4gICAgICBpZiAocnVuSGlzdG9yeVswXSA9PSAwKVxuICAgICAgICBjdXJyZW50UnVuTGVuZ3RoICs9IHRoaXMuc2l6ZTtcbiAgICAgIHJ1bkhpc3RvcnkucG9wKCk7XG4gICAgICBydW5IaXN0b3J5LnVuc2hpZnQoY3VycmVudFJ1bkxlbmd0aCk7XG4gICAgfVxuICB9O1xuICBsZXQgUXJDb2RlID0gX1FyQ29kZTtcbiAgUXJDb2RlLk1JTl9WRVJTSU9OID0gMTtcbiAgUXJDb2RlLk1BWF9WRVJTSU9OID0gNDA7XG4gIFFyQ29kZS5QRU5BTFRZX04xID0gMztcbiAgUXJDb2RlLlBFTkFMVFlfTjIgPSAzO1xuICBRckNvZGUuUEVOQUxUWV9OMyA9IDQwO1xuICBRckNvZGUuUEVOQUxUWV9ONCA9IDEwO1xuICBRckNvZGUuRUNDX0NPREVXT1JEU19QRVJfQkxPQ0sgPSBbXG4gICAgWy0xLCA3LCAxMCwgMTUsIDIwLCAyNiwgMTgsIDIwLCAyNCwgMzAsIDE4LCAyMCwgMjQsIDI2LCAzMCwgMjIsIDI0LCAyOCwgMzAsIDI4LCAyOCwgMjgsIDI4LCAzMCwgMzAsIDI2LCAyOCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwXSxcbiAgICBbLTEsIDEwLCAxNiwgMjYsIDE4LCAyNCwgMTYsIDE4LCAyMiwgMjIsIDI2LCAzMCwgMjIsIDIyLCAyNCwgMjQsIDI4LCAyOCwgMjYsIDI2LCAyNiwgMjYsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4XSxcbiAgICBbLTEsIDEzLCAyMiwgMTgsIDI2LCAxOCwgMjQsIDE4LCAyMiwgMjAsIDI0LCAyOCwgMjYsIDI0LCAyMCwgMzAsIDI0LCAyOCwgMjgsIDI2LCAzMCwgMjgsIDMwLCAzMCwgMzAsIDMwLCAyOCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwXSxcbiAgICBbLTEsIDE3LCAyOCwgMjIsIDE2LCAyMiwgMjgsIDI2LCAyNiwgMjQsIDI4LCAyNCwgMjgsIDIyLCAyNCwgMjQsIDMwLCAyOCwgMjgsIDI2LCAyOCwgMzAsIDI0LCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwXVxuICBdO1xuICBRckNvZGUuTlVNX0VSUk9SX0NPUlJFQ1RJT05fQkxPQ0tTID0gW1xuICAgIFstMSwgMSwgMSwgMSwgMSwgMSwgMiwgMiwgMiwgMiwgNCwgNCwgNCwgNCwgNCwgNiwgNiwgNiwgNiwgNywgOCwgOCwgOSwgOSwgMTAsIDEyLCAxMiwgMTIsIDEzLCAxNCwgMTUsIDE2LCAxNywgMTgsIDE5LCAxOSwgMjAsIDIxLCAyMiwgMjQsIDI1XSxcbiAgICBbLTEsIDEsIDEsIDEsIDIsIDIsIDQsIDQsIDQsIDUsIDUsIDUsIDgsIDksIDksIDEwLCAxMCwgMTEsIDEzLCAxNCwgMTYsIDE3LCAxNywgMTgsIDIwLCAyMSwgMjMsIDI1LCAyNiwgMjgsIDI5LCAzMSwgMzMsIDM1LCAzNywgMzgsIDQwLCA0MywgNDUsIDQ3LCA0OV0sXG4gICAgWy0xLCAxLCAxLCAyLCAyLCA0LCA0LCA2LCA2LCA4LCA4LCA4LCAxMCwgMTIsIDE2LCAxMiwgMTcsIDE2LCAxOCwgMjEsIDIwLCAyMywgMjMsIDI1LCAyNywgMjksIDM0LCAzNCwgMzUsIDM4LCA0MCwgNDMsIDQ1LCA0OCwgNTEsIDUzLCA1NiwgNTksIDYyLCA2NSwgNjhdLFxuICAgIFstMSwgMSwgMSwgMiwgNCwgNCwgNCwgNSwgNiwgOCwgOCwgMTEsIDExLCAxNiwgMTYsIDE4LCAxNiwgMTksIDIxLCAyNSwgMjUsIDI1LCAzNCwgMzAsIDMyLCAzNSwgMzcsIDQwLCA0MiwgNDUsIDQ4LCA1MSwgNTQsIDU3LCA2MCwgNjMsIDY2LCA3MCwgNzQsIDc3LCA4MV1cbiAgXTtcbiAgcXJjb2RlZ2VuMi5RckNvZGUgPSBRckNvZGU7XG4gIGZ1bmN0aW9uIGFwcGVuZEJpdHModmFsLCBsZW4sIGJiKSB7XG4gICAgaWYgKGxlbiA8IDAgfHwgbGVuID4gMzEgfHwgdmFsID4+PiBsZW4gIT0gMClcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVmFsdWUgb3V0IG9mIHJhbmdlXCIpO1xuICAgIGZvciAobGV0IGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSlcbiAgICAgIGJiLnB1c2godmFsID4+PiBpICYgMSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Qml0KHgsIGkpIHtcbiAgICByZXR1cm4gKHggPj4+IGkgJiAxKSAhPSAwO1xuICB9XG4gIGZ1bmN0aW9uIGFzc2VydChjb25kKSB7XG4gICAgaWYgKCFjb25kKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXNzZXJ0aW9uIGVycm9yXCIpO1xuICB9XG4gIGNvbnN0IF9RclNlZ21lbnQgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IobW9kZSwgbnVtQ2hhcnMsIGJpdERhdGEpIHtcbiAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgICB0aGlzLm51bUNoYXJzID0gbnVtQ2hhcnM7XG4gICAgICB0aGlzLmJpdERhdGEgPSBiaXREYXRhO1xuICAgICAgaWYgKG51bUNoYXJzIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50XCIpO1xuICAgICAgdGhpcy5iaXREYXRhID0gYml0RGF0YS5zbGljZSgpO1xuICAgIH1cbiAgICBzdGF0aWMgbWFrZUJ5dGVzKGRhdGEpIHtcbiAgICAgIGxldCBiYiA9IFtdO1xuICAgICAgZm9yIChjb25zdCBiIG9mIGRhdGEpXG4gICAgICAgIGFwcGVuZEJpdHMoYiwgOCwgYmIpO1xuICAgICAgcmV0dXJuIG5ldyBfUXJTZWdtZW50KF9RclNlZ21lbnQuTW9kZS5CWVRFLCBkYXRhLmxlbmd0aCwgYmIpO1xuICAgIH1cbiAgICBzdGF0aWMgbWFrZU51bWVyaWMoZGlnaXRzKSB7XG4gICAgICBpZiAoIV9RclNlZ21lbnQuaXNOdW1lcmljKGRpZ2l0cykpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiU3RyaW5nIGNvbnRhaW5zIG5vbi1udW1lcmljIGNoYXJhY3RlcnNcIik7XG4gICAgICBsZXQgYmIgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGlnaXRzLmxlbmd0aDsgKSB7XG4gICAgICAgIGNvbnN0IG4gPSBNYXRoLm1pbihkaWdpdHMubGVuZ3RoIC0gaSwgMyk7XG4gICAgICAgIGFwcGVuZEJpdHMocGFyc2VJbnQoZGlnaXRzLnN1YnN0cihpLCBuKSwgMTApLCBuICogMyArIDEsIGJiKTtcbiAgICAgICAgaSArPSBuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBfUXJTZWdtZW50KF9RclNlZ21lbnQuTW9kZS5OVU1FUklDLCBkaWdpdHMubGVuZ3RoLCBiYik7XG4gICAgfVxuICAgIHN0YXRpYyBtYWtlQWxwaGFudW1lcmljKHRleHQpIHtcbiAgICAgIGlmICghX1FyU2VnbWVudC5pc0FscGhhbnVtZXJpYyh0ZXh0KSlcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJTdHJpbmcgY29udGFpbnMgdW5lbmNvZGFibGUgY2hhcmFjdGVycyBpbiBhbHBoYW51bWVyaWMgbW9kZVwiKTtcbiAgICAgIGxldCBiYiA9IFtdO1xuICAgICAgbGV0IGk7XG4gICAgICBmb3IgKGkgPSAwOyBpICsgMiA8PSB0ZXh0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGxldCB0ZW1wID0gX1FyU2VnbWVudC5BTFBIQU5VTUVSSUNfQ0hBUlNFVC5pbmRleE9mKHRleHQuY2hhckF0KGkpKSAqIDQ1O1xuICAgICAgICB0ZW1wICs9IF9RclNlZ21lbnQuQUxQSEFOVU1FUklDX0NIQVJTRVQuaW5kZXhPZih0ZXh0LmNoYXJBdChpICsgMSkpO1xuICAgICAgICBhcHBlbmRCaXRzKHRlbXAsIDExLCBiYik7XG4gICAgICB9XG4gICAgICBpZiAoaSA8IHRleHQubGVuZ3RoKVxuICAgICAgICBhcHBlbmRCaXRzKF9RclNlZ21lbnQuQUxQSEFOVU1FUklDX0NIQVJTRVQuaW5kZXhPZih0ZXh0LmNoYXJBdChpKSksIDYsIGJiKTtcbiAgICAgIHJldHVybiBuZXcgX1FyU2VnbWVudChfUXJTZWdtZW50Lk1vZGUuQUxQSEFOVU1FUklDLCB0ZXh0Lmxlbmd0aCwgYmIpO1xuICAgIH1cbiAgICBzdGF0aWMgbWFrZVNlZ21lbnRzKHRleHQpIHtcbiAgICAgIGlmICh0ZXh0ID09IFwiXCIpXG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIGVsc2UgaWYgKF9RclNlZ21lbnQuaXNOdW1lcmljKHRleHQpKVxuICAgICAgICByZXR1cm4gW19RclNlZ21lbnQubWFrZU51bWVyaWModGV4dCldO1xuICAgICAgZWxzZSBpZiAoX1FyU2VnbWVudC5pc0FscGhhbnVtZXJpYyh0ZXh0KSlcbiAgICAgICAgcmV0dXJuIFtfUXJTZWdtZW50Lm1ha2VBbHBoYW51bWVyaWModGV4dCldO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gW19RclNlZ21lbnQubWFrZUJ5dGVzKF9RclNlZ21lbnQudG9VdGY4Qnl0ZUFycmF5KHRleHQpKV07XG4gICAgfVxuICAgIHN0YXRpYyBtYWtlRWNpKGFzc2lnblZhbCkge1xuICAgICAgbGV0IGJiID0gW107XG4gICAgICBpZiAoYXNzaWduVmFsIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJFQ0kgYXNzaWdubWVudCB2YWx1ZSBvdXQgb2YgcmFuZ2VcIik7XG4gICAgICBlbHNlIGlmIChhc3NpZ25WYWwgPCAxIDw8IDcpXG4gICAgICAgIGFwcGVuZEJpdHMoYXNzaWduVmFsLCA4LCBiYik7XG4gICAgICBlbHNlIGlmIChhc3NpZ25WYWwgPCAxIDw8IDE0KSB7XG4gICAgICAgIGFwcGVuZEJpdHMoMiwgMiwgYmIpO1xuICAgICAgICBhcHBlbmRCaXRzKGFzc2lnblZhbCwgMTQsIGJiKTtcbiAgICAgIH0gZWxzZSBpZiAoYXNzaWduVmFsIDwgMWU2KSB7XG4gICAgICAgIGFwcGVuZEJpdHMoNiwgMywgYmIpO1xuICAgICAgICBhcHBlbmRCaXRzKGFzc2lnblZhbCwgMjEsIGJiKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkVDSSBhc3NpZ25tZW50IHZhbHVlIG91dCBvZiByYW5nZVwiKTtcbiAgICAgIHJldHVybiBuZXcgX1FyU2VnbWVudChfUXJTZWdtZW50Lk1vZGUuRUNJLCAwLCBiYik7XG4gICAgfVxuICAgIHN0YXRpYyBpc051bWVyaWModGV4dCkge1xuICAgICAgcmV0dXJuIF9RclNlZ21lbnQuTlVNRVJJQ19SRUdFWC50ZXN0KHRleHQpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNBbHBoYW51bWVyaWModGV4dCkge1xuICAgICAgcmV0dXJuIF9RclNlZ21lbnQuQUxQSEFOVU1FUklDX1JFR0VYLnRlc3QodGV4dCk7XG4gICAgfVxuICAgIGdldERhdGEoKSB7XG4gICAgICByZXR1cm4gdGhpcy5iaXREYXRhLnNsaWNlKCk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRUb3RhbEJpdHMoc2VncywgdmVyc2lvbikge1xuICAgICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgICBmb3IgKGNvbnN0IHNlZyBvZiBzZWdzKSB7XG4gICAgICAgIGNvbnN0IGNjYml0cyA9IHNlZy5tb2RlLm51bUNoYXJDb3VudEJpdHModmVyc2lvbik7XG4gICAgICAgIGlmIChzZWcubnVtQ2hhcnMgPj0gMSA8PCBjY2JpdHMpXG4gICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICByZXN1bHQgKz0gNCArIGNjYml0cyArIHNlZy5iaXREYXRhLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHN0YXRpYyB0b1V0ZjhCeXRlQXJyYXkoc3RyKSB7XG4gICAgICBzdHIgPSBlbmNvZGVVUkkoc3RyKTtcbiAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzdHIuY2hhckF0KGkpICE9IFwiJVwiKVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VJbnQoc3RyLnN1YnN0cihpICsgMSwgMiksIDE2KSk7XG4gICAgICAgICAgaSArPSAyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfTtcbiAgbGV0IFFyU2VnbWVudCA9IF9RclNlZ21lbnQ7XG4gIFFyU2VnbWVudC5OVU1FUklDX1JFR0VYID0gL15bMC05XSokLztcbiAgUXJTZWdtZW50LkFMUEhBTlVNRVJJQ19SRUdFWCA9IC9eW0EtWjAtOSAkJSorLlxcLzotXSokLztcbiAgUXJTZWdtZW50LkFMUEhBTlVNRVJJQ19DSEFSU0VUID0gXCIwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVogJCUqKy0uLzpcIjtcbiAgcXJjb2RlZ2VuMi5RclNlZ21lbnQgPSBRclNlZ21lbnQ7XG59KShxcmNvZGVnZW4gfHwgKHFyY29kZWdlbiA9IHt9KSk7XG4oKHFyY29kZWdlbjIpID0+IHtcbiAgbGV0IFFyQ29kZTtcbiAgKChRckNvZGUyKSA9PiB7XG4gICAgY29uc3QgX0VjYyA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKG9yZGluYWwsIGZvcm1hdEJpdHMpIHtcbiAgICAgICAgdGhpcy5vcmRpbmFsID0gb3JkaW5hbDtcbiAgICAgICAgdGhpcy5mb3JtYXRCaXRzID0gZm9ybWF0Qml0cztcbiAgICAgIH1cbiAgICB9O1xuICAgIGxldCBFY2MgPSBfRWNjO1xuICAgIEVjYy5MT1cgPSBuZXcgX0VjYygwLCAxKTtcbiAgICBFY2MuTUVESVVNID0gbmV3IF9FY2MoMSwgMCk7XG4gICAgRWNjLlFVQVJUSUxFID0gbmV3IF9FY2MoMiwgMyk7XG4gICAgRWNjLkhJR0ggPSBuZXcgX0VjYygzLCAyKTtcbiAgICBRckNvZGUyLkVjYyA9IEVjYztcbiAgfSkoUXJDb2RlID0gcXJjb2RlZ2VuMi5RckNvZGUgfHwgKHFyY29kZWdlbjIuUXJDb2RlID0ge30pKTtcbn0pKHFyY29kZWdlbiB8fCAocXJjb2RlZ2VuID0ge30pKTtcbigocXJjb2RlZ2VuMikgPT4ge1xuICBsZXQgUXJTZWdtZW50O1xuICAoKFFyU2VnbWVudDIpID0+IHtcbiAgICBjb25zdCBfTW9kZSA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKG1vZGVCaXRzLCBudW1CaXRzQ2hhckNvdW50KSB7XG4gICAgICAgIHRoaXMubW9kZUJpdHMgPSBtb2RlQml0cztcbiAgICAgICAgdGhpcy5udW1CaXRzQ2hhckNvdW50ID0gbnVtQml0c0NoYXJDb3VudDtcbiAgICAgIH1cbiAgICAgIG51bUNoYXJDb3VudEJpdHModmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm51bUJpdHNDaGFyQ291bnRbTWF0aC5mbG9vcigodmVyICsgNykgLyAxNyldO1xuICAgICAgfVxuICAgIH07XG4gICAgbGV0IE1vZGUgPSBfTW9kZTtcbiAgICBNb2RlLk5VTUVSSUMgPSBuZXcgX01vZGUoMSwgWzEwLCAxMiwgMTRdKTtcbiAgICBNb2RlLkFMUEhBTlVNRVJJQyA9IG5ldyBfTW9kZSgyLCBbOSwgMTEsIDEzXSk7XG4gICAgTW9kZS5CWVRFID0gbmV3IF9Nb2RlKDQsIFs4LCAxNiwgMTZdKTtcbiAgICBNb2RlLktBTkpJID0gbmV3IF9Nb2RlKDgsIFs4LCAxMCwgMTJdKTtcbiAgICBNb2RlLkVDSSA9IG5ldyBfTW9kZSg3LCBbMCwgMCwgMF0pO1xuICAgIFFyU2VnbWVudDIuTW9kZSA9IE1vZGU7XG4gIH0pKFFyU2VnbWVudCA9IHFyY29kZWdlbjIuUXJTZWdtZW50IHx8IChxcmNvZGVnZW4yLlFyU2VnbWVudCA9IHt9KSk7XG59KShxcmNvZGVnZW4gfHwgKHFyY29kZWdlbiA9IHt9KSk7XG52YXIgcXJjb2RlZ2VuX2RlZmF1bHQgPSBxcmNvZGVnZW47XG5cbi8vIHNyYy9pbmRleC50c3hcbi8qKlxuICogQGxpY2Vuc2UgcXJjb2RlLnJlYWN0XG4gKiBDb3B5cmlnaHQgKGMpIFBhdWwgTydTaGFubmVzc3lcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBJU0NcbiAqL1xudmFyIEVSUk9SX0xFVkVMX01BUCA9IHtcbiAgTDogcXJjb2RlZ2VuX2RlZmF1bHQuUXJDb2RlLkVjYy5MT1csXG4gIE06IHFyY29kZWdlbl9kZWZhdWx0LlFyQ29kZS5FY2MuTUVESVVNLFxuICBROiBxcmNvZGVnZW5fZGVmYXVsdC5RckNvZGUuRWNjLlFVQVJUSUxFLFxuICBIOiBxcmNvZGVnZW5fZGVmYXVsdC5RckNvZGUuRWNjLkhJR0hcbn07XG52YXIgREVGQVVMVF9TSVpFID0gMTI4O1xudmFyIERFRkFVTFRfTEVWRUwgPSBcIkxcIjtcbnZhciBERUZBVUxUX0JHQ09MT1IgPSBcIiNGRkZGRkZcIjtcbnZhciBERUZBVUxUX0ZHQ09MT1IgPSBcIiMwMDAwMDBcIjtcbnZhciBERUZBVUxUX0lOQ0xVREVNQVJHSU4gPSBmYWxzZTtcbnZhciBNQVJHSU5fU0laRSA9IDQ7XG52YXIgREVGQVVMVF9JTUdfU0NBTEUgPSAwLjE7XG5mdW5jdGlvbiBnZW5lcmF0ZVBhdGgobW9kdWxlcywgbWFyZ2luID0gMCkge1xuICBjb25zdCBvcHMgPSBbXTtcbiAgbW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uKHJvdywgeSkge1xuICAgIGxldCBzdGFydCA9IG51bGw7XG4gICAgcm93LmZvckVhY2goZnVuY3Rpb24oY2VsbCwgeCkge1xuICAgICAgaWYgKCFjZWxsICYmIHN0YXJ0ICE9PSBudWxsKSB7XG4gICAgICAgIG9wcy5wdXNoKGBNJHtzdGFydCArIG1hcmdpbn0gJHt5ICsgbWFyZ2lufWgke3ggLSBzdGFydH12MUgke3N0YXJ0ICsgbWFyZ2lufXpgKTtcbiAgICAgICAgc3RhcnQgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoeCA9PT0gcm93Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgaWYgKCFjZWxsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA9PT0gbnVsbCkge1xuICAgICAgICAgIG9wcy5wdXNoKGBNJHt4ICsgbWFyZ2lufSwke3kgKyBtYXJnaW59IGgxdjFIJHt4ICsgbWFyZ2lufXpgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHMucHVzaChgTSR7c3RhcnQgKyBtYXJnaW59LCR7eSArIG1hcmdpbn0gaCR7eCArIDEgLSBzdGFydH12MUgke3N0YXJ0ICsgbWFyZ2lufXpgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY2VsbCAmJiBzdGFydCA9PT0gbnVsbCkge1xuICAgICAgICBzdGFydCA9IHg7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gb3BzLmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiBleGNhdmF0ZU1vZHVsZXMobW9kdWxlcywgZXhjYXZhdGlvbikge1xuICByZXR1cm4gbW9kdWxlcy5zbGljZSgpLm1hcCgocm93LCB5KSA9PiB7XG4gICAgaWYgKHkgPCBleGNhdmF0aW9uLnkgfHwgeSA+PSBleGNhdmF0aW9uLnkgKyBleGNhdmF0aW9uLmgpIHtcbiAgICAgIHJldHVybiByb3c7XG4gICAgfVxuICAgIHJldHVybiByb3cubWFwKChjZWxsLCB4KSA9PiB7XG4gICAgICBpZiAoeCA8IGV4Y2F2YXRpb24ueCB8fCB4ID49IGV4Y2F2YXRpb24ueCArIGV4Y2F2YXRpb24udykge1xuICAgICAgICByZXR1cm4gY2VsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRJbWFnZVNldHRpbmdzKGNlbGxzLCBzaXplLCBpbmNsdWRlTWFyZ2luLCBpbWFnZVNldHRpbmdzKSB7XG4gIGlmIChpbWFnZVNldHRpbmdzID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBtYXJnaW4gPSBpbmNsdWRlTWFyZ2luID8gTUFSR0lOX1NJWkUgOiAwO1xuICBjb25zdCBudW1DZWxscyA9IGNlbGxzLmxlbmd0aCArIG1hcmdpbiAqIDI7XG4gIGNvbnN0IGRlZmF1bHRTaXplID0gTWF0aC5mbG9vcihzaXplICogREVGQVVMVF9JTUdfU0NBTEUpO1xuICBjb25zdCBzY2FsZSA9IG51bUNlbGxzIC8gc2l6ZTtcbiAgY29uc3QgdyA9IChpbWFnZVNldHRpbmdzLndpZHRoIHx8IGRlZmF1bHRTaXplKSAqIHNjYWxlO1xuICBjb25zdCBoID0gKGltYWdlU2V0dGluZ3MuaGVpZ2h0IHx8IGRlZmF1bHRTaXplKSAqIHNjYWxlO1xuICBjb25zdCB4ID0gaW1hZ2VTZXR0aW5ncy54ID09IG51bGwgPyBjZWxscy5sZW5ndGggLyAyIC0gdyAvIDIgOiBpbWFnZVNldHRpbmdzLnggKiBzY2FsZTtcbiAgY29uc3QgeSA9IGltYWdlU2V0dGluZ3MueSA9PSBudWxsID8gY2VsbHMubGVuZ3RoIC8gMiAtIGggLyAyIDogaW1hZ2VTZXR0aW5ncy55ICogc2NhbGU7XG4gIGxldCBleGNhdmF0aW9uID0gbnVsbDtcbiAgaWYgKGltYWdlU2V0dGluZ3MuZXhjYXZhdGUpIHtcbiAgICBsZXQgZmxvb3JYID0gTWF0aC5mbG9vcih4KTtcbiAgICBsZXQgZmxvb3JZID0gTWF0aC5mbG9vcih5KTtcbiAgICBsZXQgY2VpbFcgPSBNYXRoLmNlaWwodyArIHggLSBmbG9vclgpO1xuICAgIGxldCBjZWlsSCA9IE1hdGguY2VpbChoICsgeSAtIGZsb29yWSk7XG4gICAgZXhjYXZhdGlvbiA9IHsgeDogZmxvb3JYLCB5OiBmbG9vclksIHc6IGNlaWxXLCBoOiBjZWlsSCB9O1xuICB9XG4gIHJldHVybiB7IHgsIHksIGgsIHcsIGV4Y2F2YXRpb24gfTtcbn1cbnZhciBTVVBQT1JUU19QQVRIMkQgPSBmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICBuZXcgUGF0aDJEKCkuYWRkUGF0aChuZXcgUGF0aDJEKCkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufSgpO1xuZnVuY3Rpb24gUVJDb2RlQ2FudmFzKHByb3BzKSB7XG4gIGNvbnN0IF9hID0gcHJvcHMsIHtcbiAgICB2YWx1ZSxcbiAgICBzaXplID0gREVGQVVMVF9TSVpFLFxuICAgIGxldmVsID0gREVGQVVMVF9MRVZFTCxcbiAgICBiZ0NvbG9yID0gREVGQVVMVF9CR0NPTE9SLFxuICAgIGZnQ29sb3IgPSBERUZBVUxUX0ZHQ09MT1IsXG4gICAgaW5jbHVkZU1hcmdpbiA9IERFRkFVTFRfSU5DTFVERU1BUkdJTixcbiAgICBzdHlsZSxcbiAgICBpbWFnZVNldHRpbmdzXG4gIH0gPSBfYSwgb3RoZXJQcm9wcyA9IF9fb2JqUmVzdChfYSwgW1xuICAgIFwidmFsdWVcIixcbiAgICBcInNpemVcIixcbiAgICBcImxldmVsXCIsXG4gICAgXCJiZ0NvbG9yXCIsXG4gICAgXCJmZ0NvbG9yXCIsXG4gICAgXCJpbmNsdWRlTWFyZ2luXCIsXG4gICAgXCJzdHlsZVwiLFxuICAgIFwiaW1hZ2VTZXR0aW5nc1wiXG4gIF0pO1xuICBjb25zdCBpbWdTcmMgPSBpbWFnZVNldHRpbmdzID09IG51bGwgPyB2b2lkIDAgOiBpbWFnZVNldHRpbmdzLnNyYztcbiAgY29uc3QgX2NhbnZhcyA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgX2ltYWdlID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBbaXNJbWdMb2FkZWQsIHNldElzSW1hZ2VMb2FkZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChfY2FudmFzLmN1cnJlbnQgIT0gbnVsbCkge1xuICAgICAgY29uc3QgY2FudmFzID0gX2NhbnZhcy5jdXJyZW50O1xuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIGlmICghY3R4KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBjZWxscyA9IHFyY29kZWdlbl9kZWZhdWx0LlFyQ29kZS5lbmNvZGVUZXh0KHZhbHVlLCBFUlJPUl9MRVZFTF9NQVBbbGV2ZWxdKS5nZXRNb2R1bGVzKCk7XG4gICAgICBjb25zdCBtYXJnaW4gPSBpbmNsdWRlTWFyZ2luID8gTUFSR0lOX1NJWkUgOiAwO1xuICAgICAgY29uc3QgbnVtQ2VsbHMgPSBjZWxscy5sZW5ndGggKyBtYXJnaW4gKiAyO1xuICAgICAgY29uc3QgY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MgPSBnZXRJbWFnZVNldHRpbmdzKGNlbGxzLCBzaXplLCBpbmNsdWRlTWFyZ2luLCBpbWFnZVNldHRpbmdzKTtcbiAgICAgIGNvbnN0IGltYWdlID0gX2ltYWdlLmN1cnJlbnQ7XG4gICAgICBjb25zdCBoYXZlSW1hZ2VUb1JlbmRlciA9IGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzICE9IG51bGwgJiYgaW1hZ2UgIT09IG51bGwgJiYgaW1hZ2UuY29tcGxldGUgJiYgaW1hZ2UubmF0dXJhbEhlaWdodCAhPT0gMCAmJiBpbWFnZS5uYXR1cmFsV2lkdGggIT09IDA7XG4gICAgICBpZiAoaGF2ZUltYWdlVG9SZW5kZXIpIHtcbiAgICAgICAgaWYgKGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzLmV4Y2F2YXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgIGNlbGxzID0gZXhjYXZhdGVNb2R1bGVzKGNlbGxzLCBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncy5leGNhdmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgcGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzLndpZHRoID0gc2l6ZSAqIHBpeGVsUmF0aW87XG4gICAgICBjb25zdCBzY2FsZSA9IHNpemUgLyBudW1DZWxscyAqIHBpeGVsUmF0aW87XG4gICAgICBjdHguc2NhbGUoc2NhbGUsIHNjYWxlKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBiZ0NvbG9yO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIG51bUNlbGxzLCBudW1DZWxscyk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gZmdDb2xvcjtcbiAgICAgIGlmIChTVVBQT1JUU19QQVRIMkQpIHtcbiAgICAgICAgY3R4LmZpbGwobmV3IFBhdGgyRChnZW5lcmF0ZVBhdGgoY2VsbHMsIG1hcmdpbikpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNlbGxzLmZvckVhY2goZnVuY3Rpb24ocm93LCByZHgpIHtcbiAgICAgICAgICByb3cuZm9yRWFjaChmdW5jdGlvbihjZWxsLCBjZHgpIHtcbiAgICAgICAgICAgIGlmIChjZWxsKSB7XG4gICAgICAgICAgICAgIGN0eC5maWxsUmVjdChjZHggKyBtYXJnaW4sIHJkeCArIG1hcmdpbiwgMSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGhhdmVJbWFnZVRvUmVuZGVyKSB7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzLnggKyBtYXJnaW4sIGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzLnkgKyBtYXJnaW4sIGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzLncsIGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzLmgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2V0SXNJbWFnZUxvYWRlZChmYWxzZSk7XG4gIH0sIFtpbWdTcmNdKTtcbiAgY29uc3QgY2FudmFzU3R5bGUgPSBfX3NwcmVhZFZhbHVlcyh7IGhlaWdodDogc2l6ZSwgd2lkdGg6IHNpemUgfSwgc3R5bGUpO1xuICBsZXQgaW1nID0gbnVsbDtcbiAgaWYgKGltZ1NyYyAhPSBudWxsKSB7XG4gICAgaW1nID0gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIiwge1xuICAgICAgc3JjOiBpbWdTcmMsXG4gICAgICBrZXk6IGltZ1NyYyxcbiAgICAgIHN0eWxlOiB7IGRpc3BsYXk6IFwibm9uZVwiIH0sXG4gICAgICBvbkxvYWQ6ICgpID0+IHtcbiAgICAgICAgc2V0SXNJbWFnZUxvYWRlZCh0cnVlKTtcbiAgICAgIH0sXG4gICAgICByZWY6IF9pbWFnZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiwgX19zcHJlYWRWYWx1ZXMoe1xuICAgIHN0eWxlOiBjYW52YXNTdHlsZSxcbiAgICBoZWlnaHQ6IHNpemUsXG4gICAgd2lkdGg6IHNpemUsXG4gICAgcmVmOiBfY2FudmFzXG4gIH0sIG90aGVyUHJvcHMpKSwgaW1nKTtcbn1cbmZ1bmN0aW9uIFFSQ29kZVNWRyhwcm9wcykge1xuICBjb25zdCBfYSA9IHByb3BzLCB7XG4gICAgdmFsdWUsXG4gICAgc2l6ZSA9IERFRkFVTFRfU0laRSxcbiAgICBsZXZlbCA9IERFRkFVTFRfTEVWRUwsXG4gICAgYmdDb2xvciA9IERFRkFVTFRfQkdDT0xPUixcbiAgICBmZ0NvbG9yID0gREVGQVVMVF9GR0NPTE9SLFxuICAgIGluY2x1ZGVNYXJnaW4gPSBERUZBVUxUX0lOQ0xVREVNQVJHSU4sXG4gICAgaW1hZ2VTZXR0aW5nc1xuICB9ID0gX2EsIG90aGVyUHJvcHMgPSBfX29ialJlc3QoX2EsIFtcbiAgICBcInZhbHVlXCIsXG4gICAgXCJzaXplXCIsXG4gICAgXCJsZXZlbFwiLFxuICAgIFwiYmdDb2xvclwiLFxuICAgIFwiZmdDb2xvclwiLFxuICAgIFwiaW5jbHVkZU1hcmdpblwiLFxuICAgIFwiaW1hZ2VTZXR0aW5nc1wiXG4gIF0pO1xuICBsZXQgY2VsbHMgPSBxcmNvZGVnZW5fZGVmYXVsdC5RckNvZGUuZW5jb2RlVGV4dCh2YWx1ZSwgRVJST1JfTEVWRUxfTUFQW2xldmVsXSkuZ2V0TW9kdWxlcygpO1xuICBjb25zdCBtYXJnaW4gPSBpbmNsdWRlTWFyZ2luID8gTUFSR0lOX1NJWkUgOiAwO1xuICBjb25zdCBudW1DZWxscyA9IGNlbGxzLmxlbmd0aCArIG1hcmdpbiAqIDI7XG4gIGNvbnN0IGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzID0gZ2V0SW1hZ2VTZXR0aW5ncyhjZWxscywgc2l6ZSwgaW5jbHVkZU1hcmdpbiwgaW1hZ2VTZXR0aW5ncyk7XG4gIGxldCBpbWFnZSA9IG51bGw7XG4gIGlmIChpbWFnZVNldHRpbmdzICE9IG51bGwgJiYgY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MgIT0gbnVsbCkge1xuICAgIGlmIChjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncy5leGNhdmF0aW9uICE9IG51bGwpIHtcbiAgICAgIGNlbGxzID0gZXhjYXZhdGVNb2R1bGVzKGNlbGxzLCBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncy5leGNhdmF0aW9uKTtcbiAgICB9XG4gICAgaW1hZ2UgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImltYWdlXCIsIHtcbiAgICAgIHhsaW5rSHJlZjogaW1hZ2VTZXR0aW5ncy5zcmMsXG4gICAgICBoZWlnaHQ6IGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzLmgsXG4gICAgICB3aWR0aDogY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MudyxcbiAgICAgIHg6IGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzLnggKyBtYXJnaW4sXG4gICAgICB5OiBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncy55ICsgbWFyZ2luLFxuICAgICAgcHJlc2VydmVBc3BlY3RSYXRpbzogXCJub25lXCJcbiAgICB9KTtcbiAgfVxuICBjb25zdCBmZ1BhdGggPSBnZW5lcmF0ZVBhdGgoY2VsbHMsIG1hcmdpbik7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCBfX3NwcmVhZFZhbHVlcyh7XG4gICAgaGVpZ2h0OiBzaXplLFxuICAgIHdpZHRoOiBzaXplLFxuICAgIHZpZXdCb3g6IGAwIDAgJHtudW1DZWxsc30gJHtudW1DZWxsc31gXG4gIH0sIG90aGVyUHJvcHMpLCAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGZpbGw6IGJnQ29sb3IsXG4gICAgZDogYE0wLDAgaCR7bnVtQ2VsbHN9diR7bnVtQ2VsbHN9SDB6YCxcbiAgICBzaGFwZVJlbmRlcmluZzogXCJjcmlzcEVkZ2VzXCJcbiAgfSksIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgZmlsbDogZmdDb2xvcixcbiAgICBkOiBmZ1BhdGgsXG4gICAgc2hhcGVSZW5kZXJpbmc6IFwiY3Jpc3BFZGdlc1wiXG4gIH0pLCBpbWFnZSk7XG59XG52YXIgUVJDb2RlID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IF9hID0gcHJvcHMsIHsgcmVuZGVyQXMgfSA9IF9hLCBvdGhlclByb3BzID0gX19vYmpSZXN0KF9hLCBbXCJyZW5kZXJBc1wiXSk7XG4gIGlmIChyZW5kZXJBcyA9PT0gXCJzdmdcIikge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChRUkNvZGVTVkcsIF9fc3ByZWFkVmFsdWVzKHt9LCBvdGhlclByb3BzKSk7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFFSQ29kZUNhbnZhcywgX19zcHJlYWRWYWx1ZXMoe30sIG90aGVyUHJvcHMpKTtcbn07XG5leHBvcnQge1xuICBRUkNvZGVDYW52YXMsXG4gIFFSQ29kZVNWRyxcbiAgUVJDb2RlIGFzIGRlZmF1bHRcbn07XG4iXSwibmFtZXMiOlsiX19kZWZQcm9wIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJfX2dldE93blByb3BTeW1ib2xzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiX19oYXNPd25Qcm9wIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJfX3Byb3BJc0VudW0iLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIl9fZGVmTm9ybWFsUHJvcCIsIm9iaiIsImtleSIsInZhbHVlIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX19zcHJlYWRWYWx1ZXMiLCJhIiwiYiIsInByb3AiLCJjYWxsIiwiX19vYmpSZXN0Iiwic291cmNlIiwiZXhjbHVkZSIsInRhcmdldCIsImluZGV4T2YiLCJSZWFjdCIsInVzZVJlZiIsInVzZUVmZmVjdCIsInVzZVN0YXRlIiwicXJjb2RlZ2VuIiwicXJjb2RlZ2VuMiIsIl9RckNvZGUiLCJjb25zdHJ1Y3RvciIsInZlcnNpb24iLCJlcnJvckNvcnJlY3Rpb25MZXZlbCIsImRhdGFDb2Rld29yZHMiLCJtc2siLCJtb2R1bGVzIiwiaXNGdW5jdGlvbiIsIk1JTl9WRVJTSU9OIiwiTUFYX1ZFUlNJT04iLCJSYW5nZUVycm9yIiwic2l6ZSIsInJvdyIsImkiLCJwdXNoIiwic2xpY2UiLCJkcmF3RnVuY3Rpb25QYXR0ZXJucyIsImFsbENvZGV3b3JkcyIsImFkZEVjY0FuZEludGVybGVhdmUiLCJkcmF3Q29kZXdvcmRzIiwibWluUGVuYWx0eSIsImFwcGx5TWFzayIsImRyYXdGb3JtYXRCaXRzIiwicGVuYWx0eSIsImdldFBlbmFsdHlTY29yZSIsImFzc2VydCIsIm1hc2siLCJlbmNvZGVUZXh0IiwidGV4dCIsImVjbCIsInNlZ3MiLCJRclNlZ21lbnQiLCJtYWtlU2VnbWVudHMiLCJlbmNvZGVTZWdtZW50cyIsImVuY29kZUJpbmFyeSIsImRhdGEiLCJzZWciLCJtYWtlQnl0ZXMiLCJtaW5WZXJzaW9uIiwibWF4VmVyc2lvbiIsImJvb3N0RWNsIiwiZGF0YVVzZWRCaXRzIiwiZGF0YUNhcGFjaXR5Qml0czIiLCJnZXROdW1EYXRhQ29kZXdvcmRzIiwidXNlZEJpdHMiLCJnZXRUb3RhbEJpdHMiLCJuZXdFY2wiLCJFY2MiLCJNRURJVU0iLCJRVUFSVElMRSIsIkhJR0giLCJiYiIsImFwcGVuZEJpdHMiLCJtb2RlIiwibW9kZUJpdHMiLCJudW1DaGFycyIsIm51bUNoYXJDb3VudEJpdHMiLCJnZXREYXRhIiwibGVuZ3RoIiwiZGF0YUNhcGFjaXR5Qml0cyIsIk1hdGgiLCJtaW4iLCJwYWRCeXRlIiwiZm9yRWFjaCIsImdldE1vZHVsZSIsIngiLCJ5IiwiZ2V0TW9kdWxlcyIsInNldEZ1bmN0aW9uTW9kdWxlIiwiZHJhd0ZpbmRlclBhdHRlcm4iLCJhbGlnblBhdFBvcyIsImdldEFsaWdubWVudFBhdHRlcm5Qb3NpdGlvbnMiLCJudW1BbGlnbiIsImoiLCJkcmF3QWxpZ25tZW50UGF0dGVybiIsImRyYXdWZXJzaW9uIiwiZm9ybWF0Qml0cyIsInJlbSIsImJpdHMiLCJnZXRCaXQiLCJjb2xvciIsImZsb29yIiwiZHkiLCJkeCIsImRpc3QiLCJtYXgiLCJhYnMiLCJ4eCIsInl5IiwiaXNEYXJrIiwidmVyIiwibnVtQmxvY2tzIiwiTlVNX0VSUk9SX0NPUlJFQ1RJT05fQkxPQ0tTIiwib3JkaW5hbCIsImJsb2NrRWNjTGVuIiwiRUNDX0NPREVXT1JEU19QRVJfQkxPQ0siLCJyYXdDb2Rld29yZHMiLCJnZXROdW1SYXdEYXRhTW9kdWxlcyIsIm51bVNob3J0QmxvY2tzIiwic2hvcnRCbG9ja0xlbiIsImJsb2NrcyIsInJzRGl2IiwicmVlZFNvbG9tb25Db21wdXRlRGl2aXNvciIsImsiLCJkYXQiLCJlY2MiLCJyZWVkU29sb21vbkNvbXB1dGVSZW1haW5kZXIiLCJjb25jYXQiLCJyZXN1bHQiLCJibG9jayIsInJpZ2h0IiwidmVydCIsInVwd2FyZCIsImludmVydCIsIkVycm9yIiwicnVuQ29sb3IiLCJydW5YIiwicnVuSGlzdG9yeSIsIlBFTkFMVFlfTjEiLCJmaW5kZXJQZW5hbHR5QWRkSGlzdG9yeSIsImZpbmRlclBlbmFsdHlDb3VudFBhdHRlcm5zIiwiUEVOQUxUWV9OMyIsImZpbmRlclBlbmFsdHlUZXJtaW5hdGVBbmRDb3VudCIsInJ1blkiLCJQRU5BTFRZX04yIiwiZGFyayIsInJlZHVjZSIsInN1bSIsInRvdGFsIiwiY2VpbCIsIlBFTkFMVFlfTjQiLCJzdGVwIiwicG9zIiwic3BsaWNlIiwiZGVncmVlIiwicm9vdCIsInJlZWRTb2xvbW9uTXVsdGlwbHkiLCJkaXZpc29yIiwibWFwIiwiXyIsImZhY3RvciIsInNoaWZ0IiwiY29lZiIsInoiLCJuIiwiY29yZSIsImN1cnJlbnRSdW5Db2xvciIsImN1cnJlbnRSdW5MZW5ndGgiLCJwb3AiLCJ1bnNoaWZ0IiwiUXJDb2RlIiwidmFsIiwibGVuIiwiY29uZCIsIl9RclNlZ21lbnQiLCJiaXREYXRhIiwiTW9kZSIsIkJZVEUiLCJtYWtlTnVtZXJpYyIsImRpZ2l0cyIsImlzTnVtZXJpYyIsInBhcnNlSW50Iiwic3Vic3RyIiwiTlVNRVJJQyIsIm1ha2VBbHBoYW51bWVyaWMiLCJpc0FscGhhbnVtZXJpYyIsInRlbXAiLCJBTFBIQU5VTUVSSUNfQ0hBUlNFVCIsImNoYXJBdCIsIkFMUEhBTlVNRVJJQyIsInRvVXRmOEJ5dGVBcnJheSIsIm1ha2VFY2kiLCJhc3NpZ25WYWwiLCJFQ0kiLCJOVU1FUklDX1JFR0VYIiwidGVzdCIsIkFMUEhBTlVNRVJJQ19SRUdFWCIsImNjYml0cyIsIkluZmluaXR5Iiwic3RyIiwiZW5jb2RlVVJJIiwiY2hhckNvZGVBdCIsIlFyQ29kZTIiLCJfRWNjIiwiTE9XIiwiUXJTZWdtZW50MiIsIl9Nb2RlIiwibnVtQml0c0NoYXJDb3VudCIsIktBTkpJIiwicXJjb2RlZ2VuX2RlZmF1bHQiLCJFUlJPUl9MRVZFTF9NQVAiLCJMIiwiTSIsIlEiLCJIIiwiREVGQVVMVF9TSVpFIiwiREVGQVVMVF9MRVZFTCIsIkRFRkFVTFRfQkdDT0xPUiIsIkRFRkFVTFRfRkdDT0xPUiIsIkRFRkFVTFRfSU5DTFVERU1BUkdJTiIsIk1BUkdJTl9TSVpFIiwiREVGQVVMVF9JTUdfU0NBTEUiLCJnZW5lcmF0ZVBhdGgiLCJtYXJnaW4iLCJvcHMiLCJzdGFydCIsImNlbGwiLCJqb2luIiwiZXhjYXZhdGVNb2R1bGVzIiwiZXhjYXZhdGlvbiIsImgiLCJ3IiwiZ2V0SW1hZ2VTZXR0aW5ncyIsImNlbGxzIiwiaW5jbHVkZU1hcmdpbiIsImltYWdlU2V0dGluZ3MiLCJudW1DZWxscyIsImRlZmF1bHRTaXplIiwic2NhbGUiLCJ3aWR0aCIsImhlaWdodCIsImV4Y2F2YXRlIiwiZmxvb3JYIiwiZmxvb3JZIiwiY2VpbFciLCJjZWlsSCIsIlNVUFBPUlRTX1BBVEgyRCIsIlBhdGgyRCIsImFkZFBhdGgiLCJlIiwiUVJDb2RlQ2FudmFzIiwicHJvcHMiLCJfYSIsImxldmVsIiwiYmdDb2xvciIsImZnQ29sb3IiLCJzdHlsZSIsIm90aGVyUHJvcHMiLCJpbWdTcmMiLCJzcmMiLCJfY2FudmFzIiwiX2ltYWdlIiwiaXNJbWdMb2FkZWQiLCJzZXRJc0ltYWdlTG9hZGVkIiwiY3VycmVudCIsImNhbnZhcyIsImN0eCIsImdldENvbnRleHQiLCJjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncyIsImltYWdlIiwiaGF2ZUltYWdlVG9SZW5kZXIiLCJjb21wbGV0ZSIsIm5hdHVyYWxIZWlnaHQiLCJuYXR1cmFsV2lkdGgiLCJwaXhlbFJhdGlvIiwid2luZG93IiwiZGV2aWNlUGl4ZWxSYXRpbyIsImZpbGxTdHlsZSIsImZpbGxSZWN0IiwiZmlsbCIsInJkeCIsImNkeCIsImRyYXdJbWFnZSIsImNhbnZhc1N0eWxlIiwiaW1nIiwiY3JlYXRlRWxlbWVudCIsImRpc3BsYXkiLCJvbkxvYWQiLCJyZWYiLCJGcmFnbWVudCIsIlFSQ29kZVNWRyIsInhsaW5rSHJlZiIsInByZXNlcnZlQXNwZWN0UmF0aW8iLCJmZ1BhdGgiLCJ2aWV3Qm94IiwiZCIsInNoYXBlUmVuZGVyaW5nIiwiUVJDb2RlIiwicmVuZGVyQXMiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/qrcode.react/lib/esm/index.js\n");

/***/ })

};
;