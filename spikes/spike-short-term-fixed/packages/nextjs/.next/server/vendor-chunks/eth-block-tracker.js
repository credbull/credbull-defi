"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/eth-block-tracker";
exports.ids = ["vendor-chunks/eth-block-tracker"];
exports.modules = {

/***/ "(ssr)/./node_modules/eth-block-tracker/dist/BaseBlockTracker.js":
/*!*****************************************************************!*\
  !*** ./node_modules/eth-block-tracker/dist/BaseBlockTracker.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BaseBlockTracker = void 0;\nconst safe_event_emitter_1 = __importDefault(__webpack_require__(/*! @metamask/safe-event-emitter */ \"(ssr)/./node_modules/@metamask/safe-event-emitter/dist/cjs/index.js\"));\nconst sec = 1000;\nconst calculateSum = (accumulator, currentValue)=>accumulator + currentValue;\nconst blockTrackerEvents = [\n    \"sync\",\n    \"latest\"\n];\nclass BaseBlockTracker extends safe_event_emitter_1.default {\n    constructor(opts){\n        super();\n        // config\n        this._blockResetDuration = opts.blockResetDuration || 20 * sec;\n        this._usePastBlocks = opts.usePastBlocks || false;\n        // state\n        this._currentBlock = null;\n        this._isRunning = false;\n        // bind functions for internal use\n        this._onNewListener = this._onNewListener.bind(this);\n        this._onRemoveListener = this._onRemoveListener.bind(this);\n        this._resetCurrentBlock = this._resetCurrentBlock.bind(this);\n        // listen for handler changes\n        this._setupInternalEvents();\n    }\n    async destroy() {\n        this._cancelBlockResetTimeout();\n        await this._maybeEnd();\n        super.removeAllListeners();\n    }\n    isRunning() {\n        return this._isRunning;\n    }\n    getCurrentBlock() {\n        return this._currentBlock;\n    }\n    async getLatestBlock() {\n        // return if available\n        if (this._currentBlock) {\n            return this._currentBlock;\n        }\n        // wait for a new latest block\n        const latestBlock = await new Promise((resolve)=>this.once(\"latest\", resolve));\n        // return newly set current block\n        return latestBlock;\n    }\n    // dont allow module consumer to remove our internal event listeners\n    removeAllListeners(eventName) {\n        // perform default behavior, preserve fn arity\n        if (eventName) {\n            super.removeAllListeners(eventName);\n        } else {\n            super.removeAllListeners();\n        }\n        // re-add internal events\n        this._setupInternalEvents();\n        // trigger stop check just in case\n        this._onRemoveListener();\n        return this;\n    }\n    _setupInternalEvents() {\n        // first remove listeners for idempotence\n        this.removeListener(\"newListener\", this._onNewListener);\n        this.removeListener(\"removeListener\", this._onRemoveListener);\n        // then add them\n        this.on(\"newListener\", this._onNewListener);\n        this.on(\"removeListener\", this._onRemoveListener);\n    }\n    _onNewListener(eventName) {\n        // `newListener` is called *before* the listener is added\n        if (blockTrackerEvents.includes(eventName)) {\n            this._maybeStart();\n        }\n    }\n    _onRemoveListener() {\n        // `removeListener` is called *after* the listener is removed\n        if (this._getBlockTrackerEventCount() > 0) {\n            return;\n        }\n        this._maybeEnd();\n    }\n    async _maybeStart() {\n        if (this._isRunning) {\n            return;\n        }\n        this._isRunning = true;\n        // cancel setting latest block to stale\n        this._cancelBlockResetTimeout();\n        await this._start();\n        this.emit(\"_started\");\n    }\n    async _maybeEnd() {\n        if (!this._isRunning) {\n            return;\n        }\n        this._isRunning = false;\n        this._setupBlockResetTimeout();\n        await this._end();\n        this.emit(\"_ended\");\n    }\n    _getBlockTrackerEventCount() {\n        return blockTrackerEvents.map((eventName)=>this.listenerCount(eventName)).reduce(calculateSum);\n    }\n    _shouldUseNewBlock(newBlock) {\n        const currentBlock = this._currentBlock;\n        if (!currentBlock) {\n            return true;\n        }\n        const newBlockInt = hexToInt(newBlock);\n        const currentBlockInt = hexToInt(currentBlock);\n        return this._usePastBlocks && newBlockInt < currentBlockInt || newBlockInt > currentBlockInt;\n    }\n    _newPotentialLatest(newBlock) {\n        if (!this._shouldUseNewBlock(newBlock)) {\n            return;\n        }\n        this._setCurrentBlock(newBlock);\n    }\n    _setCurrentBlock(newBlock) {\n        const oldBlock = this._currentBlock;\n        this._currentBlock = newBlock;\n        this.emit(\"latest\", newBlock);\n        this.emit(\"sync\", {\n            oldBlock,\n            newBlock\n        });\n    }\n    _setupBlockResetTimeout() {\n        // clear any existing timeout\n        this._cancelBlockResetTimeout();\n        // clear latest block when stale\n        this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this._blockResetDuration);\n        // nodejs - dont hold process open\n        if (this._blockResetTimeout.unref) {\n            this._blockResetTimeout.unref();\n        }\n    }\n    _cancelBlockResetTimeout() {\n        if (this._blockResetTimeout) {\n            clearTimeout(this._blockResetTimeout);\n        }\n    }\n    _resetCurrentBlock() {\n        this._currentBlock = null;\n    }\n}\nexports.BaseBlockTracker = BaseBlockTracker;\n/**\n * Converts a number represented as a string in hexadecimal format into a native\n * number.\n *\n * @param hexInt - The hex string.\n * @returns The number.\n */ function hexToInt(hexInt) {\n    return Number.parseInt(hexInt, 16);\n} //# sourceMappingURL=BaseBlockTracker.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvZGlzdC9CYXNlQmxvY2tUcmFja2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLElBQUssSUFBSSxJQUFJLENBQUNBLGVBQWUsSUFBSyxTQUFVQyxHQUFHO0lBQ2pFLE9BQU8sT0FBUUEsSUFBSUMsVUFBVSxHQUFJRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUM1RDtBQUNBRSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsd0JBQXdCLEdBQUcsS0FBSztBQUNoQyxNQUFNRyx1QkFBdUJSLGdCQUFnQlMsbUJBQU9BLENBQUMseUdBQThCO0FBQ25GLE1BQU1DLE1BQU07QUFDWixNQUFNQyxlQUFlLENBQUNDLGFBQWFDLGVBQWlCRCxjQUFjQztBQUNsRSxNQUFNQyxxQkFBcUI7SUFBQztJQUFRO0NBQVM7QUFDN0MsTUFBTVAseUJBQXlCQyxxQkFBcUJPLE9BQU87SUFDdkRDLFlBQVlDLElBQUksQ0FBRTtRQUNkLEtBQUs7UUFDTCxTQUFTO1FBQ1QsSUFBSSxDQUFDQyxtQkFBbUIsR0FBR0QsS0FBS0Usa0JBQWtCLElBQUksS0FBS1Q7UUFDM0QsSUFBSSxDQUFDVSxjQUFjLEdBQUdILEtBQUtJLGFBQWEsSUFBSTtRQUM1QyxRQUFRO1FBQ1IsSUFBSSxDQUFDQyxhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDQyxVQUFVLEdBQUc7UUFDbEIsa0NBQWtDO1FBQ2xDLElBQUksQ0FBQ0MsY0FBYyxHQUFHLElBQUksQ0FBQ0EsY0FBYyxDQUFDQyxJQUFJLENBQUMsSUFBSTtRQUNuRCxJQUFJLENBQUNDLGlCQUFpQixHQUFHLElBQUksQ0FBQ0EsaUJBQWlCLENBQUNELElBQUksQ0FBQyxJQUFJO1FBQ3pELElBQUksQ0FBQ0Usa0JBQWtCLEdBQUcsSUFBSSxDQUFDQSxrQkFBa0IsQ0FBQ0YsSUFBSSxDQUFDLElBQUk7UUFDM0QsNkJBQTZCO1FBQzdCLElBQUks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a0JBQWtCLENBQUNDLFdBQVc7WUFDcEM7UUFDSjtRQUNBLElBQUksQ0FBQ00sZ0JBQWdCLENBQUNOO0lBQzFCO0lBQ0FNLGlCQUFpQk4sUUFBUSxFQUFFO1FBQ3ZCLE1BQU1PLFdBQVcsSUFBSSxDQUFDdkMsYUFBYTtRQUNuQyxJQUFJLENBQUNBLGFBQWEsR0FBR2dDO1FBQ3JCLElBQUksQ0FBQ1AsSUFBSSxDQUFDLFVBQVVPO1FBQ3BCLElBQUksQ0FBQ1AsSUFBSSxDQUFDLFFBQVE7WUFBRWM7WUFBVVA7UUFBUztJQUMzQztJQUNBTiwwQkFBMEI7UUFDdEIsNkJBQTZCO1FBQzdCLElBQUksQ0FBQ2xCLHdCQUF3QjtRQUM3QixnQ0FBZ0M7UUFDaEMsSUFBSSxDQUFDZ0Msa0JBQWtCLEdBQUdDLFdBQVcsSUFBSSxDQUFDcEMsa0JBQWtCLEVBQUUsSUFBSSxDQUFDVCxtQkFBbUI7UUFDdEYsa0NBQWtDO1FBQ2xDLElBQUksSUFBSSxDQUFDNEMsa0JBQWtCLENBQUNFLEtBQUssRUFBRTtZQUMvQixJQUFJLENBQUNGLGtCQUFrQixDQUFDRSxLQUFLO1FBQ2pDO0lBQ0o7SUFDQWxDLDJCQUEyQjtRQUN2QixJQUFJLElBQUksQ0FBQ2dDLGtCQUFrQixFQUFFO1lBQ3pCRyxhQUFhLElBQUksQ0FBQ0gsa0JBQWtCO1FBQ3hDO0lBQ0o7SUFDQW5DLHFCQUFxQjtRQUNqQixJQUFJLENBQUNMLGFBQWEsR0FBRztJQUN6QjtBQUNKO0FBQ0FqQix3QkFBd0IsR0FBR0U7QUFDM0I7Ozs7OztDQU1DLEdBQ0QsU0FBU2tELFNBQVNTLE1BQU07SUFDcEIsT0FBT0MsT0FBT0MsUUFBUSxDQUFDRixRQUFRO0FBQ25DLEVBQ0EsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHNlLTIvbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2V0aC1ibG9jay10cmFja2VyL2Rpc3QvQmFzZUJsb2NrVHJhY2tlci5qcz9kMDI1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CYXNlQmxvY2tUcmFja2VyID0gdm9pZCAwO1xuY29uc3Qgc2FmZV9ldmVudF9lbWl0dGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBtZXRhbWFzay9zYWZlLWV2ZW50LWVtaXR0ZXJcIikpO1xuY29uc3Qgc2VjID0gMTAwMDtcbmNvbnN0IGNhbGN1bGF0ZVN1bSA9IChhY2N1bXVsYXRvciwgY3VycmVudFZhbHVlKSA9PiBhY2N1bXVsYXRvciArIGN1cnJlbnRWYWx1ZTtcbmNvbnN0IGJsb2NrVHJhY2tlckV2ZW50cyA9IFsnc3luYycsICdsYXRlc3QnXTtcbmNsYXNzIEJhc2VCbG9ja1RyYWNrZXIgZXh0ZW5kcyBzYWZlX2V2ZW50X2VtaXR0ZXJfMS5kZWZhdWx0IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIGNvbmZpZ1xuICAgICAgICB0aGlzLl9ibG9ja1Jlc2V0RHVyYXRpb24gPSBvcHRzLmJsb2NrUmVzZXREdXJhdGlvbiB8fCAyMCAqIHNlYztcbiAgICAgICAgdGhpcy5fdXNlUGFzdEJsb2NrcyA9IG9wdHMudXNlUGFzdEJsb2NrcyB8fCBmYWxzZTtcbiAgICAgICAgLy8gc3RhdGVcbiAgICAgICAgdGhpcy5fY3VycmVudEJsb2NrID0gbnVsbDtcbiAgICAgICAgdGhpcy5faXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIC8vIGJpbmQgZnVuY3Rpb25zIGZvciBpbnRlcm5hbCB1c2VcbiAgICAgICAgdGhpcy5fb25OZXdMaXN0ZW5lciA9IHRoaXMuX29uTmV3TGlzdGVuZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fb25SZW1vdmVMaXN0ZW5lciA9IHRoaXMuX29uUmVtb3ZlTGlzdGVuZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fcmVzZXRDdXJyZW50QmxvY2sgPSB0aGlzLl9yZXNldEN1cnJlbnRCbG9jay5iaW5kKHRoaXMpO1xuICAgICAgICAvLyBsaXN0ZW4gZm9yIGhhbmRsZXIgY2hhbmdlc1xuICAgICAgICB0aGlzLl9zZXR1cEludGVybmFsRXZlbnRzKCk7XG4gICAgfVxuICAgIGFzeW5jIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX2NhbmNlbEJsb2NrUmVzZXRUaW1lb3V0KCk7XG4gICAgICAgIGF3YWl0IHRoaXMuX21heWJlRW5kKCk7XG4gICAgICAgIHN1cGVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIH1cbiAgICBpc1J1bm5pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1J1bm5pbmc7XG4gICAgfVxuICAgIGdldEN1cnJlbnRCbG9jaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRCbG9jaztcbiAgICB9XG4gICAgYXN5bmMgZ2V0TGF0ZXN0QmxvY2soKSB7XG4gICAgICAgIC8vIHJldHVybiBpZiBhdmFpbGFibGVcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRCbG9jaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRCbG9jaztcbiAgICAgICAgfVxuICAgICAgICAvLyB3YWl0IGZvciBhIG5ldyBsYXRlc3QgYmxvY2tcbiAgICAgICAgY29uc3QgbGF0ZXN0QmxvY2sgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gdGhpcy5vbmNlKCdsYXRlc3QnLCByZXNvbHZlKSk7XG4gICAgICAgIC8vIHJldHVybiBuZXdseSBzZXQgY3VycmVudCBibG9ja1xuICAgICAgICByZXR1cm4gbGF0ZXN0QmxvY2s7XG4gICAgfVxuICAgIC8vIGRvbnQgYWxsb3cgbW9kdWxlIGNvbnN1bWVyIHRvIHJlbW92ZSBvdXIgaW50ZXJuYWwgZXZlbnQgbGlzdGVuZXJzXG4gICAgcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSkge1xuICAgICAgICAvLyBwZXJmb3JtIGRlZmF1bHQgYmVoYXZpb3IsIHByZXNlcnZlIGZuIGFyaXR5XG4gICAgICAgIGlmIChldmVudE5hbWUpIHtcbiAgICAgICAgICAgIHN1cGVyLnJlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3VwZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmUtYWRkIGludGVybmFsIGV2ZW50c1xuICAgICAgICB0aGlzLl9zZXR1cEludGVybmFsRXZlbnRzKCk7XG4gICAgICAgIC8vIHRyaWdnZXIgc3RvcCBjaGVjayBqdXN0IGluIGNhc2VcbiAgICAgICAgdGhpcy5fb25SZW1vdmVMaXN0ZW5lcigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgX3NldHVwSW50ZXJuYWxFdmVudHMoKSB7XG4gICAgICAgIC8vIGZpcnN0IHJlbW92ZSBsaXN0ZW5lcnMgZm9yIGlkZW1wb3RlbmNlXG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ25ld0xpc3RlbmVyJywgdGhpcy5fb25OZXdMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ3JlbW92ZUxpc3RlbmVyJywgdGhpcy5fb25SZW1vdmVMaXN0ZW5lcik7XG4gICAgICAgIC8vIHRoZW4gYWRkIHRoZW1cbiAgICAgICAgdGhpcy5vbignbmV3TGlzdGVuZXInLCB0aGlzLl9vbk5ld0xpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5vbigncmVtb3ZlTGlzdGVuZXInLCB0aGlzLl9vblJlbW92ZUxpc3RlbmVyKTtcbiAgICB9XG4gICAgX29uTmV3TGlzdGVuZXIoZXZlbnROYW1lKSB7XG4gICAgICAgIC8vIGBuZXdMaXN0ZW5lcmAgaXMgY2FsbGVkICpiZWZvcmUqIHRoZSBsaXN0ZW5lciBpcyBhZGRlZFxuICAgICAgICBpZiAoYmxvY2tUcmFja2VyRXZlbnRzLmluY2x1ZGVzKGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX21heWJlU3RhcnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfb25SZW1vdmVMaXN0ZW5lcigpIHtcbiAgICAgICAgLy8gYHJlbW92ZUxpc3RlbmVyYCBpcyBjYWxsZWQgKmFmdGVyKiB0aGUgbGlzdGVuZXIgaXMgcmVtb3ZlZFxuICAgICAgICBpZiAodGhpcy5fZ2V0QmxvY2tUcmFja2VyRXZlbnRDb3VudCgpID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21heWJlRW5kKCk7XG4gICAgfVxuICAgIGFzeW5jIF9tYXliZVN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy5faXNSdW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgLy8gY2FuY2VsIHNldHRpbmcgbGF0ZXN0IGJsb2NrIHRvIHN0YWxlXG4gICAgICAgIHRoaXMuX2NhbmNlbEJsb2NrUmVzZXRUaW1lb3V0KCk7XG4gICAgICAgIGF3YWl0IHRoaXMuX3N0YXJ0KCk7XG4gICAgICAgIHRoaXMuZW1pdCgnX3N0YXJ0ZWQnKTtcbiAgICB9XG4gICAgYXN5bmMgX21heWJlRW5kKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzUnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zZXR1cEJsb2NrUmVzZXRUaW1lb3V0KCk7XG4gICAgICAgIGF3YWl0IHRoaXMuX2VuZCgpO1xuICAgICAgICB0aGlzLmVtaXQoJ19lbmRlZCcpO1xuICAgIH1cbiAgICBfZ2V0QmxvY2tUcmFja2VyRXZlbnRDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIGJsb2NrVHJhY2tlckV2ZW50c1xuICAgICAgICAgICAgLm1hcCgoZXZlbnROYW1lKSA9PiB0aGlzLmxpc3RlbmVyQ291bnQoZXZlbnROYW1lKSlcbiAgICAgICAgICAgIC5yZWR1Y2UoY2FsY3VsYXRlU3VtKTtcbiAgICB9XG4gICAgX3Nob3VsZFVzZU5ld0Jsb2NrKG5ld0Jsb2NrKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRCbG9jayA9IHRoaXMuX2N1cnJlbnRCbG9jaztcbiAgICAgICAgaWYgKCFjdXJyZW50QmxvY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0Jsb2NrSW50ID0gaGV4VG9JbnQobmV3QmxvY2spO1xuICAgICAgICBjb25zdCBjdXJyZW50QmxvY2tJbnQgPSBoZXhUb0ludChjdXJyZW50QmxvY2spO1xuICAgICAgICByZXR1cm4gKCh0aGlzLl91c2VQYXN0QmxvY2tzICYmIG5ld0Jsb2NrSW50IDwgY3VycmVudEJsb2NrSW50KSB8fFxuICAgICAgICAgICAgbmV3QmxvY2tJbnQgPiBjdXJyZW50QmxvY2tJbnQpO1xuICAgIH1cbiAgICBfbmV3UG90ZW50aWFsTGF0ZXN0KG5ld0Jsb2NrKSB7XG4gICAgICAgIGlmICghdGhpcy5fc2hvdWxkVXNlTmV3QmxvY2sobmV3QmxvY2spKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0Q3VycmVudEJsb2NrKG5ld0Jsb2NrKTtcbiAgICB9XG4gICAgX3NldEN1cnJlbnRCbG9jayhuZXdCbG9jaykge1xuICAgICAgICBjb25zdCBvbGRCbG9jayA9IHRoaXMuX2N1cnJlbnRCbG9jaztcbiAgICAgICAgdGhpcy5fY3VycmVudEJsb2NrID0gbmV3QmxvY2s7XG4gICAgICAgIHRoaXMuZW1pdCgnbGF0ZXN0JywgbmV3QmxvY2spO1xuICAgICAgICB0aGlzLmVtaXQoJ3N5bmMnLCB7IG9sZEJsb2NrLCBuZXdCbG9jayB9KTtcbiAgICB9XG4gICAgX3NldHVwQmxvY2tSZXNldFRpbWVvdXQoKSB7XG4gICAgICAgIC8vIGNsZWFyIGFueSBleGlzdGluZyB0aW1lb3V0XG4gICAgICAgIHRoaXMuX2NhbmNlbEJsb2NrUmVzZXRUaW1lb3V0KCk7XG4gICAgICAgIC8vIGNsZWFyIGxhdGVzdCBibG9jayB3aGVuIHN0YWxlXG4gICAgICAgIHRoaXMuX2Jsb2NrUmVzZXRUaW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLl9yZXNldEN1cnJlbnRCbG9jaywgdGhpcy5fYmxvY2tSZXNldER1cmF0aW9uKTtcbiAgICAgICAgLy8gbm9kZWpzIC0gZG9udCBob2xkIHByb2Nlc3Mgb3BlblxuICAgICAgICBpZiAodGhpcy5fYmxvY2tSZXNldFRpbWVvdXQudW5yZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX2Jsb2NrUmVzZXRUaW1lb3V0LnVucmVmKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2NhbmNlbEJsb2NrUmVzZXRUaW1lb3V0KCkge1xuICAgICAgICBpZiAodGhpcy5fYmxvY2tSZXNldFRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9ibG9ja1Jlc2V0VGltZW91dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3Jlc2V0Q3VycmVudEJsb2NrKCkge1xuICAgICAgICB0aGlzLl9jdXJyZW50QmxvY2sgPSBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZUJsb2NrVHJhY2tlciA9IEJhc2VCbG9ja1RyYWNrZXI7XG4vKipcbiAqIENvbnZlcnRzIGEgbnVtYmVyIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nIGluIGhleGFkZWNpbWFsIGZvcm1hdCBpbnRvIGEgbmF0aXZlXG4gKiBudW1iZXIuXG4gKlxuICogQHBhcmFtIGhleEludCAtIFRoZSBoZXggc3RyaW5nLlxuICogQHJldHVybnMgVGhlIG51bWJlci5cbiAqL1xuZnVuY3Rpb24gaGV4VG9JbnQoaGV4SW50KSB7XG4gICAgcmV0dXJuIE51bWJlci5wYXJzZUludChoZXhJbnQsIDE2KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhc2VCbG9ja1RyYWNrZXIuanMubWFwIl0sIm5hbWVzIjpbIl9faW1wb3J0RGVmYXVsdCIsIm1vZCIsIl9fZXNNb2R1bGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkJhc2VCbG9ja1RyYWNrZXIiLCJzYWZlX2V2ZW50X2VtaXR0ZXJfMSIsInJlcXVpcmUiLCJzZWMiLCJjYWxjdWxhdGVTdW0iLCJhY2N1bXVsYXRvciIsImN1cnJlbnRWYWx1ZSIsImJsb2NrVHJhY2tlckV2ZW50cyIsImRlZmF1bHQiLCJjb25zdHJ1Y3RvciIsIm9wdHMiLCJfYmxvY2tSZXNldER1cmF0aW9uIiwiYmxvY2tSZXNldER1cmF0aW9uIiwiX3VzZVBhc3RCbG9ja3MiLCJ1c2VQYXN0QmxvY2tzIiwiX2N1cnJlbnRCbG9jayIsIl9pc1J1bm5pbmciLCJfb25OZXdMaXN0ZW5lciIsImJpbmQiLCJfb25SZW1vdmVMaXN0ZW5lciIsIl9yZXNldEN1cnJlbnRCbG9jayIsIl9zZXR1cEludGVybmFsRXZlbnRzIiwiZGVzdHJveSIsIl9jYW5jZWxCbG9ja1Jlc2V0VGltZW91dCIsIl9tYXliZUVuZCIsInJlbW92ZUFsbExpc3RlbmVycyIsImlzUnVubmluZyIsImdldEN1cnJlbnRCbG9jayIsImdldExhdGVzdEJsb2NrIiwibGF0ZXN0QmxvY2siLCJQcm9taXNlIiwicmVzb2x2ZSIsIm9uY2UiLCJldmVudE5hbWUiLCJyZW1vdmVMaXN0ZW5lciIsIm9uIiwiaW5jbHVkZXMiLCJfbWF5YmVTdGFydCIsIl9nZXRCbG9ja1RyYWNrZXJFdmVudENvdW50IiwiX3N0YXJ0IiwiZW1pdCIsIl9zZXR1cEJsb2NrUmVzZXRUaW1lb3V0IiwiX2VuZCIsIm1hcCIsImxpc3RlbmVyQ291bnQiLCJyZWR1Y2UiLCJfc2hvdWxkVXNlTmV3QmxvY2siLCJuZXdCbG9jayIsImN1cnJlbnRCbG9jayIsIm5ld0Jsb2NrSW50IiwiaGV4VG9JbnQiLCJjdXJyZW50QmxvY2tJbnQiLCJfbmV3UG90ZW50aWFsTGF0ZXN0IiwiX3NldEN1cnJlbnRCbG9jayIsIm9sZEJsb2NrIiwiX2Jsb2NrUmVzZXRUaW1lb3V0Iiwic2V0VGltZW91dCIsInVucmVmIiwiY2xlYXJUaW1lb3V0IiwiaGV4SW50IiwiTnVtYmVyIiwicGFyc2VJbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/dist/BaseBlockTracker.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/dist/PollingBlockTracker.js":
/*!********************************************************************!*\
  !*** ./node_modules/eth-block-tracker/dist/PollingBlockTracker.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.PollingBlockTracker = void 0;\nconst json_rpc_random_id_1 = __importDefault(__webpack_require__(/*! json-rpc-random-id */ \"(ssr)/./node_modules/json-rpc-random-id/index.js\"));\nconst pify_1 = __importDefault(__webpack_require__(/*! pify */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/pify/index.js\"));\nconst BaseBlockTracker_1 = __webpack_require__(/*! ./BaseBlockTracker */ \"(ssr)/./node_modules/eth-block-tracker/dist/BaseBlockTracker.js\");\nconst logging_utils_1 = __webpack_require__(/*! ./logging-utils */ \"(ssr)/./node_modules/eth-block-tracker/dist/logging-utils.js\");\nconst log = (0, logging_utils_1.createModuleLogger)(logging_utils_1.projectLogger, \"polling-block-tracker\");\nconst createRandomId = (0, json_rpc_random_id_1.default)();\nconst sec = 1000;\nclass PollingBlockTracker extends BaseBlockTracker_1.BaseBlockTracker {\n    constructor(opts = {}){\n        var _a;\n        // parse + validate args\n        if (!opts.provider) {\n            throw new Error(\"PollingBlockTracker - no provider specified.\");\n        }\n        super(Object.assign(Object.assign({}, opts), {\n            blockResetDuration: (_a = opts.blockResetDuration) !== null && _a !== void 0 ? _a : opts.pollingInterval\n        }));\n        // config\n        this._provider = opts.provider;\n        this._pollingInterval = opts.pollingInterval || 20 * sec;\n        this._retryTimeout = opts.retryTimeout || this._pollingInterval / 10;\n        this._keepEventLoopActive = opts.keepEventLoopActive === undefined ? true : opts.keepEventLoopActive;\n        this._setSkipCacheFlag = opts.setSkipCacheFlag || false;\n    }\n    // trigger block polling\n    async checkForLatestBlock() {\n        await this._updateLatestBlock();\n        return await this.getLatestBlock();\n    }\n    async _start() {\n        this._synchronize();\n    }\n    async _end() {\n    // No-op\n    }\n    async _synchronize() {\n        var _a;\n        while(this._isRunning){\n            try {\n                await this._updateLatestBlock();\n                const promise = timeout(this._pollingInterval, !this._keepEventLoopActive);\n                this.emit(\"_waitingForNextIteration\");\n                await promise;\n            } catch (err) {\n                const newErr = new Error(`PollingBlockTracker - encountered an error while attempting to update latest block:\\n${(_a = err.stack) !== null && _a !== void 0 ? _a : err}`);\n                try {\n                    this.emit(\"error\", newErr);\n                } catch (emitErr) {\n                    console.error(newErr);\n                }\n                const promise = timeout(this._retryTimeout, !this._keepEventLoopActive);\n                this.emit(\"_waitingForNextIteration\");\n                await promise;\n            }\n        }\n    }\n    async _updateLatestBlock() {\n        // fetch + set latest block\n        const latestBlock = await this._fetchLatestBlock();\n        this._newPotentialLatest(latestBlock);\n    }\n    async _fetchLatestBlock() {\n        const req = {\n            jsonrpc: \"2.0\",\n            id: createRandomId(),\n            method: \"eth_blockNumber\",\n            params: []\n        };\n        if (this._setSkipCacheFlag) {\n            req.skipCache = true;\n        }\n        log(\"Making request\", req);\n        const res = await (0, pify_1.default)((cb)=>this._provider.sendAsync(req, cb))();\n        log(\"Got response\", res);\n        if (res.error) {\n            throw new Error(`PollingBlockTracker - encountered error fetching block:\\n${res.error.message}`);\n        }\n        return res.result;\n    }\n}\nexports.PollingBlockTracker = PollingBlockTracker;\n/**\n * Waits for the specified amount of time.\n *\n * @param duration - The amount of time in milliseconds.\n * @param unref - Assuming this function is run in a Node context, governs\n * whether Node should wait before the `setTimeout` has completed before ending\n * the process (true for no, false for yes). Defaults to false.\n * @returns A promise that can be used to wait.\n */ function timeout(duration, unref) {\n    return new Promise((resolve)=>{\n        const timeoutRef = setTimeout(resolve, duration);\n        // don't keep process open\n        if (timeoutRef.unref && unref) {\n            timeoutRef.unref();\n        }\n    });\n} //# sourceMappingURL=PollingBlockTracker.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvZGlzdC9Qb2xsaW5nQmxvY2tUcmFja2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLElBQUssSUFBSSxJQUFJLENBQUNBLGVBQWUsSUFBSyxTQUFVQyxHQUFHO0lBQ2pFLE9BQU8sT0FBUUEsSUFBSUMsVUFBVSxHQUFJRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUM1RDtBQUNBRSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsMkJBQTJCLEdBQUcsS0FBSztBQUNuQyxNQUFNRyx1QkFBdUJSLGdCQUFnQlMsbUJBQU9BLENBQUMsNEVBQW9CO0FBQ3pFLE1BQU1DLFNBQVNWLGdCQUFnQlMsbUJBQU9BLENBQUMsK0VBQU07QUFDN0MsTUFBTUUscUJBQXFCRixtQkFBT0EsQ0FBQywyRkFBb0I7QUFDdkQsTUFBTUcsa0JBQWtCSCxtQkFBT0EsQ0FBQyxxRkFBaUI7QUFDakQsTUFBTUksTUFBTSxDQUFDLEdBQUdELGdCQUFnQkUsa0JBQWtCLEVBQUVGLGdCQUFnQkcsYUFBYSxFQUFFO0FBQ25GLE1BQU1DLGlCQUFpQixDQUFDLEdBQUdSLHFCQUFxQlMsT0FBTztBQUN2RCxNQUFNQyxNQUFNO0FBQ1osTUFBTVgsNEJBQTRCSSxtQkFBbUJRLGdCQUFnQjtJQUNqRUMsWUFBWUMsT0FBTyxDQUFDLENBQUMsQ0FBRTtRQUNuQixJQUFJQztRQUNKLHdCQUF3QjtRQUN4QixJQUFJLENBQUNELEtBQUtFLFFBQVEsRUFBRTtZQUNoQixNQUFNLElBQUlDLE1BQU07UUFDcEI7UUFDQSxLQUFLLENBQUNyQixPQUFPc0IsTUFBTSxDQUFDdEIsT0FBT3NCLE1BQU0sQ0FBQyxDQUFDLEdBQUdKLE9BQU87WUFBRUssb0JBQW9CLENBQUNKLEtBQUtELEtBQUtLLGtCQUFrQixNQUFNLFFBQVFKLE9BQU8sS0FBSyxJQUFJQSxLQUFLRCxLQUFLTSxlQUFlO1FBQUM7UUFDeEos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QStDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHNlLTIvbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2V0aC1ibG9jay10cmFja2VyL2Rpc3QvUG9sbGluZ0Jsb2NrVHJhY2tlci5qcz8zMWQyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qb2xsaW5nQmxvY2tUcmFja2VyID0gdm9pZCAwO1xuY29uc3QganNvbl9ycGNfcmFuZG9tX2lkXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImpzb24tcnBjLXJhbmRvbS1pZFwiKSk7XG5jb25zdCBwaWZ5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInBpZnlcIikpO1xuY29uc3QgQmFzZUJsb2NrVHJhY2tlcl8xID0gcmVxdWlyZShcIi4vQmFzZUJsb2NrVHJhY2tlclwiKTtcbmNvbnN0IGxvZ2dpbmdfdXRpbHNfMSA9IHJlcXVpcmUoXCIuL2xvZ2dpbmctdXRpbHNcIik7XG5jb25zdCBsb2cgPSAoMCwgbG9nZ2luZ191dGlsc18xLmNyZWF0ZU1vZHVsZUxvZ2dlcikobG9nZ2luZ191dGlsc18xLnByb2plY3RMb2dnZXIsICdwb2xsaW5nLWJsb2NrLXRyYWNrZXInKTtcbmNvbnN0IGNyZWF0ZVJhbmRvbUlkID0gKDAsIGpzb25fcnBjX3JhbmRvbV9pZF8xLmRlZmF1bHQpKCk7XG5jb25zdCBzZWMgPSAxMDAwO1xuY2xhc3MgUG9sbGluZ0Jsb2NrVHJhY2tlciBleHRlbmRzIEJhc2VCbG9ja1RyYWNrZXJfMS5CYXNlQmxvY2tUcmFja2VyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBwYXJzZSArIHZhbGlkYXRlIGFyZ3NcbiAgICAgICAgaWYgKCFvcHRzLnByb3ZpZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvbGxpbmdCbG9ja1RyYWNrZXIgLSBubyBwcm92aWRlciBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRzKSwgeyBibG9ja1Jlc2V0RHVyYXRpb246IChfYSA9IG9wdHMuYmxvY2tSZXNldER1cmF0aW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBvcHRzLnBvbGxpbmdJbnRlcnZhbCB9KSk7XG4gICAgICAgIC8vIGNvbmZpZ1xuICAgICAgICB0aGlzLl9wcm92aWRlciA9IG9wdHMucHJvdmlkZXI7XG4gICAgICAgIHRoaXMuX3BvbGxpbmdJbnRlcnZhbCA9IG9wdHMucG9sbGluZ0ludGVydmFsIHx8IDIwICogc2VjO1xuICAgICAgICB0aGlzLl9yZXRyeVRpbWVvdXQgPSBvcHRzLnJldHJ5VGltZW91dCB8fCB0aGlzLl9wb2xsaW5nSW50ZXJ2YWwgLyAxMDtcbiAgICAgICAgdGhpcy5fa2VlcEV2ZW50TG9vcEFjdGl2ZSA9XG4gICAgICAgICAgICBvcHRzLmtlZXBFdmVudExvb3BBY3RpdmUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRzLmtlZXBFdmVudExvb3BBY3RpdmU7XG4gICAgICAgIHRoaXMuX3NldFNraXBDYWNoZUZsYWcgPSBvcHRzLnNldFNraXBDYWNoZUZsYWcgfHwgZmFsc2U7XG4gICAgfVxuICAgIC8vIHRyaWdnZXIgYmxvY2sgcG9sbGluZ1xuICAgIGFzeW5jIGNoZWNrRm9yTGF0ZXN0QmxvY2soKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZUxhdGVzdEJsb2NrKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdldExhdGVzdEJsb2NrKCk7XG4gICAgfVxuICAgIGFzeW5jIF9zdGFydCgpIHtcbiAgICAgICAgdGhpcy5fc3luY2hyb25pemUoKTtcbiAgICB9XG4gICAgYXN5bmMgX2VuZCgpIHtcbiAgICAgICAgLy8gTm8tb3BcbiAgICB9XG4gICAgYXN5bmMgX3N5bmNocm9uaXplKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHdoaWxlICh0aGlzLl9pc1J1bm5pbmcpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlTGF0ZXN0QmxvY2soKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlID0gdGltZW91dCh0aGlzLl9wb2xsaW5nSW50ZXJ2YWwsICF0aGlzLl9rZWVwRXZlbnRMb29wQWN0aXZlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ193YWl0aW5nRm9yTmV4dEl0ZXJhdGlvbicpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RXJyID0gbmV3IEVycm9yKGBQb2xsaW5nQmxvY2tUcmFja2VyIC0gZW5jb3VudGVyZWQgYW4gZXJyb3Igd2hpbGUgYXR0ZW1wdGluZyB0byB1cGRhdGUgbGF0ZXN0IGJsb2NrOlxcbiR7KF9hID0gZXJyLnN0YWNrKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBlcnJ9YCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ld0Vycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlbWl0RXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobmV3RXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRpbWVvdXQodGhpcy5fcmV0cnlUaW1lb3V0LCAhdGhpcy5fa2VlcEV2ZW50TG9vcEFjdGl2ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdfd2FpdGluZ0Zvck5leHRJdGVyYXRpb24nKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBwcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF91cGRhdGVMYXRlc3RCbG9jaygpIHtcbiAgICAgICAgLy8gZmV0Y2ggKyBzZXQgbGF0ZXN0IGJsb2NrXG4gICAgICAgIGNvbnN0IGxhdGVzdEJsb2NrID0gYXdhaXQgdGhpcy5fZmV0Y2hMYXRlc3RCbG9jaygpO1xuICAgICAgICB0aGlzLl9uZXdQb3RlbnRpYWxMYXRlc3QobGF0ZXN0QmxvY2spO1xuICAgIH1cbiAgICBhc3luYyBfZmV0Y2hMYXRlc3RCbG9jaygpIHtcbiAgICAgICAgY29uc3QgcmVxID0ge1xuICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICBpZDogY3JlYXRlUmFuZG9tSWQoKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ2V0aF9ibG9ja051bWJlcicsXG4gICAgICAgICAgICBwYXJhbXM6IFtdLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5fc2V0U2tpcENhY2hlRmxhZykge1xuICAgICAgICAgICAgcmVxLnNraXBDYWNoZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbG9nKCdNYWtpbmcgcmVxdWVzdCcsIHJlcSk7XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0ICgwLCBwaWZ5XzEuZGVmYXVsdCkoKGNiKSA9PiB0aGlzLl9wcm92aWRlci5zZW5kQXN5bmMocmVxLCBjYikpKCk7XG4gICAgICAgIGxvZygnR290IHJlc3BvbnNlJywgcmVzKTtcbiAgICAgICAgaWYgKHJlcy5lcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb2xsaW5nQmxvY2tUcmFja2VyIC0gZW5jb3VudGVyZWQgZXJyb3IgZmV0Y2hpbmcgYmxvY2s6XFxuJHtyZXMuZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICB9XG59XG5leHBvcnRzLlBvbGxpbmdCbG9ja1RyYWNrZXIgPSBQb2xsaW5nQmxvY2tUcmFja2VyO1xuLyoqXG4gKiBXYWl0cyBmb3IgdGhlIHNwZWNpZmllZCBhbW91bnQgb2YgdGltZS5cbiAqXG4gKiBAcGFyYW0gZHVyYXRpb24gLSBUaGUgYW1vdW50IG9mIHRpbWUgaW4gbWlsbGlzZWNvbmRzLlxuICogQHBhcmFtIHVucmVmIC0gQXNzdW1pbmcgdGhpcyBmdW5jdGlvbiBpcyBydW4gaW4gYSBOb2RlIGNvbnRleHQsIGdvdmVybnNcbiAqIHdoZXRoZXIgTm9kZSBzaG91bGQgd2FpdCBiZWZvcmUgdGhlIGBzZXRUaW1lb3V0YCBoYXMgY29tcGxldGVkIGJlZm9yZSBlbmRpbmdcbiAqIHRoZSBwcm9jZXNzICh0cnVlIGZvciBubywgZmFsc2UgZm9yIHllcykuIERlZmF1bHRzIHRvIGZhbHNlLlxuICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgY2FuIGJlIHVzZWQgdG8gd2FpdC5cbiAqL1xuZnVuY3Rpb24gdGltZW91dChkdXJhdGlvbiwgdW5yZWYpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgY29uc3QgdGltZW91dFJlZiA9IHNldFRpbWVvdXQocmVzb2x2ZSwgZHVyYXRpb24pO1xuICAgICAgICAvLyBkb24ndCBrZWVwIHByb2Nlc3Mgb3BlblxuICAgICAgICBpZiAodGltZW91dFJlZi51bnJlZiAmJiB1bnJlZikge1xuICAgICAgICAgICAgdGltZW91dFJlZi51bnJlZigpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qb2xsaW5nQmxvY2tUcmFja2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2ltcG9ydERlZmF1bHQiLCJtb2QiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJQb2xsaW5nQmxvY2tUcmFja2VyIiwianNvbl9ycGNfcmFuZG9tX2lkXzEiLCJyZXF1aXJlIiwicGlmeV8xIiwiQmFzZUJsb2NrVHJhY2tlcl8xIiwibG9nZ2luZ191dGlsc18xIiwibG9nIiwiY3JlYXRlTW9kdWxlTG9nZ2VyIiwicHJvamVjdExvZ2dlciIsImNyZWF0ZVJhbmRvbUlkIiwiZGVmYXVsdCIsInNlYyIsIkJhc2VCbG9ja1RyYWNrZXIiLCJjb25zdHJ1Y3RvciIsIm9wdHMiLCJfYSIsInByb3ZpZGVyIiwiRXJyb3IiLCJhc3NpZ24iLCJibG9ja1Jlc2V0RHVyYXRpb24iLCJwb2xsaW5nSW50ZXJ2YWwiLCJfcHJvdmlkZXIiLCJfcG9sbGluZ0ludGVydmFsIiwiX3JldHJ5VGltZW91dCIsInJldHJ5VGltZW91dCIsIl9rZWVwRXZlbnRMb29wQWN0aXZlIiwia2VlcEV2ZW50TG9vcEFjdGl2ZSIsInVuZGVmaW5lZCIsIl9zZXRTa2lwQ2FjaGVGbGFnIiwic2V0U2tpcENhY2hlRmxhZyIsImNoZWNrRm9yTGF0ZXN0QmxvY2siLCJfdXBkYXRlTGF0ZXN0QmxvY2siLCJnZXRMYXRlc3RCbG9jayIsIl9zdGFydCIsIl9zeW5jaHJvbml6ZSIsIl9lbmQiLCJfaXNSdW5uaW5nIiwicHJvbWlzZSIsInRpbWVvdXQiLCJlbWl0IiwiZXJyIiwibmV3RXJyIiwic3RhY2siLCJlbWl0RXJyIiwiY29uc29sZSIsImVycm9yIiwibGF0ZXN0QmxvY2siLCJfZmV0Y2hMYXRlc3RCbG9jayIsIl9uZXdQb3RlbnRpYWxMYXRlc3QiLCJyZXEiLCJqc29ucnBjIiwiaWQiLCJtZXRob2QiLCJwYXJhbXMiLCJza2lwQ2FjaGUiLCJyZXMiLCJjYiIsInNlbmRBc3luYyIsIm1lc3NhZ2UiLCJyZXN1bHQiLCJkdXJhdGlvbiIsInVucmVmIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aW1lb3V0UmVmIiwic2V0VGltZW91dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/dist/PollingBlockTracker.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/dist/SubscribeBlockTracker.js":
/*!**********************************************************************!*\
  !*** ./node_modules/eth-block-tracker/dist/SubscribeBlockTracker.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.SubscribeBlockTracker = void 0;\nconst json_rpc_random_id_1 = __importDefault(__webpack_require__(/*! json-rpc-random-id */ \"(ssr)/./node_modules/json-rpc-random-id/index.js\"));\nconst BaseBlockTracker_1 = __webpack_require__(/*! ./BaseBlockTracker */ \"(ssr)/./node_modules/eth-block-tracker/dist/BaseBlockTracker.js\");\nconst createRandomId = (0, json_rpc_random_id_1.default)();\nclass SubscribeBlockTracker extends BaseBlockTracker_1.BaseBlockTracker {\n    constructor(opts = {}){\n        // parse + validate args\n        if (!opts.provider) {\n            throw new Error(\"SubscribeBlockTracker - no provider specified.\");\n        }\n        // BaseBlockTracker constructor\n        super(opts);\n        // config\n        this._provider = opts.provider;\n        this._subscriptionId = null;\n    }\n    async checkForLatestBlock() {\n        return await this.getLatestBlock();\n    }\n    async _start() {\n        if (this._subscriptionId === undefined || this._subscriptionId === null) {\n            try {\n                const blockNumber = await this._call(\"eth_blockNumber\");\n                this._subscriptionId = await this._call(\"eth_subscribe\", \"newHeads\");\n                this._provider.on(\"data\", this._handleSubData.bind(this));\n                this._newPotentialLatest(blockNumber);\n            } catch (e) {\n                this.emit(\"error\", e);\n            }\n        }\n    }\n    async _end() {\n        if (this._subscriptionId !== null && this._subscriptionId !== undefined) {\n            try {\n                await this._call(\"eth_unsubscribe\", this._subscriptionId);\n                this._subscriptionId = null;\n            } catch (e) {\n                this.emit(\"error\", e);\n            }\n        }\n    }\n    _call(method, ...params) {\n        return new Promise((resolve, reject)=>{\n            this._provider.sendAsync({\n                id: createRandomId(),\n                method,\n                params,\n                jsonrpc: \"2.0\"\n            }, (err, res)=>{\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(res.result);\n                }\n            });\n        });\n    }\n    _handleSubData(_, response) {\n        var _a;\n        if (response.method === \"eth_subscription\" && ((_a = response.params) === null || _a === void 0 ? void 0 : _a.subscription) === this._subscriptionId) {\n            this._newPotentialLatest(response.params.result.number);\n        }\n    }\n}\nexports.SubscribeBlockTracker = SubscribeBlockTracker; //# sourceMappingURL=SubscribeBlockTracker.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvZGlzdC9TdWJzY3JpYmVCbG9ja1RyYWNrZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsSUFBSyxJQUFJLElBQUksQ0FBQ0EsZUFBZSxJQUFLLFNBQVVDLEdBQUc7SUFDakUsT0FBTyxPQUFRQSxJQUFJQyxVQUFVLEdBQUlELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQzVEO0FBQ0FFLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCw2QkFBNkIsR0FBRyxLQUFLO0FBQ3JDLE1BQU1HLHVCQUF1QlIsZ0JBQWdCUyxtQkFBT0EsQ0FBQyw0RUFBb0I7QUFDekUsTUFBTUMscUJBQXFCRCxtQkFBT0EsQ0FBQywyRkFBb0I7QUFDdkQsTUFBTUUsaUJBQWlCLENBQUMsR0FBR0gscUJBQXFCSSxPQUFPO0FBQ3ZELE1BQU1MLDhCQUE4QkcsbUJBQW1CRyxnQkFBZ0I7SUFDbkVDLFlBQVlDLE9BQU8sQ0FBQyxDQUFDLENBQUU7UUFDbkIsd0JBQXdCO1FBQ3hCLElBQUksQ0FBQ0EsS0FBS0MsUUFBUSxFQUFFO1lBQ2hCLE1BQU0sSUFBSUMsTUFBTTtRQUNwQjtRQUNBLCtCQUErQjtRQUMvQixLQUFLLENBQUNGO1FBQ04sU0FBUztRQUNULElBQUksQ0FBQ0csU0FBUyxHQUFHSCxLQUFLQyxRQUFRO1FBQzlCLElBQUksQ0FBQ0csZUFBZSxHQUFHO0lBQzNCO0lBQ0EsTUFBTUMsc0JBQXNCO1FBQ3hCLE9BQU8sTUFBTSxJQUFJLENBQUNDLGNBQWM7SUFDcEM7SUFDQSxNQUFNQyxTQUFTO1FBQ1gsSUFBSSxJQUFJLENBQUNILGVBQWUsS0FBS0ksYUFBYSxJQUFJLENBQUNKLGVBQWUsS0FBSyxNQUFNO1lBQ3JFLElBQUk7Z0JBQ0EsTUFBTUssY0FBZSxNQUFNLElBQUksQ0FBQ0MsS0FBSyxDQUFDO2dCQUN0QyxJQUFJLENBQUNOLGVBQWUsR0FBSSxNQUFNLElBQUksQ0FBQ00sS0FBSyxDQUFDLGlCQUFpQjtnQkFDMUQsSUFBSSxDQUFDUCxTQUFTLENBQUNRLEVBQUUsQ0FBQyxRQUFRLElBQUksQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUMsSUFBSTtnQkFDdkQsSUFBSSxDQUFDQyxtQkFBbUIsQ0FBQ0w7WUFDN0IsRUFDQSxPQUFPTSxHQUFHO2dCQUNOLElBQUksQ0FBQ0MsSUFBSSxDQUFDLFNBQVNEO1lBQ3ZCO1FBQ0o7SUFDSjtJQUNBLE1BQU1FLE9BQU87UUFDVCxJQUFJLElBQUksQ0FBQ2IsZUFBZSxLQUFLLFFBQVEsSUFBSSxDQUFDQSxlQUFlLEtBQUtJLFdBQVc7WUFDckUsSUFBSTtnQkFDQSxNQUFNLElBQUksQ0FBQ0UsS0FBSyxDQUFDLG1CQUFtQixJQUFJLENBQUNOLGVBQWU7Z0JBQ3hELElBQUksQ0FBQ0EsZUFBZSxHQUFHO1lBQzNCLEVBQ0EsT0FBT1csR0FBRztnQkFDTixJQUFJLENBQUNDLElBQUksQ0FBQyxTQUFTRDtZQUN2QjtRQUNKO0lBQ0o7SUFDQUwsTUFBTVEsTUFBTSxFQUFFLEdBQUdDLE1BQU0sRUFBRTtRQUNyQixPQUFPLElBQUlDLFFBQVEsQ0FBQ0MsU0FBU0M7WUFDekIsSUFBSSxDQUFDbkIsU0FBUyxDQUFDb0IsU0FBUyxDQUFDO2dCQUNyQkMsSUFBSTVCO2dCQUNKc0I7Z0JBQ0FDO2dCQUNBTSxTQUFTO1lBQ2IsR0FBRyxDQUFDQyxLQUFLQztnQkFDTCxJQUFJRCxLQUFLO29CQUNMSixPQUFPSTtnQkFDWCxPQUNLO29CQUNETCxRQUFRTSxJQUFJQyxNQUFNO2dCQUN0QjtZQUNKO1FBQ0o7SUFDSjtJQUNBaEIsZUFBZWlCLENBQUMsRUFBRUMsUUFBUSxFQUFFO1FBQ3hCLElBQUlDO1FBQ0osSUFBSUQsU0FBU1osTUFBTSxLQUFLLHNCQUNwQixDQUFDLENBQUNhLEtBQUtELFNBQVNYLE1BQU0sTUFBTSxRQUFRWSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdDLFlBQVksTUFBTSxJQUFJLENBQUM1QixlQUFlLEVBQUU7WUFDeEcsSUFBSSxDQUFDVSxtQkFBbUIsQ0FBQ2dCLFNBQVNYLE1BQU0sQ0FBQ1MsTUFBTSxDQUFDSyxNQUFNO1FBQzFEO0lBQ0o7QUFDSjtBQUNBM0MsNkJBQTZCLEdBQUdFLHVCQUNoQyxpREFBaUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac2UtMi9uZXh0anMvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvZGlzdC9TdWJzY3JpYmVCbG9ja1RyYWNrZXIuanM/YmQ4YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3Vic2NyaWJlQmxvY2tUcmFja2VyID0gdm9pZCAwO1xuY29uc3QganNvbl9ycGNfcmFuZG9tX2lkXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImpzb24tcnBjLXJhbmRvbS1pZFwiKSk7XG5jb25zdCBCYXNlQmxvY2tUcmFja2VyXzEgPSByZXF1aXJlKFwiLi9CYXNlQmxvY2tUcmFja2VyXCIpO1xuY29uc3QgY3JlYXRlUmFuZG9tSWQgPSAoMCwganNvbl9ycGNfcmFuZG9tX2lkXzEuZGVmYXVsdCkoKTtcbmNsYXNzIFN1YnNjcmliZUJsb2NrVHJhY2tlciBleHRlbmRzIEJhc2VCbG9ja1RyYWNrZXJfMS5CYXNlQmxvY2tUcmFja2VyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICAgICAgLy8gcGFyc2UgKyB2YWxpZGF0ZSBhcmdzXG4gICAgICAgIGlmICghb3B0cy5wcm92aWRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdWJzY3JpYmVCbG9ja1RyYWNrZXIgLSBubyBwcm92aWRlciBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmFzZUJsb2NrVHJhY2tlciBjb25zdHJ1Y3RvclxuICAgICAgICBzdXBlcihvcHRzKTtcbiAgICAgICAgLy8gY29uZmlnXG4gICAgICAgIHRoaXMuX3Byb3ZpZGVyID0gb3B0cy5wcm92aWRlcjtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uSWQgPSBudWxsO1xuICAgIH1cbiAgICBhc3luYyBjaGVja0ZvckxhdGVzdEJsb2NrKCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRMYXRlc3RCbG9jaygpO1xuICAgIH1cbiAgICBhc3luYyBfc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdWJzY3JpcHRpb25JZCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3N1YnNjcmlwdGlvbklkID09PSBudWxsKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gKGF3YWl0IHRoaXMuX2NhbGwoJ2V0aF9ibG9ja051bWJlcicpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25JZCA9IChhd2FpdCB0aGlzLl9jYWxsKCdldGhfc3Vic2NyaWJlJywgJ25ld0hlYWRzJykpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb3ZpZGVyLm9uKCdkYXRhJywgdGhpcy5faGFuZGxlU3ViRGF0YS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9uZXdQb3RlbnRpYWxMYXRlc3QoYmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2VuZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N1YnNjcmlwdGlvbklkICE9PSBudWxsICYmIHRoaXMuX3N1YnNjcmlwdGlvbklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fY2FsbCgnZXRoX3Vuc3Vic2NyaWJlJywgdGhpcy5fc3Vic2NyaXB0aW9uSWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbklkID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9jYWxsKG1ldGhvZCwgLi4ucGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9wcm92aWRlci5zZW5kQXN5bmMoe1xuICAgICAgICAgICAgICAgIGlkOiBjcmVhdGVSYW5kb21JZCgpLFxuICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICB9LCAoZXJyLCByZXMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXMucmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9oYW5kbGVTdWJEYXRhKF8sIHJlc3BvbnNlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLm1ldGhvZCA9PT0gJ2V0aF9zdWJzY3JpcHRpb24nICYmXG4gICAgICAgICAgICAoKF9hID0gcmVzcG9uc2UucGFyYW1zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3Vic2NyaXB0aW9uKSA9PT0gdGhpcy5fc3Vic2NyaXB0aW9uSWQpIHtcbiAgICAgICAgICAgIHRoaXMuX25ld1BvdGVudGlhbExhdGVzdChyZXNwb25zZS5wYXJhbXMucmVzdWx0Lm51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlN1YnNjcmliZUJsb2NrVHJhY2tlciA9IFN1YnNjcmliZUJsb2NrVHJhY2tlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1YnNjcmliZUJsb2NrVHJhY2tlci5qcy5tYXAiXSwibmFtZXMiOlsiX19pbXBvcnREZWZhdWx0IiwibW9kIiwiX19lc01vZHVsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiU3Vic2NyaWJlQmxvY2tUcmFja2VyIiwianNvbl9ycGNfcmFuZG9tX2lkXzEiLCJyZXF1aXJlIiwiQmFzZUJsb2NrVHJhY2tlcl8xIiwiY3JlYXRlUmFuZG9tSWQiLCJkZWZhdWx0IiwiQmFzZUJsb2NrVHJhY2tlciIsImNvbnN0cnVjdG9yIiwib3B0cyIsInByb3ZpZGVyIiwiRXJyb3IiLCJfcHJvdmlkZXIiLCJfc3Vic2NyaXB0aW9uSWQiLCJjaGVja0ZvckxhdGVzdEJsb2NrIiwiZ2V0TGF0ZXN0QmxvY2siLCJfc3RhcnQiLCJ1bmRlZmluZWQiLCJibG9ja051bWJlciIsIl9jYWxsIiwib24iLCJfaGFuZGxlU3ViRGF0YSIsImJpbmQiLCJfbmV3UG90ZW50aWFsTGF0ZXN0IiwiZSIsImVtaXQiLCJfZW5kIiwibWV0aG9kIiwicGFyYW1zIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJzZW5kQXN5bmMiLCJpZCIsImpzb25ycGMiLCJlcnIiLCJyZXMiLCJyZXN1bHQiLCJfIiwicmVzcG9uc2UiLCJfYSIsInN1YnNjcmlwdGlvbiIsIm51bWJlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/dist/SubscribeBlockTracker.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/eth-block-tracker/dist/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, {\n        enumerable: true,\n        get: function() {\n            return m[k];\n        }\n    });\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __exportStar = this && this.__exportStar || function(m, exports1) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n__exportStar(__webpack_require__(/*! ./PollingBlockTracker */ \"(ssr)/./node_modules/eth-block-tracker/dist/PollingBlockTracker.js\"), exports);\n__exportStar(__webpack_require__(/*! ./SubscribeBlockTracker */ \"(ssr)/./node_modules/eth-block-tracker/dist/SubscribeBlockTracker.js\"), exports); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixJQUFLLElBQUksSUFBSSxDQUFDQSxlQUFlLElBQU1DLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQzFGLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCSixPQUFPTyxjQUFjLENBQUNMLEdBQUdHLElBQUk7UUFBRUcsWUFBWTtRQUFNQyxLQUFLO1lBQWEsT0FBT04sQ0FBQyxDQUFDQyxFQUFFO1FBQUU7SUFBRTtBQUN0RixJQUFNLFNBQVNGLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDdEIsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0JGLENBQUMsQ0FBQ0csR0FBRyxHQUFHRixDQUFDLENBQUNDLEVBQUU7QUFDaEIsQ0FBQztBQUNELElBQUlNLGVBQWUsSUFBSyxJQUFJLElBQUksQ0FBQ0EsWUFBWSxJQUFLLFNBQVNQLENBQUMsRUFBRVEsUUFBTztJQUNqRSxJQUFLLElBQUlDLEtBQUtULEVBQUcsSUFBSVMsTUFBTSxhQUFhLENBQUNaLE9BQU9hLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNKLFVBQVNDLElBQUliLGdCQUFnQlksVUFBU1IsR0FBR1M7QUFDM0g7QUFDQVosOENBQTZDO0lBQUVnQixPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdETixhQUFhTyxtQkFBT0EsQ0FBQyxpR0FBdUIsR0FBR047QUFDL0NELGFBQWFPLG1CQUFPQSxDQUFDLHFHQUF5QixHQUFHTixVQUNqRCxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac2UtMi9uZXh0anMvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvZGlzdC9pbmRleC5qcz9hYmFiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vUG9sbGluZ0Jsb2NrVHJhY2tlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vU3Vic2NyaWJlQmxvY2tUcmFja2VyXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJfX2NyZWF0ZUJpbmRpbmciLCJPYmplY3QiLCJjcmVhdGUiLCJvIiwibSIsImsiLCJrMiIsInVuZGVmaW5lZCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImdldCIsIl9fZXhwb3J0U3RhciIsImV4cG9ydHMiLCJwIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwidmFsdWUiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/dist/logging-utils.js":
/*!**************************************************************!*\
  !*** ./node_modules/eth-block-tracker/dist/logging-utils.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createModuleLogger = exports.projectLogger = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/index.js\");\nObject.defineProperty(exports, \"createModuleLogger\", ({\n    enumerable: true,\n    get: function() {\n        return utils_1.createModuleLogger;\n    }\n}));\nexports.projectLogger = (0, utils_1.createProjectLogger)(\"eth-block-tracker\"); //# sourceMappingURL=logging-utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvZGlzdC9sb2dnaW5nLXV0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwwQkFBMEIsR0FBR0EscUJBQXFCLEdBQUcsS0FBSztBQUMxRCxNQUFNSSxVQUFVQyxtQkFBT0EsQ0FBQywwR0FBaUI7QUFDekNQLHNEQUFxRDtJQUFFUSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPSCxRQUFRRixrQkFBa0I7SUFBRTtBQUFFLENBQUMsRUFBQztBQUNuSUYscUJBQXFCLEdBQUcsQ0FBQyxHQUFHSSxRQUFRSSxtQkFBbUIsRUFBRSxzQkFDekQseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHNlLTIvbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2V0aC1ibG9jay10cmFja2VyL2Rpc3QvbG9nZ2luZy11dGlscy5qcz9kYTE2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVNb2R1bGVMb2dnZXIgPSBleHBvcnRzLnByb2plY3RMb2dnZXIgPSB2b2lkIDA7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay91dGlsc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZU1vZHVsZUxvZ2dlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMS5jcmVhdGVNb2R1bGVMb2dnZXI7IH0gfSk7XG5leHBvcnRzLnByb2plY3RMb2dnZXIgPSAoMCwgdXRpbHNfMS5jcmVhdGVQcm9qZWN0TG9nZ2VyKSgnZXRoLWJsb2NrLXRyYWNrZXInKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZ2dpbmctdXRpbHMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiY3JlYXRlTW9kdWxlTG9nZ2VyIiwicHJvamVjdExvZ2dlciIsInV0aWxzXzEiLCJyZXF1aXJlIiwiZW51bWVyYWJsZSIsImdldCIsImNyZWF0ZVByb2plY3RMb2dnZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/dist/logging-utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/assert.js":
/*!************************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/assert.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.assertExhaustive = exports.assertStruct = exports.assert = exports.AssertionError = void 0;\nconst superstruct_1 = __webpack_require__(/*! superstruct */ \"(ssr)/./node_modules/superstruct/dist/index.mjs\");\n/**\n * Type guard for determining whether the given value is an error object with a\n * `message` property, such as an instance of Error.\n *\n * @param error - The object to check.\n * @returns True or false, depending on the result.\n */ function isErrorWithMessage(error) {\n    return typeof error === \"object\" && error !== null && \"message\" in error;\n}\n/**\n * Check if a value is a constructor, i.e., a function that can be called with\n * the `new` keyword.\n *\n * @param fn - The value to check.\n * @returns `true` if the value is a constructor, or `false` otherwise.\n */ function isConstructable(fn) {\n    var _a, _b;\n    /* istanbul ignore next */ return Boolean(typeof ((_b = (_a = fn === null || fn === void 0 ? void 0 : fn.prototype) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.name) === \"string\");\n}\n/**\n * Get the error message from an unknown error object. If the error object has\n * a `message` property, that property is returned. Otherwise, the stringified\n * error object is returned.\n *\n * @param error - The error object to get the message from.\n * @returns The error message.\n */ function getErrorMessage(error) {\n    const message = isErrorWithMessage(error) ? error.message : String(error);\n    // If the error ends with a period, remove it, as we'll add our own period.\n    if (message.endsWith(\".\")) {\n        return message.slice(0, -1);\n    }\n    return message;\n}\n/**\n * Initialise an {@link AssertionErrorConstructor} error.\n *\n * @param ErrorWrapper - The error class to use.\n * @param message - The error message.\n * @returns The error object.\n */ // eslint-disable-next-line @typescript-eslint/naming-convention\nfunction getError(ErrorWrapper, message) {\n    if (isConstructable(ErrorWrapper)) {\n        return new ErrorWrapper({\n            message\n        });\n    }\n    return ErrorWrapper({\n        message\n    });\n}\n/**\n * The default error class that is thrown if an assertion fails.\n */ class AssertionError extends Error {\n    constructor(options){\n        super(options.message);\n        this.code = \"ERR_ASSERTION\";\n    }\n}\nexports.AssertionError = AssertionError;\n/**\n * Same as Node.js assert.\n * If the value is falsy, throws an error, does nothing otherwise.\n *\n * @throws {@link AssertionError} If value is falsy.\n * @param value - The test that should be truthy to pass.\n * @param message - Message to be passed to {@link AssertionError} or an\n * {@link Error} instance to throw.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}. If a custom error class is provided for\n * the `message` argument, this argument is ignored.\n */ function assert(value, message = \"Assertion failed.\", // eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper = AssertionError) {\n    if (!value) {\n        if (message instanceof Error) {\n            throw message;\n        }\n        throw getError(ErrorWrapper, message);\n    }\n}\nexports.assert = assert;\n/**\n * Assert a value against a Superstruct struct.\n *\n * @param value - The value to validate.\n * @param struct - The struct to validate against.\n * @param errorPrefix - A prefix to add to the error message. Defaults to\n * \"Assertion failed\".\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the value is not valid.\n */ function assertStruct(value, struct, errorPrefix = \"Assertion failed\", // eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper = AssertionError) {\n    try {\n        (0, superstruct_1.assert)(value, struct);\n    } catch (error) {\n        throw getError(ErrorWrapper, `${errorPrefix}: ${getErrorMessage(error)}.`);\n    }\n}\nexports.assertStruct = assertStruct;\n/**\n * Use in the default case of a switch that you want to be fully exhaustive.\n * Using this function forces the compiler to enforce exhaustivity during\n * compile-time.\n *\n * @example\n * ```\n * const number = 1;\n * switch (number) {\n *   case 0:\n *     ...\n *   case 1:\n *     ...\n *   default:\n *     assertExhaustive(snapPrefix);\n * }\n * ```\n * @param _object - The object on which the switch is being operated.\n */ function assertExhaustive(_object) {\n    throw new Error(\"Invalid branch reached. Should be detected during compilation.\");\n}\nexports.assertExhaustive = assertExhaustive; //# sourceMappingURL=assert.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2Fzc2VydC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsd0JBQXdCLEdBQUdBLG9CQUFvQixHQUFHQSxjQUFjLEdBQUdBLHNCQUFzQixHQUFHLEtBQUs7QUFDakcsTUFBTU0sZ0JBQWdCQyxtQkFBT0EsQ0FBQyxvRUFBYTtBQUMzQzs7Ozs7O0NBTUMsR0FDRCxTQUFTQyxtQkFBbUJDLEtBQUs7SUFDN0IsT0FBTyxPQUFPQSxVQUFVLFlBQVlBLFVBQVUsUUFBUSxhQUFhQTtBQUN2RTtBQUNBOzs7Ozs7Q0FNQyxHQUNELFNBQVNDLGdCQUFnQkMsRUFBRTtJQUN2QixJQUFJQyxJQUFJQztJQUNSLHdCQUF3QixHQUN4QixPQUFPQyxRQUFRLE9BQVEsRUFBQ0QsS0FBSyxDQUFDRCxLQUFLRCxPQUFPLFFBQVFBLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0ksU0FBUyxNQUFNLFFBQVFILE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0ksV0FBVyxNQUFNLFFBQVFILE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0ksSUFBSSxNQUFNO0FBQ3BNO0FBQ0E7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNDLGdCQUFnQlQsS0FBSztJQUMxQixNQUFNVSxVQUFVWCxtQkFBbUJDLFNBQVNBLE1BQU1VLE9BQU8sR0FBR0MsT0FBT1g7SUFDbkUsMkVBQTJFO0lBQzNFLElBQUlVLFFBQVFFLFFBQVEsQ0FBQyxNQUFNO1FBQ3ZCLE9BQU9GLFFBQVFHLEtBQUssQ0FBQyxHQUFHLENBQUM7SUFDN0I7SUFDQSxPQUFPSDtBQUNYO0FBQ0E7Ozs7OztDQU1DLEdBQ0QsZ0VBQWdFO0FBQ2hFLFNBQVNJLFNBQVNDLFlBQVksRUFBRUwsT0FBTztJQUNuQyxJQUFJVCxnQkFBZ0JjLGVBQWU7UUFDL0IsT0FBTyxJQUFJQSxhQUFhO1lBQ3BCTDtRQUNKO0lBQ0o7SUFDQSxPQUFPSyxhQUFhO1FBQ2hCTDtJQUNKO0FBQ0o7QUFDQTs7Q0FFQyxHQUNELE1BQU1kLHVCQUF1Qm9CO0lBQ3pCVCxZQUFZVSxPQUFPLENBQUU7UUFDakIsS0FBSyxDQUFDQSxRQUFRUCxPQUFPO1FBQ3JCLElBQUksQ0FBQ1EsSUFBSSxHQUFHO0lBQ2hCO0FBQ0o7QUFDQTNCLHNCQUFzQixHQUFHSztBQUN6Qjs7Ozs7Ozs7Ozs7Q0FXQyxHQUNELFNBQVNELE9BQU9ILEtBQUssRUFBRWtCLFVBQVUsbUJBQW1CLEVBQ3BELGdFQUFnRTtBQUNoRUssZUFBZW5CLGNBQWM7SUFDekIsSUFBSSxDQUFDSixPQUFPO1FBQ1IsSUFBSWtCLG1CQUFtQk0sT0FBTztZQUMxQixNQUFNTjtRQUNWO1FBQ0EsTUFBTUksU0FBU0MsY0FBY0w7SUFDakM7QUFDSjtBQUNBbkIsY0FBYyxHQUFHSTtBQUNqQjs7Ozs7Ozs7OztDQVVDLEdBQ0QsU0FBU0QsYUFBYUYsS0FBSyxFQUFFMkIsTUFBTSxFQUFFQyxjQUFjLGtCQUFrQixFQUNyRSxnRUFBZ0U7QUFDaEVMLGVBQWVuQixjQUFjO0lBQ3pCLElBQUk7UUFDQyxJQUFHQyxjQUFjRixNQUFNLEVBQUVILE9BQU8yQjtJQUNyQyxFQUNBLE9BQU9uQixPQUFPO1FBQ1YsTUFBTWMsU0FBU0MsY0FBYyxDQUFDLEVBQUVLLFlBQVksRUFBRSxFQUFFWCxnQkFBZ0JULE9BQU8sQ0FBQyxDQUFDO0lBQzdFO0FBQ0o7QUFDQVQsb0JBQW9CLEdBQUdHO0FBQ3ZCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrQkMsR0FDRCxTQUFTRCxpQkFBaUI0QixPQUFPO0lBQzdCLE1BQU0sSUFBSUwsTUFBTTtBQUNwQjtBQUNBekIsd0JBQXdCLEdBQUdFLGtCQUMzQixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac2UtMi9uZXh0anMvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2Fzc2VydC5qcz9hZWM2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hc3NlcnRFeGhhdXN0aXZlID0gZXhwb3J0cy5hc3NlcnRTdHJ1Y3QgPSBleHBvcnRzLmFzc2VydCA9IGV4cG9ydHMuQXNzZXJ0aW9uRXJyb3IgPSB2b2lkIDA7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcInN1cGVyc3RydWN0XCIpO1xuLyoqXG4gKiBUeXBlIGd1YXJkIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBlcnJvciBvYmplY3Qgd2l0aCBhXG4gKiBgbWVzc2FnZWAgcHJvcGVydHksIHN1Y2ggYXMgYW4gaW5zdGFuY2Ugb2YgRXJyb3IuXG4gKlxuICogQHBhcmFtIGVycm9yIC0gVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm5zIFRydWUgb3IgZmFsc2UsIGRlcGVuZGluZyBvbiB0aGUgcmVzdWx0LlxuICovXG5mdW5jdGlvbiBpc0Vycm9yV2l0aE1lc3NhZ2UoZXJyb3IpIHtcbiAgICByZXR1cm4gdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiBlcnJvciAhPT0gbnVsbCAmJiAnbWVzc2FnZScgaW4gZXJyb3I7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBjb25zdHJ1Y3RvciwgaS5lLiwgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSBjYWxsZWQgd2l0aFxuICogdGhlIGBuZXdgIGtleXdvcmQuXG4gKlxuICogQHBhcmFtIGZuIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhIGNvbnN0cnVjdG9yLCBvciBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNDb25zdHJ1Y3RhYmxlKGZuKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiBCb29sZWFuKHR5cGVvZiAoKF9iID0gKF9hID0gZm4gPT09IG51bGwgfHwgZm4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZuLnByb3RvdHlwZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnN0cnVjdG9yKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubmFtZSkgPT09ICdzdHJpbmcnKTtcbn1cbi8qKlxuICogR2V0IHRoZSBlcnJvciBtZXNzYWdlIGZyb20gYW4gdW5rbm93biBlcnJvciBvYmplY3QuIElmIHRoZSBlcnJvciBvYmplY3QgaGFzXG4gKiBhIGBtZXNzYWdlYCBwcm9wZXJ0eSwgdGhhdCBwcm9wZXJ0eSBpcyByZXR1cm5lZC4gT3RoZXJ3aXNlLCB0aGUgc3RyaW5naWZpZWRcbiAqIGVycm9yIG9iamVjdCBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgZXJyb3Igb2JqZWN0IHRvIGdldCB0aGUgbWVzc2FnZSBmcm9tLlxuICogQHJldHVybnMgVGhlIGVycm9yIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZShlcnJvcikge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBpc0Vycm9yV2l0aE1lc3NhZ2UoZXJyb3IpID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgLy8gSWYgdGhlIGVycm9yIGVuZHMgd2l0aCBhIHBlcmlvZCwgcmVtb3ZlIGl0LCBhcyB3ZSdsbCBhZGQgb3VyIG93biBwZXJpb2QuXG4gICAgaWYgKG1lc3NhZ2UuZW5kc1dpdGgoJy4nKSkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZS5zbGljZSgwLCAtMSk7XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xufVxuLyoqXG4gKiBJbml0aWFsaXNlIGFuIHtAbGluayBBc3NlcnRpb25FcnJvckNvbnN0cnVjdG9yfSBlcnJvci5cbiAqXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHVzZS5cbiAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyBUaGUgZXJyb3Igb2JqZWN0LlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5mdW5jdGlvbiBnZXRFcnJvcihFcnJvcldyYXBwZXIsIG1lc3NhZ2UpIHtcbiAgICBpZiAoaXNDb25zdHJ1Y3RhYmxlKEVycm9yV3JhcHBlcikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcldyYXBwZXIoe1xuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBFcnJvcldyYXBwZXIoe1xuICAgICAgICBtZXNzYWdlLFxuICAgIH0pO1xufVxuLyoqXG4gKiBUaGUgZGVmYXVsdCBlcnJvciBjbGFzcyB0aGF0IGlzIHRocm93biBpZiBhbiBhc3NlcnRpb24gZmFpbHMuXG4gKi9cbmNsYXNzIEFzc2VydGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucy5tZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jb2RlID0gJ0VSUl9BU1NFUlRJT04nO1xuICAgIH1cbn1cbmV4cG9ydHMuQXNzZXJ0aW9uRXJyb3IgPSBBc3NlcnRpb25FcnJvcjtcbi8qKlxuICogU2FtZSBhcyBOb2RlLmpzIGFzc2VydC5cbiAqIElmIHRoZSB2YWx1ZSBpcyBmYWxzeSwgdGhyb3dzIGFuIGVycm9yLCBkb2VzIG5vdGhpbmcgb3RoZXJ3aXNlLlxuICpcbiAqIEB0aHJvd3Mge0BsaW5rIEFzc2VydGlvbkVycm9yfSBJZiB2YWx1ZSBpcyBmYWxzeS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB0ZXN0IHRoYXQgc2hvdWxkIGJlIHRydXRoeSB0byBwYXNzLlxuICogQHBhcmFtIG1lc3NhZ2UgLSBNZXNzYWdlIHRvIGJlIHBhc3NlZCB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9IG9yIGFuXG4gKiB7QGxpbmsgRXJyb3J9IGluc3RhbmNlIHRvIHRocm93LlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS4gSWYgYSBjdXN0b20gZXJyb3IgY2xhc3MgaXMgcHJvdmlkZWQgZm9yXG4gKiB0aGUgYG1lc3NhZ2VgIGFyZ3VtZW50LCB0aGlzIGFyZ3VtZW50IGlzIGlnbm9yZWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydCh2YWx1ZSwgbWVzc2FnZSA9ICdBc3NlcnRpb24gZmFpbGVkLicsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyID0gQXNzZXJ0aW9uRXJyb3IpIHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZ2V0RXJyb3IoRXJyb3JXcmFwcGVyLCBtZXNzYWdlKTtcbiAgICB9XG59XG5leHBvcnRzLmFzc2VydCA9IGFzc2VydDtcbi8qKlxuICogQXNzZXJ0IGEgdmFsdWUgYWdhaW5zdCBhIFN1cGVyc3RydWN0IHN0cnVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdmFsaWRhdGUuXG4gKiBAcGFyYW0gc3RydWN0IC0gVGhlIHN0cnVjdCB0byB2YWxpZGF0ZSBhZ2FpbnN0LlxuICogQHBhcmFtIGVycm9yUHJlZml4IC0gQSBwcmVmaXggdG8gYWRkIHRvIHRoZSBlcnJvciBtZXNzYWdlLiBEZWZhdWx0cyB0b1xuICogXCJBc3NlcnRpb24gZmFpbGVkXCIuXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHRocm93IGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9LlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IHZhbGlkLlxuICovXG5mdW5jdGlvbiBhc3NlcnRTdHJ1Y3QodmFsdWUsIHN0cnVjdCwgZXJyb3JQcmVmaXggPSAnQXNzZXJ0aW9uIGZhaWxlZCcsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyID0gQXNzZXJ0aW9uRXJyb3IpIHtcbiAgICB0cnkge1xuICAgICAgICAoMCwgc3VwZXJzdHJ1Y3RfMS5hc3NlcnQpKHZhbHVlLCBzdHJ1Y3QpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZ2V0RXJyb3IoRXJyb3JXcmFwcGVyLCBgJHtlcnJvclByZWZpeH06ICR7Z2V0RXJyb3JNZXNzYWdlKGVycm9yKX0uYCk7XG4gICAgfVxufVxuZXhwb3J0cy5hc3NlcnRTdHJ1Y3QgPSBhc3NlcnRTdHJ1Y3Q7XG4vKipcbiAqIFVzZSBpbiB0aGUgZGVmYXVsdCBjYXNlIG9mIGEgc3dpdGNoIHRoYXQgeW91IHdhbnQgdG8gYmUgZnVsbHkgZXhoYXVzdGl2ZS5cbiAqIFVzaW5nIHRoaXMgZnVuY3Rpb24gZm9yY2VzIHRoZSBjb21waWxlciB0byBlbmZvcmNlIGV4aGF1c3Rpdml0eSBkdXJpbmdcbiAqIGNvbXBpbGUtdGltZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKiBjb25zdCBudW1iZXIgPSAxO1xuICogc3dpdGNoIChudW1iZXIpIHtcbiAqICAgY2FzZSAwOlxuICogICAgIC4uLlxuICogICBjYXNlIDE6XG4gKiAgICAgLi4uXG4gKiAgIGRlZmF1bHQ6XG4gKiAgICAgYXNzZXJ0RXhoYXVzdGl2ZShzbmFwUHJlZml4KTtcbiAqIH1cbiAqIGBgYFxuICogQHBhcmFtIF9vYmplY3QgLSBUaGUgb2JqZWN0IG9uIHdoaWNoIHRoZSBzd2l0Y2ggaXMgYmVpbmcgb3BlcmF0ZWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydEV4aGF1c3RpdmUoX29iamVjdCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBicmFuY2ggcmVhY2hlZC4gU2hvdWxkIGJlIGRldGVjdGVkIGR1cmluZyBjb21waWxhdGlvbi4nKTtcbn1cbmV4cG9ydHMuYXNzZXJ0RXhoYXVzdGl2ZSA9IGFzc2VydEV4aGF1c3RpdmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3NlcnQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiYXNzZXJ0RXhoYXVzdGl2ZSIsImFzc2VydFN0cnVjdCIsImFzc2VydCIsIkFzc2VydGlvbkVycm9yIiwic3VwZXJzdHJ1Y3RfMSIsInJlcXVpcmUiLCJpc0Vycm9yV2l0aE1lc3NhZ2UiLCJlcnJvciIsImlzQ29uc3RydWN0YWJsZSIsImZuIiwiX2EiLCJfYiIsIkJvb2xlYW4iLCJwcm90b3R5cGUiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJnZXRFcnJvck1lc3NhZ2UiLCJtZXNzYWdlIiwiU3RyaW5nIiwiZW5kc1dpdGgiLCJzbGljZSIsImdldEVycm9yIiwiRXJyb3JXcmFwcGVyIiwiRXJyb3IiLCJvcHRpb25zIiwiY29kZSIsInN0cnVjdCIsImVycm9yUHJlZml4IiwiX29iamVjdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/assert.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/base64.js":
/*!************************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/base64.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.base64 = void 0;\nconst superstruct_1 = __webpack_require__(/*! superstruct */ \"(ssr)/./node_modules/superstruct/dist/index.mjs\");\nconst assert_1 = __webpack_require__(/*! ./assert */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/assert.js\");\n/**\n * Ensure that a provided string-based struct is valid base64.\n *\n * @param struct - The string based struct.\n * @param options - Optional options to specialize base64 validation. See {@link Base64Options} documentation.\n * @returns A superstruct validating base64.\n */ const base64 = (struct, options = {})=>{\n    var _a, _b;\n    const paddingRequired = (_a = options.paddingRequired) !== null && _a !== void 0 ? _a : false;\n    const characterSet = (_b = options.characterSet) !== null && _b !== void 0 ? _b : \"base64\";\n    let letters;\n    if (characterSet === \"base64\") {\n        letters = String.raw`[A-Za-z0-9+\\/]`;\n    } else {\n        (0, assert_1.assert)(characterSet === \"base64url\");\n        letters = String.raw`[-_A-Za-z0-9]`;\n    }\n    let re;\n    if (paddingRequired) {\n        re = new RegExp(`^(?:${letters}{4})*(?:${letters}{3}=|${letters}{2}==)?$`, \"u\");\n    } else {\n        re = new RegExp(`^(?:${letters}{4})*(?:${letters}{2,3}|${letters}{3}=|${letters}{2}==)?$`, \"u\");\n    }\n    return (0, superstruct_1.pattern)(struct, re);\n};\nexports.base64 = base64; //# sourceMappingURL=base64.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2Jhc2U2NC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsY0FBYyxHQUFHLEtBQUs7QUFDdEIsTUFBTUcsZ0JBQWdCQyxtQkFBT0EsQ0FBQyxvRUFBYTtBQUMzQyxNQUFNQyxXQUFXRCxtQkFBT0EsQ0FBQyxvR0FBVTtBQUNuQzs7Ozs7O0NBTUMsR0FDRCxNQUFNRixTQUFTLENBQUNJLFFBQVFDLFVBQVUsQ0FBQyxDQUFDO0lBQ2hDLElBQUlDLElBQUlDO0lBQ1IsTUFBTUMsa0JBQWtCLENBQUNGLEtBQUtELFFBQVFHLGVBQWUsTUFBTSxRQUFRRixPQUFPLEtBQUssSUFBSUEsS0FBSztJQUN4RixNQUFNRyxlQUFlLENBQUNGLEtBQUtGLFFBQVFJLFlBQVksTUFBTSxRQUFRRixPQUFPLEtBQUssSUFBSUEsS0FBSztJQUNsRixJQUFJRztJQUNKLElBQUlELGlCQUFpQixVQUFVO1FBQzNCQyxVQUFVQyxPQUFPQyxHQUFHLENBQUUsY0FBYyxDQUFDO0lBQ3pDLE9BQ0s7UUFDQSxJQUFHVCxTQUFTVSxNQUFNLEVBQUVKLGlCQUFpQjtRQUN0Q0MsVUFBVUMsT0FBT0MsR0FBRyxDQUFFLGFBQWEsQ0FBQztJQUN4QztJQUNBLElBQUlFO0lBQ0osSUFBSU4saUJBQWlCO1FBQ2pCTSxLQUFLLElBQUlDLE9BQU8sQ0FBQyxJQUFJLEVBQUVMLFFBQVEsUUFBUSxFQUFFQSxRQUFRLEtBQUssRUFBRUEsUUFBUSxRQUFRLENBQUMsRUFBRTtJQUMvRSxPQUNLO1FBQ0RJLEtBQUssSUFBSUMsT0FBTyxDQUFDLElBQUksRUFBRUwsUUFBUSxRQUFRLEVBQUVBLFFBQVEsTUFBTSxFQUFFQSxRQUFRLEtBQUssRUFBRUEsUUFBUSxRQUFRLENBQUMsRUFBRTtJQUMvRjtJQUNBLE9BQU8sQ0FBQyxHQUFHVCxjQUFjZSxPQUFPLEVBQUVaLFFBQVFVO0FBQzlDO0FBQ0FoQixjQUFjLEdBQUdFLFFBQ2pCLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BzZS0yL25leHRqcy8uL25vZGVfbW9kdWxlcy9ldGgtYmxvY2stdHJhY2tlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvYmFzZTY0LmpzP2JlYTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJhc2U2NCA9IHZvaWQgMDtcbmNvbnN0IHN1cGVyc3RydWN0XzEgPSByZXF1aXJlKFwic3VwZXJzdHJ1Y3RcIik7XG5jb25zdCBhc3NlcnRfMSA9IHJlcXVpcmUoXCIuL2Fzc2VydFwiKTtcbi8qKlxuICogRW5zdXJlIHRoYXQgYSBwcm92aWRlZCBzdHJpbmctYmFzZWQgc3RydWN0IGlzIHZhbGlkIGJhc2U2NC5cbiAqXG4gKiBAcGFyYW0gc3RydWN0IC0gVGhlIHN0cmluZyBiYXNlZCBzdHJ1Y3QuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsIG9wdGlvbnMgdG8gc3BlY2lhbGl6ZSBiYXNlNjQgdmFsaWRhdGlvbi4gU2VlIHtAbGluayBCYXNlNjRPcHRpb25zfSBkb2N1bWVudGF0aW9uLlxuICogQHJldHVybnMgQSBzdXBlcnN0cnVjdCB2YWxpZGF0aW5nIGJhc2U2NC5cbiAqL1xuY29uc3QgYmFzZTY0ID0gKHN0cnVjdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBwYWRkaW5nUmVxdWlyZWQgPSAoX2EgPSBvcHRpb25zLnBhZGRpbmdSZXF1aXJlZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2U7XG4gICAgY29uc3QgY2hhcmFjdGVyU2V0ID0gKF9iID0gb3B0aW9ucy5jaGFyYWN0ZXJTZXQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICdiYXNlNjQnO1xuICAgIGxldCBsZXR0ZXJzO1xuICAgIGlmIChjaGFyYWN0ZXJTZXQgPT09ICdiYXNlNjQnKSB7XG4gICAgICAgIGxldHRlcnMgPSBTdHJpbmcucmF3IGBbQS1aYS16MC05K1xcL11gO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgKDAsIGFzc2VydF8xLmFzc2VydCkoY2hhcmFjdGVyU2V0ID09PSAnYmFzZTY0dXJsJyk7XG4gICAgICAgIGxldHRlcnMgPSBTdHJpbmcucmF3IGBbLV9BLVphLXowLTldYDtcbiAgICB9XG4gICAgbGV0IHJlO1xuICAgIGlmIChwYWRkaW5nUmVxdWlyZWQpIHtcbiAgICAgICAgcmUgPSBuZXcgUmVnRXhwKGBeKD86JHtsZXR0ZXJzfXs0fSkqKD86JHtsZXR0ZXJzfXszfT18JHtsZXR0ZXJzfXsyfT09KT8kYCwgJ3UnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlID0gbmV3IFJlZ0V4cChgXig/OiR7bGV0dGVyc317NH0pKig/OiR7bGV0dGVyc317MiwzfXwke2xldHRlcnN9ezN9PXwke2xldHRlcnN9ezJ9PT0pPyRgLCAndScpO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEucGF0dGVybikoc3RydWN0LCByZSk7XG59O1xuZXhwb3J0cy5iYXNlNjQgPSBiYXNlNjQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlNjQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiYmFzZTY0Iiwic3VwZXJzdHJ1Y3RfMSIsInJlcXVpcmUiLCJhc3NlcnRfMSIsInN0cnVjdCIsIm9wdGlvbnMiLCJfYSIsIl9iIiwicGFkZGluZ1JlcXVpcmVkIiwiY2hhcmFjdGVyU2V0IiwibGV0dGVycyIsIlN0cmluZyIsInJhdyIsImFzc2VydCIsInJlIiwiUmVnRXhwIiwicGF0dGVybiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/base64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/bytes.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/bytes.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createDataView = exports.concatBytes = exports.valueToBytes = exports.stringToBytes = exports.numberToBytes = exports.signedBigIntToBytes = exports.bigIntToBytes = exports.hexToBytes = exports.bytesToString = exports.bytesToNumber = exports.bytesToSignedBigInt = exports.bytesToBigInt = exports.bytesToHex = exports.assertIsBytes = exports.isBytes = void 0;\nconst assert_1 = __webpack_require__(/*! ./assert */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/assert.js\");\nconst hex_1 = __webpack_require__(/*! ./hex */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/hex.js\");\n// '0'.charCodeAt(0) === 48\nconst HEX_MINIMUM_NUMBER_CHARACTER = 48;\n// '9'.charCodeAt(0) === 57\nconst HEX_MAXIMUM_NUMBER_CHARACTER = 58;\nconst HEX_CHARACTER_OFFSET = 87;\n/**\n * Memoized function that returns an array to be used as a lookup table for\n * converting bytes to hexadecimal values.\n *\n * The array is created lazily and then cached for future use. The benefit of\n * this approach is that the performance of converting bytes to hex is much\n * better than if we were to call `toString(16)` on each byte.\n *\n * The downside is that the array is created once and then never garbage\n * collected. This is not a problem in practice because the array is only 256\n * elements long.\n *\n * @returns A function that returns the lookup table.\n */ function getPrecomputedHexValuesBuilder() {\n    // To avoid issues with tree shaking, we need to use a function to return the\n    // array. This is because the array is only used in the `bytesToHex` function\n    // and if we were to use a global variable, the array might be removed by the\n    // tree shaker.\n    const lookupTable = [];\n    return ()=>{\n        if (lookupTable.length === 0) {\n            for(let i = 0; i < 256; i++){\n                lookupTable.push(i.toString(16).padStart(2, \"0\"));\n            }\n        }\n        return lookupTable;\n    };\n}\n/**\n * Function implementation of the {@link getPrecomputedHexValuesBuilder}\n * function.\n */ const getPrecomputedHexValues = getPrecomputedHexValuesBuilder();\n/**\n * Check if a value is a `Uint8Array`.\n *\n * @param value - The value to check.\n * @returns Whether the value is a `Uint8Array`.\n */ function isBytes(value) {\n    return value instanceof Uint8Array;\n}\nexports.isBytes = isBytes;\n/**\n * Assert that a value is a `Uint8Array`.\n *\n * @param value - The value to check.\n * @throws If the value is not a `Uint8Array`.\n */ function assertIsBytes(value) {\n    (0, assert_1.assert)(isBytes(value), \"Value must be a Uint8Array.\");\n}\nexports.assertIsBytes = assertIsBytes;\n/**\n * Convert a `Uint8Array` to a hexadecimal string.\n *\n * @param bytes - The bytes to convert to a hexadecimal string.\n * @returns The hexadecimal string.\n */ function bytesToHex(bytes) {\n    assertIsBytes(bytes);\n    if (bytes.length === 0) {\n        return \"0x\";\n    }\n    const lookupTable = getPrecomputedHexValues();\n    const hexadecimal = new Array(bytes.length);\n    for(let i = 0; i < bytes.length; i++){\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        hexadecimal[i] = lookupTable[bytes[i]];\n    }\n    return (0, hex_1.add0x)(hexadecimal.join(\"\"));\n}\nexports.bytesToHex = bytesToHex;\n/**\n * Convert a `Uint8Array` to a `bigint`.\n *\n * To convert a `Uint8Array` to a `number` instead, use {@link bytesToNumber}.\n * To convert a two's complement encoded `Uint8Array` to a `bigint`, use\n * {@link bytesToSignedBigInt}.\n *\n * @param bytes - The bytes to convert to a `bigint`.\n * @returns The `bigint`.\n */ function bytesToBigInt(bytes) {\n    assertIsBytes(bytes);\n    const hexadecimal = bytesToHex(bytes);\n    return BigInt(hexadecimal);\n}\nexports.bytesToBigInt = bytesToBigInt;\n/**\n * Convert a `Uint8Array` to a signed `bigint`. This assumes that the bytes are\n * encoded in two's complement.\n *\n * To convert a `Uint8Array` to an unsigned `bigint` instead, use\n * {@link bytesToBigInt}.\n *\n * @see https://en.wikipedia.org/wiki/Two%27s_complement\n * @param bytes - The bytes to convert to a signed `bigint`.\n * @returns The signed `bigint`.\n */ function bytesToSignedBigInt(bytes) {\n    assertIsBytes(bytes);\n    let value = BigInt(0);\n    for (const byte of bytes){\n        // eslint-disable-next-line no-bitwise\n        value = (value << BigInt(8)) + BigInt(byte);\n    }\n    return BigInt.asIntN(bytes.length * 8, value);\n}\nexports.bytesToSignedBigInt = bytesToSignedBigInt;\n/**\n * Convert a `Uint8Array` to a `number`.\n *\n * To convert a `Uint8Array` to a `bigint` instead, use {@link bytesToBigInt}.\n *\n * @param bytes - The bytes to convert to a number.\n * @returns The number.\n * @throws If the resulting number is not a safe integer.\n */ function bytesToNumber(bytes) {\n    assertIsBytes(bytes);\n    const bigint = bytesToBigInt(bytes);\n    (0, assert_1.assert)(bigint <= BigInt(Number.MAX_SAFE_INTEGER), \"Number is not a safe integer. Use `bytesToBigInt` instead.\");\n    return Number(bigint);\n}\nexports.bytesToNumber = bytesToNumber;\n/**\n * Convert a UTF-8 encoded `Uint8Array` to a `string`.\n *\n * @param bytes - The bytes to convert to a string.\n * @returns The string.\n */ function bytesToString(bytes) {\n    assertIsBytes(bytes);\n    return new TextDecoder().decode(bytes);\n}\nexports.bytesToString = bytesToString;\n/**\n * Convert a hexadecimal string to a `Uint8Array`. The string can optionally be\n * prefixed with `0x`. It accepts even and odd length strings.\n *\n * If the value is \"0x\", an empty `Uint8Array` is returned.\n *\n * @param value - The hexadecimal string to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */ function hexToBytes(value) {\n    var _a;\n    // \"0x\" is often used as empty byte array.\n    if (((_a = value === null || value === void 0 ? void 0 : value.toLowerCase) === null || _a === void 0 ? void 0 : _a.call(value)) === \"0x\") {\n        return new Uint8Array();\n    }\n    (0, hex_1.assertIsHexString)(value);\n    // Remove the `0x` prefix if it exists, and pad the string to have an even\n    // number of characters.\n    const strippedValue = (0, hex_1.remove0x)(value).toLowerCase();\n    const normalizedValue = strippedValue.length % 2 === 0 ? strippedValue : `0${strippedValue}`;\n    const bytes = new Uint8Array(normalizedValue.length / 2);\n    for(let i = 0; i < bytes.length; i++){\n        // While this is not the prettiest way to convert a hexadecimal string to a\n        // `Uint8Array`, it is a lot faster than using `parseInt` to convert each\n        // character.\n        const c1 = normalizedValue.charCodeAt(i * 2);\n        const c2 = normalizedValue.charCodeAt(i * 2 + 1);\n        const n1 = c1 - (c1 < HEX_MAXIMUM_NUMBER_CHARACTER ? HEX_MINIMUM_NUMBER_CHARACTER : HEX_CHARACTER_OFFSET);\n        const n2 = c2 - (c2 < HEX_MAXIMUM_NUMBER_CHARACTER ? HEX_MINIMUM_NUMBER_CHARACTER : HEX_CHARACTER_OFFSET);\n        bytes[i] = n1 * 16 + n2;\n    }\n    return bytes;\n}\nexports.hexToBytes = hexToBytes;\n/**\n * Convert a `bigint` to a `Uint8Array`.\n *\n * This assumes that the `bigint` is an unsigned integer. To convert a signed\n * `bigint` instead, use {@link signedBigIntToBytes}.\n *\n * @param value - The bigint to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */ function bigIntToBytes(value) {\n    (0, assert_1.assert)(typeof value === \"bigint\", \"Value must be a bigint.\");\n    (0, assert_1.assert)(value >= BigInt(0), \"Value must be a non-negative bigint.\");\n    const hexadecimal = value.toString(16);\n    return hexToBytes(hexadecimal);\n}\nexports.bigIntToBytes = bigIntToBytes;\n/**\n * Check if a `bigint` fits in a certain number of bytes.\n *\n * @param value - The `bigint` to check.\n * @param bytes - The number of bytes.\n * @returns Whether the `bigint` fits in the number of bytes.\n */ function bigIntFits(value, bytes) {\n    (0, assert_1.assert)(bytes > 0);\n    /* eslint-disable no-bitwise */ const mask = value >> BigInt(31);\n    return !((~value & mask) + (value & ~mask) >> BigInt(bytes * 8 + ~0));\n/* eslint-enable no-bitwise */ }\n/**\n * Convert a signed `bigint` to a `Uint8Array`. This uses two's complement\n * encoding to represent negative numbers.\n *\n * To convert an unsigned `bigint` to a `Uint8Array` instead, use\n * {@link bigIntToBytes}.\n *\n * @see https://en.wikipedia.org/wiki/Two%27s_complement\n * @param value - The number to convert to bytes.\n * @param byteLength - The length of the resulting `Uint8Array`. If the number\n * is larger than the maximum value that can be represented by the given length,\n * an error is thrown.\n * @returns The bytes as `Uint8Array`.\n */ function signedBigIntToBytes(value, byteLength) {\n    (0, assert_1.assert)(typeof value === \"bigint\", \"Value must be a bigint.\");\n    (0, assert_1.assert)(typeof byteLength === \"number\", \"Byte length must be a number.\");\n    (0, assert_1.assert)(byteLength > 0, \"Byte length must be greater than 0.\");\n    (0, assert_1.assert)(bigIntFits(value, byteLength), \"Byte length is too small to represent the given value.\");\n    // ESLint doesn't like mutating function parameters, so to avoid having to\n    // disable the rule, we create a new variable.\n    let numberValue = value;\n    const bytes = new Uint8Array(byteLength);\n    for(let i = 0; i < bytes.length; i++){\n        bytes[i] = Number(BigInt.asUintN(8, numberValue));\n        // eslint-disable-next-line no-bitwise\n        numberValue >>= BigInt(8);\n    }\n    return bytes.reverse();\n}\nexports.signedBigIntToBytes = signedBigIntToBytes;\n/**\n * Convert a `number` to a `Uint8Array`.\n *\n * @param value - The number to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n * @throws If the number is not a safe integer.\n */ function numberToBytes(value) {\n    (0, assert_1.assert)(typeof value === \"number\", \"Value must be a number.\");\n    (0, assert_1.assert)(value >= 0, \"Value must be a non-negative number.\");\n    (0, assert_1.assert)(Number.isSafeInteger(value), \"Value is not a safe integer. Use `bigIntToBytes` instead.\");\n    const hexadecimal = value.toString(16);\n    return hexToBytes(hexadecimal);\n}\nexports.numberToBytes = numberToBytes;\n/**\n * Convert a `string` to a UTF-8 encoded `Uint8Array`.\n *\n * @param value - The string to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */ function stringToBytes(value) {\n    (0, assert_1.assert)(typeof value === \"string\", \"Value must be a string.\");\n    return new TextEncoder().encode(value);\n}\nexports.stringToBytes = stringToBytes;\n/**\n * Convert a byte-like value to a `Uint8Array`. The value can be a `Uint8Array`,\n * a `bigint`, a `number`, or a `string`.\n *\n * This will attempt to guess the type of the value based on its type and\n * contents. For more control over the conversion, use the more specific\n * conversion functions, such as {@link hexToBytes} or {@link stringToBytes}.\n *\n * If the value is a `string`, and it is prefixed with `0x`, it will be\n * interpreted as a hexadecimal string. Otherwise, it will be interpreted as a\n * UTF-8 string. To convert a hexadecimal string to bytes without interpreting\n * it as a UTF-8 string, use {@link hexToBytes} instead.\n *\n * If the value is a `bigint`, it is assumed to be unsigned. To convert a signed\n * `bigint` to bytes, use {@link signedBigIntToBytes} instead.\n *\n * If the value is a `Uint8Array`, it will be returned as-is.\n *\n * @param value - The value to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */ function valueToBytes(value) {\n    if (typeof value === \"bigint\") {\n        return bigIntToBytes(value);\n    }\n    if (typeof value === \"number\") {\n        return numberToBytes(value);\n    }\n    if (typeof value === \"string\") {\n        if (value.startsWith(\"0x\")) {\n            return hexToBytes(value);\n        }\n        return stringToBytes(value);\n    }\n    if (isBytes(value)) {\n        return value;\n    }\n    throw new TypeError(`Unsupported value type: \"${typeof value}\".`);\n}\nexports.valueToBytes = valueToBytes;\n/**\n * Concatenate multiple byte-like values into a single `Uint8Array`. The values\n * can be `Uint8Array`, `bigint`, `number`, or `string`. This uses\n * {@link valueToBytes} under the hood to convert each value to bytes. Refer to\n * the documentation of that function for more information.\n *\n * @param values - The values to concatenate.\n * @returns The concatenated bytes as `Uint8Array`.\n */ function concatBytes(values) {\n    const normalizedValues = new Array(values.length);\n    let byteLength = 0;\n    for(let i = 0; i < values.length; i++){\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const value = valueToBytes(values[i]);\n        normalizedValues[i] = value;\n        byteLength += value.length;\n    }\n    const bytes = new Uint8Array(byteLength);\n    for(let i = 0, offset = 0; i < normalizedValues.length; i++){\n        // While we could simply spread the values into an array and use\n        // `Uint8Array.from`, that is a lot slower than using `Uint8Array.set`.\n        bytes.set(normalizedValues[i], offset);\n        offset += normalizedValues[i].length;\n    }\n    return bytes;\n}\nexports.concatBytes = concatBytes;\n/**\n * Create a {@link DataView} from a {@link Uint8Array}. This is a convenience\n * function that avoids having to create a {@link DataView} manually, which\n * requires passing the `byteOffset` and `byteLength` parameters every time.\n *\n * Not passing the `byteOffset` and `byteLength` parameters can result in\n * unexpected behavior when the {@link Uint8Array} is a view of a larger\n * {@link ArrayBuffer}, e.g., when using {@link Uint8Array.subarray}.\n *\n * This function also supports Node.js {@link Buffer}s.\n *\n * @example\n * ```typescript\n * const bytes = new Uint8Array([1, 2, 3]);\n *\n * // This is equivalent to:\n * // const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n * const dataView = createDataView(bytes);\n * ```\n * @param bytes - The bytes to create the {@link DataView} from.\n * @returns The {@link DataView}.\n */ function createDataView(bytes) {\n    // To maintain compatibility with Node.js, we need to check if the bytes are\n    // a Buffer. If so, we need to slice the buffer to get the underlying\n    // ArrayBuffer.\n    // eslint-disable-next-line no-restricted-globals\n    if (typeof Buffer !== \"undefined\" && bytes instanceof Buffer) {\n        const buffer = bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength);\n        return new DataView(buffer);\n    }\n    return new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n}\nexports.createDataView = createDataView; //# sourceMappingURL=bytes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2J5dGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxzQkFBc0IsR0FBR0EsbUJBQW1CLEdBQUdBLG9CQUFvQixHQUFHQSxxQkFBcUIsR0FBR0EscUJBQXFCLEdBQUdBLDJCQUEyQixHQUFHQSxxQkFBcUIsR0FBR0Esa0JBQWtCLEdBQUdBLHFCQUFxQixHQUFHQSxxQkFBcUIsR0FBR0EsMkJBQTJCLEdBQUdBLHFCQUFxQixHQUFHQSxrQkFBa0IsR0FBR0EscUJBQXFCLEdBQUdBLGVBQWUsR0FBRyxLQUFLO0FBQzNXLE1BQU1pQixXQUFXQyxtQkFBT0EsQ0FBQyxvR0FBVTtBQUNuQyxNQUFNQyxRQUFRRCxtQkFBT0EsQ0FBQyw4RkFBTztBQUM3QiwyQkFBMkI7QUFDM0IsTUFBTUUsK0JBQStCO0FBQ3JDLDJCQUEyQjtBQUMzQixNQUFNQywrQkFBK0I7QUFDckMsTUFBTUMsdUJBQXVCO0FBQzdCOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDRCxTQUFTQztJQUNMLDZFQUE2RTtJQUM3RSw2RUFBNkU7SUFDN0UsNkVBQTZFO0lBQzdFLGVBQWU7SUFDZixNQUFNQyxjQUFjLEVBQUU7SUFDdEIsT0FBTztRQUNILElBQUlBLFlBQVlDLE1BQU0sS0FBSyxHQUFHO1lBQzFCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJLEtBQUtBLElBQUs7Z0JBQzFCRixZQUFZRyxJQUFJLENBQUNELEVBQUVFLFFBQVEsQ0FBQyxJQUFJQyxRQUFRLENBQUMsR0FBRztZQUNoRDtRQUNKO1FBQ0EsT0FBT0w7SUFDWDtBQUNKO0FBQ0E7OztDQUdDLEdBQ0QsTUFBTU0sMEJBQTBCUDtBQUNoQzs7Ozs7Q0FLQyxHQUNELFNBQVNQLFFBQVFmLEtBQUs7SUFDbEIsT0FBT0EsaUJBQWlCOEI7QUFDNUI7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QUFJLE9BQU93QyxXQUFXLGVBQWV4QyxpQkFBaUJ3QyxRQUFRO1FBQzFELE1BQU1DLFNBQVN6QyxNQUFNeUMsTUFBTSxDQUFDQyxLQUFLLENBQUMxQyxNQUFNMkMsVUFBVSxFQUFFM0MsTUFBTTJDLFVBQVUsR0FBRzNDLE1BQU0yQixVQUFVO1FBQ3ZGLE9BQU8sSUFBSWlCLFNBQVNIO0lBQ3hCO0lBQ0EsT0FBTyxJQUFJRyxTQUFTNUMsTUFBTXlDLE1BQU0sRUFBRXpDLE1BQU0yQyxVQUFVLEVBQUUzQyxNQUFNMkIsVUFBVTtBQUN4RTtBQUNBNUQsc0JBQXNCLEdBQUdFLGdCQUN6QixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac2UtMi9uZXh0anMvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2J5dGVzLmpzP2QwOGMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZURhdGFWaWV3ID0gZXhwb3J0cy5jb25jYXRCeXRlcyA9IGV4cG9ydHMudmFsdWVUb0J5dGVzID0gZXhwb3J0cy5zdHJpbmdUb0J5dGVzID0gZXhwb3J0cy5udW1iZXJUb0J5dGVzID0gZXhwb3J0cy5zaWduZWRCaWdJbnRUb0J5dGVzID0gZXhwb3J0cy5iaWdJbnRUb0J5dGVzID0gZXhwb3J0cy5oZXhUb0J5dGVzID0gZXhwb3J0cy5ieXRlc1RvU3RyaW5nID0gZXhwb3J0cy5ieXRlc1RvTnVtYmVyID0gZXhwb3J0cy5ieXRlc1RvU2lnbmVkQmlnSW50ID0gZXhwb3J0cy5ieXRlc1RvQmlnSW50ID0gZXhwb3J0cy5ieXRlc1RvSGV4ID0gZXhwb3J0cy5hc3NlcnRJc0J5dGVzID0gZXhwb3J0cy5pc0J5dGVzID0gdm9pZCAwO1xuY29uc3QgYXNzZXJ0XzEgPSByZXF1aXJlKFwiLi9hc3NlcnRcIik7XG5jb25zdCBoZXhfMSA9IHJlcXVpcmUoXCIuL2hleFwiKTtcbi8vICcwJy5jaGFyQ29kZUF0KDApID09PSA0OFxuY29uc3QgSEVYX01JTklNVU1fTlVNQkVSX0NIQVJBQ1RFUiA9IDQ4O1xuLy8gJzknLmNoYXJDb2RlQXQoMCkgPT09IDU3XG5jb25zdCBIRVhfTUFYSU1VTV9OVU1CRVJfQ0hBUkFDVEVSID0gNTg7XG5jb25zdCBIRVhfQ0hBUkFDVEVSX09GRlNFVCA9IDg3O1xuLyoqXG4gKiBNZW1vaXplZCBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gYXJyYXkgdG8gYmUgdXNlZCBhcyBhIGxvb2t1cCB0YWJsZSBmb3JcbiAqIGNvbnZlcnRpbmcgYnl0ZXMgdG8gaGV4YWRlY2ltYWwgdmFsdWVzLlxuICpcbiAqIFRoZSBhcnJheSBpcyBjcmVhdGVkIGxhemlseSBhbmQgdGhlbiBjYWNoZWQgZm9yIGZ1dHVyZSB1c2UuIFRoZSBiZW5lZml0IG9mXG4gKiB0aGlzIGFwcHJvYWNoIGlzIHRoYXQgdGhlIHBlcmZvcm1hbmNlIG9mIGNvbnZlcnRpbmcgYnl0ZXMgdG8gaGV4IGlzIG11Y2hcbiAqIGJldHRlciB0aGFuIGlmIHdlIHdlcmUgdG8gY2FsbCBgdG9TdHJpbmcoMTYpYCBvbiBlYWNoIGJ5dGUuXG4gKlxuICogVGhlIGRvd25zaWRlIGlzIHRoYXQgdGhlIGFycmF5IGlzIGNyZWF0ZWQgb25jZSBhbmQgdGhlbiBuZXZlciBnYXJiYWdlXG4gKiBjb2xsZWN0ZWQuIFRoaXMgaXMgbm90IGEgcHJvYmxlbSBpbiBwcmFjdGljZSBiZWNhdXNlIHRoZSBhcnJheSBpcyBvbmx5IDI1NlxuICogZWxlbWVudHMgbG9uZy5cbiAqXG4gKiBAcmV0dXJucyBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbG9va3VwIHRhYmxlLlxuICovXG5mdW5jdGlvbiBnZXRQcmVjb21wdXRlZEhleFZhbHVlc0J1aWxkZXIoKSB7XG4gICAgLy8gVG8gYXZvaWQgaXNzdWVzIHdpdGggdHJlZSBzaGFraW5nLCB3ZSBuZWVkIHRvIHVzZSBhIGZ1bmN0aW9uIHRvIHJldHVybiB0aGVcbiAgICAvLyBhcnJheS4gVGhpcyBpcyBiZWNhdXNlIHRoZSBhcnJheSBpcyBvbmx5IHVzZWQgaW4gdGhlIGBieXRlc1RvSGV4YCBmdW5jdGlvblxuICAgIC8vIGFuZCBpZiB3ZSB3ZXJlIHRvIHVzZSBhIGdsb2JhbCB2YXJpYWJsZSwgdGhlIGFycmF5IG1pZ2h0IGJlIHJlbW92ZWQgYnkgdGhlXG4gICAgLy8gdHJlZSBzaGFrZXIuXG4gICAgY29uc3QgbG9va3VwVGFibGUgPSBbXTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAobG9va3VwVGFibGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbG9va3VwVGFibGUucHVzaChpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9va3VwVGFibGU7XG4gICAgfTtcbn1cbi8qKlxuICogRnVuY3Rpb24gaW1wbGVtZW50YXRpb24gb2YgdGhlIHtAbGluayBnZXRQcmVjb21wdXRlZEhleFZhbHVlc0J1aWxkZXJ9XG4gKiBmdW5jdGlvbi5cbiAqL1xuY29uc3QgZ2V0UHJlY29tcHV0ZWRIZXhWYWx1ZXMgPSBnZXRQcmVjb21wdXRlZEhleFZhbHVlc0J1aWxkZXIoKTtcbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIGBVaW50OEFycmF5YC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIGBVaW50OEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gaXNCeXRlcyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG59XG5leHBvcnRzLmlzQnl0ZXMgPSBpc0J5dGVzO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCBhIHZhbHVlIGlzIGEgYFVpbnQ4QXJyYXlgLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEB0aHJvd3MgSWYgdGhlIHZhbHVlIGlzIG5vdCBhIGBVaW50OEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNCeXRlcyh2YWx1ZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKGlzQnl0ZXModmFsdWUpLCAnVmFsdWUgbXVzdCBiZSBhIFVpbnQ4QXJyYXkuJyk7XG59XG5leHBvcnRzLmFzc2VydElzQnl0ZXMgPSBhc3NlcnRJc0J5dGVzO1xuLyoqXG4gKiBDb252ZXJ0IGEgYFVpbnQ4QXJyYXlgIHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBieXRlcyB0byBjb252ZXJ0IHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGFzc2VydElzQnl0ZXMoYnl0ZXMpO1xuICAgIGlmIChieXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuICcweCc7XG4gICAgfVxuICAgIGNvbnN0IGxvb2t1cFRhYmxlID0gZ2V0UHJlY29tcHV0ZWRIZXhWYWx1ZXMoKTtcbiAgICBjb25zdCBoZXhhZGVjaW1hbCA9IG5ldyBBcnJheShieXRlcy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgaGV4YWRlY2ltYWxbaV0gPSBsb29rdXBUYWJsZVtieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiAoMCwgaGV4XzEuYWRkMHgpKGhleGFkZWNpbWFsLmpvaW4oJycpKTtcbn1cbmV4cG9ydHMuYnl0ZXNUb0hleCA9IGJ5dGVzVG9IZXg7XG4vKipcbiAqIENvbnZlcnQgYSBgVWludDhBcnJheWAgdG8gYSBgYmlnaW50YC5cbiAqXG4gKiBUbyBjb252ZXJ0IGEgYFVpbnQ4QXJyYXlgIHRvIGEgYG51bWJlcmAgaW5zdGVhZCwgdXNlIHtAbGluayBieXRlc1RvTnVtYmVyfS5cbiAqIFRvIGNvbnZlcnQgYSB0d28ncyBjb21wbGVtZW50IGVuY29kZWQgYFVpbnQ4QXJyYXlgIHRvIGEgYGJpZ2ludGAsIHVzZVxuICoge0BsaW5rIGJ5dGVzVG9TaWduZWRCaWdJbnR9LlxuICpcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBieXRlcyB0byBjb252ZXJ0IHRvIGEgYGJpZ2ludGAuXG4gKiBAcmV0dXJucyBUaGUgYGJpZ2ludGAuXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9CaWdJbnQoYnl0ZXMpIHtcbiAgICBhc3NlcnRJc0J5dGVzKGJ5dGVzKTtcbiAgICBjb25zdCBoZXhhZGVjaW1hbCA9IGJ5dGVzVG9IZXgoYnl0ZXMpO1xuICAgIHJldHVybiBCaWdJbnQoaGV4YWRlY2ltYWwpO1xufVxuZXhwb3J0cy5ieXRlc1RvQmlnSW50ID0gYnl0ZXNUb0JpZ0ludDtcbi8qKlxuICogQ29udmVydCBhIGBVaW50OEFycmF5YCB0byBhIHNpZ25lZCBgYmlnaW50YC4gVGhpcyBhc3N1bWVzIHRoYXQgdGhlIGJ5dGVzIGFyZVxuICogZW5jb2RlZCBpbiB0d28ncyBjb21wbGVtZW50LlxuICpcbiAqIFRvIGNvbnZlcnQgYSBgVWludDhBcnJheWAgdG8gYW4gdW5zaWduZWQgYGJpZ2ludGAgaW5zdGVhZCwgdXNlXG4gKiB7QGxpbmsgYnl0ZXNUb0JpZ0ludH0uXG4gKlxuICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ud28lMjdzX2NvbXBsZW1lbnRcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBieXRlcyB0byBjb252ZXJ0IHRvIGEgc2lnbmVkIGBiaWdpbnRgLlxuICogQHJldHVybnMgVGhlIHNpZ25lZCBgYmlnaW50YC5cbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb1NpZ25lZEJpZ0ludChieXRlcykge1xuICAgIGFzc2VydElzQnl0ZXMoYnl0ZXMpO1xuICAgIGxldCB2YWx1ZSA9IEJpZ0ludCgwKTtcbiAgICBmb3IgKGNvbnN0IGJ5dGUgb2YgYnl0ZXMpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgPDwgQmlnSW50KDgpKSArIEJpZ0ludChieXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIEJpZ0ludC5hc0ludE4oYnl0ZXMubGVuZ3RoICogOCwgdmFsdWUpO1xufVxuZXhwb3J0cy5ieXRlc1RvU2lnbmVkQmlnSW50ID0gYnl0ZXNUb1NpZ25lZEJpZ0ludDtcbi8qKlxuICogQ29udmVydCBhIGBVaW50OEFycmF5YCB0byBhIGBudW1iZXJgLlxuICpcbiAqIFRvIGNvbnZlcnQgYSBgVWludDhBcnJheWAgdG8gYSBgYmlnaW50YCBpbnN0ZWFkLCB1c2Uge0BsaW5rIGJ5dGVzVG9CaWdJbnR9LlxuICpcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBieXRlcyB0byBjb252ZXJ0IHRvIGEgbnVtYmVyLlxuICogQHJldHVybnMgVGhlIG51bWJlci5cbiAqIEB0aHJvd3MgSWYgdGhlIHJlc3VsdGluZyBudW1iZXIgaXMgbm90IGEgc2FmZSBpbnRlZ2VyLlxuICovXG5mdW5jdGlvbiBieXRlc1RvTnVtYmVyKGJ5dGVzKSB7XG4gICAgYXNzZXJ0SXNCeXRlcyhieXRlcyk7XG4gICAgY29uc3QgYmlnaW50ID0gYnl0ZXNUb0JpZ0ludChieXRlcyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoYmlnaW50IDw9IEJpZ0ludChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiksICdOdW1iZXIgaXMgbm90IGEgc2FmZSBpbnRlZ2VyLiBVc2UgYGJ5dGVzVG9CaWdJbnRgIGluc3RlYWQuJyk7XG4gICAgcmV0dXJuIE51bWJlcihiaWdpbnQpO1xufVxuZXhwb3J0cy5ieXRlc1RvTnVtYmVyID0gYnl0ZXNUb051bWJlcjtcbi8qKlxuICogQ29udmVydCBhIFVURi04IGVuY29kZWQgYFVpbnQ4QXJyYXlgIHRvIGEgYHN0cmluZ2AuXG4gKlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGVzIHRvIGNvbnZlcnQgdG8gYSBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBieXRlc1RvU3RyaW5nKGJ5dGVzKSB7XG4gICAgYXNzZXJ0SXNCeXRlcyhieXRlcyk7XG4gICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShieXRlcyk7XG59XG5leHBvcnRzLmJ5dGVzVG9TdHJpbmcgPSBieXRlc1RvU3RyaW5nO1xuLyoqXG4gKiBDb252ZXJ0IGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGEgYFVpbnQ4QXJyYXlgLiBUaGUgc3RyaW5nIGNhbiBvcHRpb25hbGx5IGJlXG4gKiBwcmVmaXhlZCB3aXRoIGAweGAuIEl0IGFjY2VwdHMgZXZlbiBhbmQgb2RkIGxlbmd0aCBzdHJpbmdzLlxuICpcbiAqIElmIHRoZSB2YWx1ZSBpcyBcIjB4XCIsIGFuIGVtcHR5IGBVaW50OEFycmF5YCBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKiBAcmV0dXJucyBUaGUgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBoZXhUb0J5dGVzKHZhbHVlKSB7XG4gICAgdmFyIF9hO1xuICAgIC8vIFwiMHhcIiBpcyBvZnRlbiB1c2VkIGFzIGVtcHR5IGJ5dGUgYXJyYXkuXG4gICAgaWYgKCgoX2EgPSB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWUudG9Mb3dlckNhc2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHZhbHVlKSkgPT09ICcweCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KCk7XG4gICAgfVxuICAgICgwLCBoZXhfMS5hc3NlcnRJc0hleFN0cmluZykodmFsdWUpO1xuICAgIC8vIFJlbW92ZSB0aGUgYDB4YCBwcmVmaXggaWYgaXQgZXhpc3RzLCBhbmQgcGFkIHRoZSBzdHJpbmcgdG8gaGF2ZSBhbiBldmVuXG4gICAgLy8gbnVtYmVyIG9mIGNoYXJhY3RlcnMuXG4gICAgY29uc3Qgc3RyaXBwZWRWYWx1ZSA9ICgwLCBoZXhfMS5yZW1vdmUweCkodmFsdWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3Qgbm9ybWFsaXplZFZhbHVlID0gc3RyaXBwZWRWYWx1ZS5sZW5ndGggJSAyID09PSAwID8gc3RyaXBwZWRWYWx1ZSA6IGAwJHtzdHJpcHBlZFZhbHVlfWA7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShub3JtYWxpemVkVmFsdWUubGVuZ3RoIC8gMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBXaGlsZSB0aGlzIGlzIG5vdCB0aGUgcHJldHRpZXN0IHdheSB0byBjb252ZXJ0IGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGFcbiAgICAgICAgLy8gYFVpbnQ4QXJyYXlgLCBpdCBpcyBhIGxvdCBmYXN0ZXIgdGhhbiB1c2luZyBgcGFyc2VJbnRgIHRvIGNvbnZlcnQgZWFjaFxuICAgICAgICAvLyBjaGFyYWN0ZXIuXG4gICAgICAgIGNvbnN0IGMxID0gbm9ybWFsaXplZFZhbHVlLmNoYXJDb2RlQXQoaSAqIDIpO1xuICAgICAgICBjb25zdCBjMiA9IG5vcm1hbGl6ZWRWYWx1ZS5jaGFyQ29kZUF0KGkgKiAyICsgMSk7XG4gICAgICAgIGNvbnN0IG4xID0gYzEgLVxuICAgICAgICAgICAgKGMxIDwgSEVYX01BWElNVU1fTlVNQkVSX0NIQVJBQ1RFUlxuICAgICAgICAgICAgICAgID8gSEVYX01JTklNVU1fTlVNQkVSX0NIQVJBQ1RFUlxuICAgICAgICAgICAgICAgIDogSEVYX0NIQVJBQ1RFUl9PRkZTRVQpO1xuICAgICAgICBjb25zdCBuMiA9IGMyIC1cbiAgICAgICAgICAgIChjMiA8IEhFWF9NQVhJTVVNX05VTUJFUl9DSEFSQUNURVJcbiAgICAgICAgICAgICAgICA/IEhFWF9NSU5JTVVNX05VTUJFUl9DSEFSQUNURVJcbiAgICAgICAgICAgICAgICA6IEhFWF9DSEFSQUNURVJfT0ZGU0VUKTtcbiAgICAgICAgYnl0ZXNbaV0gPSBuMSAqIDE2ICsgbjI7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn1cbmV4cG9ydHMuaGV4VG9CeXRlcyA9IGhleFRvQnl0ZXM7XG4vKipcbiAqIENvbnZlcnQgYSBgYmlnaW50YCB0byBhIGBVaW50OEFycmF5YC5cbiAqXG4gKiBUaGlzIGFzc3VtZXMgdGhhdCB0aGUgYGJpZ2ludGAgaXMgYW4gdW5zaWduZWQgaW50ZWdlci4gVG8gY29udmVydCBhIHNpZ25lZFxuICogYGJpZ2ludGAgaW5zdGVhZCwgdXNlIHtAbGluayBzaWduZWRCaWdJbnRUb0J5dGVzfS5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgYmlnaW50IHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKiBAcmV0dXJucyBUaGUgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBiaWdJbnRUb0J5dGVzKHZhbHVlKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIHZhbHVlID09PSAnYmlnaW50JywgJ1ZhbHVlIG11c3QgYmUgYSBiaWdpbnQuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodmFsdWUgPj0gQmlnSW50KDApLCAnVmFsdWUgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBiaWdpbnQuJyk7XG4gICAgY29uc3QgaGV4YWRlY2ltYWwgPSB2YWx1ZS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMoaGV4YWRlY2ltYWwpO1xufVxuZXhwb3J0cy5iaWdJbnRUb0J5dGVzID0gYmlnSW50VG9CeXRlcztcbi8qKlxuICogQ2hlY2sgaWYgYSBgYmlnaW50YCBmaXRzIGluIGEgY2VydGFpbiBudW1iZXIgb2YgYnl0ZXMuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGBiaWdpbnRgIHRvIGNoZWNrLlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIG51bWJlciBvZiBieXRlcy5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGBiaWdpbnRgIGZpdHMgaW4gdGhlIG51bWJlciBvZiBieXRlcy5cbiAqL1xuZnVuY3Rpb24gYmlnSW50Rml0cyh2YWx1ZSwgYnl0ZXMpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShieXRlcyA+IDApO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cbiAgICBjb25zdCBtYXNrID0gdmFsdWUgPj4gQmlnSW50KDMxKTtcbiAgICByZXR1cm4gISgoKH52YWx1ZSAmIG1hc2spICsgKHZhbHVlICYgfm1hc2spKSA+PiBCaWdJbnQoYnl0ZXMgKiA4ICsgfjApKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWJpdHdpc2UgKi9cbn1cbi8qKlxuICogQ29udmVydCBhIHNpZ25lZCBgYmlnaW50YCB0byBhIGBVaW50OEFycmF5YC4gVGhpcyB1c2VzIHR3bydzIGNvbXBsZW1lbnRcbiAqIGVuY29kaW5nIHRvIHJlcHJlc2VudCBuZWdhdGl2ZSBudW1iZXJzLlxuICpcbiAqIFRvIGNvbnZlcnQgYW4gdW5zaWduZWQgYGJpZ2ludGAgdG8gYSBgVWludDhBcnJheWAgaW5zdGVhZCwgdXNlXG4gKiB7QGxpbmsgYmlnSW50VG9CeXRlc30uXG4gKlxuICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ud28lMjdzX2NvbXBsZW1lbnRcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBudW1iZXIgdG8gY29udmVydCB0byBieXRlcy5cbiAqIEBwYXJhbSBieXRlTGVuZ3RoIC0gVGhlIGxlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIGBVaW50OEFycmF5YC4gSWYgdGhlIG51bWJlclxuICogaXMgbGFyZ2VyIHRoYW4gdGhlIG1heGltdW0gdmFsdWUgdGhhdCBjYW4gYmUgcmVwcmVzZW50ZWQgYnkgdGhlIGdpdmVuIGxlbmd0aCxcbiAqIGFuIGVycm9yIGlzIHRocm93bi5cbiAqIEByZXR1cm5zIFRoZSBieXRlcyBhcyBgVWludDhBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIHNpZ25lZEJpZ0ludFRvQnl0ZXModmFsdWUsIGJ5dGVMZW5ndGgpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnLCAnVmFsdWUgbXVzdCBiZSBhIGJpZ2ludC4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh0eXBlb2YgYnl0ZUxlbmd0aCA9PT0gJ251bWJlcicsICdCeXRlIGxlbmd0aCBtdXN0IGJlIGEgbnVtYmVyLicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKGJ5dGVMZW5ndGggPiAwLCAnQnl0ZSBsZW5ndGggbXVzdCBiZSBncmVhdGVyIHRoYW4gMC4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShiaWdJbnRGaXRzKHZhbHVlLCBieXRlTGVuZ3RoKSwgJ0J5dGUgbGVuZ3RoIGlzIHRvbyBzbWFsbCB0byByZXByZXNlbnQgdGhlIGdpdmVuIHZhbHVlLicpO1xuICAgIC8vIEVTTGludCBkb2Vzbid0IGxpa2UgbXV0YXRpbmcgZnVuY3Rpb24gcGFyYW1ldGVycywgc28gdG8gYXZvaWQgaGF2aW5nIHRvXG4gICAgLy8gZGlzYWJsZSB0aGUgcnVsZSwgd2UgY3JlYXRlIGEgbmV3IHZhcmlhYmxlLlxuICAgIGxldCBudW1iZXJWYWx1ZSA9IHZhbHVlO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZUxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBieXRlc1tpXSA9IE51bWJlcihCaWdJbnQuYXNVaW50Tig4LCBudW1iZXJWYWx1ZSkpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICBudW1iZXJWYWx1ZSA+Pj0gQmlnSW50KDgpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXMucmV2ZXJzZSgpO1xufVxuZXhwb3J0cy5zaWduZWRCaWdJbnRUb0J5dGVzID0gc2lnbmVkQmlnSW50VG9CeXRlcztcbi8qKlxuICogQ29udmVydCBhIGBudW1iZXJgIHRvIGEgYFVpbnQ4QXJyYXlgLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBudW1iZXIgdG8gY29udmVydCB0byBieXRlcy5cbiAqIEByZXR1cm5zIFRoZSBieXRlcyBhcyBgVWludDhBcnJheWAuXG4gKiBAdGhyb3dzIElmIHRoZSBudW1iZXIgaXMgbm90IGEgc2FmZSBpbnRlZ2VyLlxuICovXG5mdW5jdGlvbiBudW1iZXJUb0J5dGVzKHZhbHVlKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ1ZhbHVlIG11c3QgYmUgYSBudW1iZXIuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodmFsdWUgPj0gMCwgJ1ZhbHVlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbHVlKSwgJ1ZhbHVlIGlzIG5vdCBhIHNhZmUgaW50ZWdlci4gVXNlIGBiaWdJbnRUb0J5dGVzYCBpbnN0ZWFkLicpO1xuICAgIGNvbnN0IGhleGFkZWNpbWFsID0gdmFsdWUudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBoZXhUb0J5dGVzKGhleGFkZWNpbWFsKTtcbn1cbmV4cG9ydHMubnVtYmVyVG9CeXRlcyA9IG51bWJlclRvQnl0ZXM7XG4vKipcbiAqIENvbnZlcnQgYSBgc3RyaW5nYCB0byBhIFVURi04IGVuY29kZWQgYFVpbnQ4QXJyYXlgLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBzdHJpbmcgdG8gY29udmVydCB0byBieXRlcy5cbiAqIEByZXR1cm5zIFRoZSBieXRlcyBhcyBgVWludDhBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvQnl0ZXModmFsdWUpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnLCAnVmFsdWUgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgICByZXR1cm4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHZhbHVlKTtcbn1cbmV4cG9ydHMuc3RyaW5nVG9CeXRlcyA9IHN0cmluZ1RvQnl0ZXM7XG4vKipcbiAqIENvbnZlcnQgYSBieXRlLWxpa2UgdmFsdWUgdG8gYSBgVWludDhBcnJheWAuIFRoZSB2YWx1ZSBjYW4gYmUgYSBgVWludDhBcnJheWAsXG4gKiBhIGBiaWdpbnRgLCBhIGBudW1iZXJgLCBvciBhIGBzdHJpbmdgLlxuICpcbiAqIFRoaXMgd2lsbCBhdHRlbXB0IHRvIGd1ZXNzIHRoZSB0eXBlIG9mIHRoZSB2YWx1ZSBiYXNlZCBvbiBpdHMgdHlwZSBhbmRcbiAqIGNvbnRlbnRzLiBGb3IgbW9yZSBjb250cm9sIG92ZXIgdGhlIGNvbnZlcnNpb24sIHVzZSB0aGUgbW9yZSBzcGVjaWZpY1xuICogY29udmVyc2lvbiBmdW5jdGlvbnMsIHN1Y2ggYXMge0BsaW5rIGhleFRvQnl0ZXN9IG9yIHtAbGluayBzdHJpbmdUb0J5dGVzfS5cbiAqXG4gKiBJZiB0aGUgdmFsdWUgaXMgYSBgc3RyaW5nYCwgYW5kIGl0IGlzIHByZWZpeGVkIHdpdGggYDB4YCwgaXQgd2lsbCBiZVxuICogaW50ZXJwcmV0ZWQgYXMgYSBoZXhhZGVjaW1hbCBzdHJpbmcuIE90aGVyd2lzZSwgaXQgd2lsbCBiZSBpbnRlcnByZXRlZCBhcyBhXG4gKiBVVEYtOCBzdHJpbmcuIFRvIGNvbnZlcnQgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYnl0ZXMgd2l0aG91dCBpbnRlcnByZXRpbmdcbiAqIGl0IGFzIGEgVVRGLTggc3RyaW5nLCB1c2Uge0BsaW5rIGhleFRvQnl0ZXN9IGluc3RlYWQuXG4gKlxuICogSWYgdGhlIHZhbHVlIGlzIGEgYGJpZ2ludGAsIGl0IGlzIGFzc3VtZWQgdG8gYmUgdW5zaWduZWQuIFRvIGNvbnZlcnQgYSBzaWduZWRcbiAqIGBiaWdpbnRgIHRvIGJ5dGVzLCB1c2Uge0BsaW5rIHNpZ25lZEJpZ0ludFRvQnl0ZXN9IGluc3RlYWQuXG4gKlxuICogSWYgdGhlIHZhbHVlIGlzIGEgYFVpbnQ4QXJyYXlgLCBpdCB3aWxsIGJlIHJldHVybmVkIGFzLWlzLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGJ5dGVzLlxuICogQHJldHVybnMgVGhlIGJ5dGVzIGFzIGBVaW50OEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gdmFsdWVUb0J5dGVzKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgcmV0dXJuIGJpZ0ludFRvQnl0ZXModmFsdWUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gbnVtYmVyVG9CeXRlcyh2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKCcweCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gaGV4VG9CeXRlcyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ1RvQnl0ZXModmFsdWUpO1xuICAgIH1cbiAgICBpZiAoaXNCeXRlcyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVbnN1cHBvcnRlZCB2YWx1ZSB0eXBlOiBcIiR7dHlwZW9mIHZhbHVlfVwiLmApO1xufVxuZXhwb3J0cy52YWx1ZVRvQnl0ZXMgPSB2YWx1ZVRvQnl0ZXM7XG4vKipcbiAqIENvbmNhdGVuYXRlIG11bHRpcGxlIGJ5dGUtbGlrZSB2YWx1ZXMgaW50byBhIHNpbmdsZSBgVWludDhBcnJheWAuIFRoZSB2YWx1ZXNcbiAqIGNhbiBiZSBgVWludDhBcnJheWAsIGBiaWdpbnRgLCBgbnVtYmVyYCwgb3IgYHN0cmluZ2AuIFRoaXMgdXNlc1xuICoge0BsaW5rIHZhbHVlVG9CeXRlc30gdW5kZXIgdGhlIGhvb2QgdG8gY29udmVydCBlYWNoIHZhbHVlIHRvIGJ5dGVzLiBSZWZlciB0b1xuICogdGhlIGRvY3VtZW50YXRpb24gb2YgdGhhdCBmdW5jdGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyB0byBjb25jYXRlbmF0ZS5cbiAqIEByZXR1cm5zIFRoZSBjb25jYXRlbmF0ZWQgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb25jYXRCeXRlcyh2YWx1ZXMpIHtcbiAgICBjb25zdCBub3JtYWxpemVkVmFsdWVzID0gbmV3IEFycmF5KHZhbHVlcy5sZW5ndGgpO1xuICAgIGxldCBieXRlTGVuZ3RoID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlVG9CeXRlcyh2YWx1ZXNbaV0pO1xuICAgICAgICBub3JtYWxpemVkVmFsdWVzW2ldID0gdmFsdWU7XG4gICAgICAgIGJ5dGVMZW5ndGggKz0gdmFsdWUubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ5dGVMZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBvZmZzZXQgPSAwOyBpIDwgbm9ybWFsaXplZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBXaGlsZSB3ZSBjb3VsZCBzaW1wbHkgc3ByZWFkIHRoZSB2YWx1ZXMgaW50byBhbiBhcnJheSBhbmQgdXNlXG4gICAgICAgIC8vIGBVaW50OEFycmF5LmZyb21gLCB0aGF0IGlzIGEgbG90IHNsb3dlciB0aGFuIHVzaW5nIGBVaW50OEFycmF5LnNldGAuXG4gICAgICAgIGJ5dGVzLnNldChub3JtYWxpemVkVmFsdWVzW2ldLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gbm9ybWFsaXplZFZhbHVlc1tpXS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn1cbmV4cG9ydHMuY29uY2F0Qnl0ZXMgPSBjb25jYXRCeXRlcztcbi8qKlxuICogQ3JlYXRlIGEge0BsaW5rIERhdGFWaWV3fSBmcm9tIGEge0BsaW5rIFVpbnQ4QXJyYXl9LiBUaGlzIGlzIGEgY29udmVuaWVuY2VcbiAqIGZ1bmN0aW9uIHRoYXQgYXZvaWRzIGhhdmluZyB0byBjcmVhdGUgYSB7QGxpbmsgRGF0YVZpZXd9IG1hbnVhbGx5LCB3aGljaFxuICogcmVxdWlyZXMgcGFzc2luZyB0aGUgYGJ5dGVPZmZzZXRgIGFuZCBgYnl0ZUxlbmd0aGAgcGFyYW1ldGVycyBldmVyeSB0aW1lLlxuICpcbiAqIE5vdCBwYXNzaW5nIHRoZSBgYnl0ZU9mZnNldGAgYW5kIGBieXRlTGVuZ3RoYCBwYXJhbWV0ZXJzIGNhbiByZXN1bHQgaW5cbiAqIHVuZXhwZWN0ZWQgYmVoYXZpb3Igd2hlbiB0aGUge0BsaW5rIFVpbnQ4QXJyYXl9IGlzIGEgdmlldyBvZiBhIGxhcmdlclxuICoge0BsaW5rIEFycmF5QnVmZmVyfSwgZS5nLiwgd2hlbiB1c2luZyB7QGxpbmsgVWludDhBcnJheS5zdWJhcnJheX0uXG4gKlxuICogVGhpcyBmdW5jdGlvbiBhbHNvIHN1cHBvcnRzIE5vZGUuanMge0BsaW5rIEJ1ZmZlcn1zLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KFsxLCAyLCAzXSk7XG4gKlxuICogLy8gVGhpcyBpcyBlcXVpdmFsZW50IHRvOlxuICogLy8gY29uc3QgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYnl0ZXMuYnVmZmVyLCBieXRlcy5ieXRlT2Zmc2V0LCBieXRlcy5ieXRlTGVuZ3RoKTtcbiAqIGNvbnN0IGRhdGFWaWV3ID0gY3JlYXRlRGF0YVZpZXcoYnl0ZXMpO1xuICogYGBgXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUgYnl0ZXMgdG8gY3JlYXRlIHRoZSB7QGxpbmsgRGF0YVZpZXd9IGZyb20uXG4gKiBAcmV0dXJucyBUaGUge0BsaW5rIERhdGFWaWV3fS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGF0YVZpZXcoYnl0ZXMpIHtcbiAgICAvLyBUbyBtYWludGFpbiBjb21wYXRpYmlsaXR5IHdpdGggTm9kZS5qcywgd2UgbmVlZCB0byBjaGVjayBpZiB0aGUgYnl0ZXMgYXJlXG4gICAgLy8gYSBCdWZmZXIuIElmIHNvLCB3ZSBuZWVkIHRvIHNsaWNlIHRoZSBidWZmZXIgdG8gZ2V0IHRoZSB1bmRlcmx5aW5nXG4gICAgLy8gQXJyYXlCdWZmZXIuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xuICAgIGlmICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBieXRlcyBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICBjb25zdCBidWZmZXIgPSBieXRlcy5idWZmZXIuc2xpY2UoYnl0ZXMuYnl0ZU9mZnNldCwgYnl0ZXMuYnl0ZU9mZnNldCArIGJ5dGVzLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXR1cm4gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0YVZpZXcoYnl0ZXMuYnVmZmVyLCBieXRlcy5ieXRlT2Zmc2V0LCBieXRlcy5ieXRlTGVuZ3RoKTtcbn1cbmV4cG9ydHMuY3JlYXRlRGF0YVZpZXcgPSBjcmVhdGVEYXRhVmlldztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ5dGVzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNyZWF0ZURhdGFWaWV3IiwiY29uY2F0Qnl0ZXMiLCJ2YWx1ZVRvQnl0ZXMiLCJzdHJpbmdUb0J5dGVzIiwibnVtYmVyVG9CeXRlcyIsInNpZ25lZEJpZ0ludFRvQnl0ZXMiLCJiaWdJbnRUb0J5dGVzIiwiaGV4VG9CeXRlcyIsImJ5dGVzVG9TdHJpbmciLCJieXRlc1RvTnVtYmVyIiwiYnl0ZXNUb1NpZ25lZEJpZ0ludCIsImJ5dGVzVG9CaWdJbnQiLCJieXRlc1RvSGV4IiwiYXNzZXJ0SXNCeXRlcyIsImlzQnl0ZXMiLCJhc3NlcnRfMSIsInJlcXVpcmUiLCJoZXhfMSIsIkhFWF9NSU5JTVVNX05VTUJFUl9DSEFSQUNURVIiLCJIRVhfTUFYSU1VTV9OVU1CRVJfQ0hBUkFDVEVSIiwiSEVYX0NIQVJBQ1RFUl9PRkZTRVQiLCJnZXRQcmVjb21wdXRlZEhleFZhbHVlc0J1aWxkZXIiLCJsb29rdXBUYWJsZSIsImxlbmd0aCIsImkiLCJwdXNoIiwidG9TdHJpbmciLCJwYWRTdGFydCIsImdldFByZWNvbXB1dGVkSGV4VmFsdWVzIiwiVWludDhBcnJheSIsImFzc2VydCIsImJ5dGVzIiwiaGV4YWRlY2ltYWwiLCJBcnJheSIsImFkZDB4Iiwiam9pbiIsIkJpZ0ludCIsImJ5dGUiLCJhc0ludE4iLCJiaWdpbnQiLCJOdW1iZXIiLCJNQVhfU0FGRV9JTlRFR0VSIiwiVGV4dERlY29kZXIiLCJkZWNvZGUiLCJfYSIsInRvTG93ZXJDYXNlIiwiY2FsbCIsImFzc2VydElzSGV4U3RyaW5nIiwic3RyaXBwZWRWYWx1ZSIsInJlbW92ZTB4Iiwibm9ybWFsaXplZFZhbHVlIiwiYzEiLCJjaGFyQ29kZUF0IiwiYzIiLCJuMSIsIm4yIiwiYmlnSW50Rml0cyIsIm1hc2siLCJieXRlTGVuZ3RoIiwibnVtYmVyVmFsdWUiLCJhc1VpbnROIiwicmV2ZXJzZSIsImlzU2FmZUludGVnZXIiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsInN0YXJ0c1dpdGgiLCJUeXBlRXJyb3IiLCJ2YWx1ZXMiLCJub3JtYWxpemVkVmFsdWVzIiwib2Zmc2V0Iiwic2V0IiwiQnVmZmVyIiwiYnVmZmVyIiwic2xpY2UiLCJieXRlT2Zmc2V0IiwiRGF0YVZpZXciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/checksum.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/checksum.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ChecksumStruct = void 0;\nconst superstruct_1 = __webpack_require__(/*! superstruct */ \"(ssr)/./node_modules/superstruct/dist/index.mjs\");\nconst base64_1 = __webpack_require__(/*! ./base64 */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/base64.js\");\nexports.ChecksumStruct = (0, superstruct_1.size)((0, base64_1.base64)((0, superstruct_1.string)(), {\n    paddingRequired: true\n}), 44, 44); //# sourceMappingURL=checksum.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2NoZWNrc3VtLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxzQkFBc0IsR0FBRyxLQUFLO0FBQzlCLE1BQU1HLGdCQUFnQkMsbUJBQU9BLENBQUMsb0VBQWE7QUFDM0MsTUFBTUMsV0FBV0QsbUJBQU9BLENBQUMsb0dBQVU7QUFDbkNKLHNCQUFzQixHQUFHLENBQUMsR0FBR0csY0FBY0csSUFBSSxFQUFFLENBQUMsR0FBR0QsU0FBU0UsTUFBTSxFQUFFLENBQUMsR0FBR0osY0FBY0ssTUFBTSxLQUFLO0lBQUVDLGlCQUFpQjtBQUFLLElBQUksSUFBSSxLQUNuSSxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac2UtMi9uZXh0anMvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2NoZWNrc3VtLmpzP2Q4OWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNoZWNrc3VtU3RydWN0ID0gdm9pZCAwO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJzdXBlcnN0cnVjdFwiKTtcbmNvbnN0IGJhc2U2NF8xID0gcmVxdWlyZShcIi4vYmFzZTY0XCIpO1xuZXhwb3J0cy5DaGVja3N1bVN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnNpemUpKCgwLCBiYXNlNjRfMS5iYXNlNjQpKCgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSwgeyBwYWRkaW5nUmVxdWlyZWQ6IHRydWUgfSksIDQ0LCA0NCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGVja3N1bS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJDaGVja3N1bVN0cnVjdCIsInN1cGVyc3RydWN0XzEiLCJyZXF1aXJlIiwiYmFzZTY0XzEiLCJzaXplIiwiYmFzZTY0Iiwic3RyaW5nIiwicGFkZGluZ1JlcXVpcmVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/checksum.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/coercers.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/coercers.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createHex = exports.createBytes = exports.createBigInt = exports.createNumber = void 0;\nconst superstruct_1 = __webpack_require__(/*! superstruct */ \"(ssr)/./node_modules/superstruct/dist/index.mjs\");\nconst assert_1 = __webpack_require__(/*! ./assert */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/assert.js\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/bytes.js\");\nconst hex_1 = __webpack_require__(/*! ./hex */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/hex.js\");\nconst NumberLikeStruct = (0, superstruct_1.union)([\n    (0, superstruct_1.number)(),\n    (0, superstruct_1.bigint)(),\n    (0, superstruct_1.string)(),\n    hex_1.StrictHexStruct\n]);\nconst NumberCoercer = (0, superstruct_1.coerce)((0, superstruct_1.number)(), NumberLikeStruct, Number);\nconst BigIntCoercer = (0, superstruct_1.coerce)((0, superstruct_1.bigint)(), NumberLikeStruct, BigInt);\nconst BytesLikeStruct = (0, superstruct_1.union)([\n    hex_1.StrictHexStruct,\n    (0, superstruct_1.instance)(Uint8Array)\n]);\nconst BytesCoercer = (0, superstruct_1.coerce)((0, superstruct_1.instance)(Uint8Array), (0, superstruct_1.union)([\n    hex_1.StrictHexStruct\n]), bytes_1.hexToBytes);\nconst HexCoercer = (0, superstruct_1.coerce)(hex_1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array), bytes_1.bytesToHex);\n/**\n * Create a number from a number-like value.\n *\n * - If the value is a number, it is returned as-is.\n * - If the value is a `bigint`, it is converted to a number.\n * - If the value is a string, it is interpreted as a decimal number.\n * - If the value is a hex string (i.e., it starts with \"0x\"), it is\n * interpreted as a hexadecimal number.\n *\n * This validates that the value is a number-like value, and that the resulting\n * number is not `NaN` or `Infinity`.\n *\n * @example\n * ```typescript\n * const value = createNumber('0x010203');\n * console.log(value); // 66051\n *\n * const otherValue = createNumber(123n);\n * console.log(otherValue); // 123\n * ```\n * @param value - The value to create the number from.\n * @returns The created number.\n * @throws If the value is not a number-like value, or if the resulting number\n * is `NaN` or `Infinity`.\n */ function createNumber(value) {\n    try {\n        const result = (0, superstruct_1.create)(value, NumberCoercer);\n        (0, assert_1.assert)(Number.isFinite(result), `Expected a number-like value, got \"${value}\".`);\n        return result;\n    } catch (error) {\n        if (error instanceof superstruct_1.StructError) {\n            throw new Error(`Expected a number-like value, got \"${value}\".`);\n        }\n        /* istanbul ignore next */ throw error;\n    }\n}\nexports.createNumber = createNumber;\n/**\n * Create a `bigint` from a number-like value.\n *\n * - If the value is a number, it is converted to a `bigint`.\n * - If the value is a `bigint`, it is returned as-is.\n * - If the value is a string, it is interpreted as a decimal number and\n * converted to a `bigint`.\n * - If the value is a hex string (i.e., it starts with \"0x\"), it is\n * interpreted as a hexadecimal number and converted to a `bigint`.\n *\n * @example\n * ```typescript\n * const value = createBigInt('0x010203');\n * console.log(value); // 16909060n\n *\n * const otherValue = createBigInt(123);\n * console.log(otherValue); // 123n\n * ```\n * @param value - The value to create the bigint from.\n * @returns The created bigint.\n * @throws If the value is not a number-like value.\n */ function createBigInt(value) {\n    try {\n        // The `BigInt` constructor throws if the value is not a number-like value.\n        // There is no need to validate the value manually.\n        return (0, superstruct_1.create)(value, BigIntCoercer);\n    } catch (error) {\n        if (error instanceof superstruct_1.StructError) {\n            throw new Error(`Expected a number-like value, got \"${String(error.value)}\".`);\n        }\n        /* istanbul ignore next */ throw error;\n    }\n}\nexports.createBigInt = createBigInt;\n/**\n * Create a byte array from a bytes-like value.\n *\n * - If the value is a byte array, it is returned as-is.\n * - If the value is a hex string (i.e., it starts with \"0x\"), it is interpreted\n * as a hexadecimal number and converted to a byte array.\n *\n * @example\n * ```typescript\n * const value = createBytes('0x010203');\n * console.log(value); // Uint8Array [ 1, 2, 3 ]\n *\n * const otherValue = createBytes('0x010203');\n * console.log(otherValue); // Uint8Array [ 1, 2, 3 ]\n * ```\n * @param value - The value to create the byte array from.\n * @returns The created byte array.\n * @throws If the value is not a bytes-like value.\n */ function createBytes(value) {\n    if (typeof value === \"string\" && value.toLowerCase() === \"0x\") {\n        return new Uint8Array();\n    }\n    try {\n        return (0, superstruct_1.create)(value, BytesCoercer);\n    } catch (error) {\n        if (error instanceof superstruct_1.StructError) {\n            throw new Error(`Expected a bytes-like value, got \"${String(error.value)}\".`);\n        }\n        /* istanbul ignore next */ throw error;\n    }\n}\nexports.createBytes = createBytes;\n/**\n * Create a hexadecimal string from a bytes-like value.\n *\n * - If the value is a hex string (i.e., it starts with \"0x\"), it is returned\n * as-is.\n * - If the value is a `Uint8Array`, it is converted to a hex string.\n *\n * @example\n * ```typescript\n * const value = createHex(new Uint8Array([1, 2, 3]));\n * console.log(value); // '0x010203'\n *\n * const otherValue = createHex('0x010203');\n * console.log(otherValue); // '0x010203'\n * ```\n * @param value - The value to create the hex string from.\n * @returns The created hex string.\n * @throws If the value is not a bytes-like value.\n */ function createHex(value) {\n    if (value instanceof Uint8Array && value.length === 0 || typeof value === \"string\" && value.toLowerCase() === \"0x\") {\n        return \"0x\";\n    }\n    try {\n        return (0, superstruct_1.create)(value, HexCoercer);\n    } catch (error) {\n        if (error instanceof superstruct_1.StructError) {\n            throw new Error(`Expected a bytes-like value, got \"${String(error.value)}\".`);\n        }\n        /* istanbul ignore next */ throw error;\n    }\n}\nexports.createHex = createHex; //# sourceMappingURL=coercers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2NvZXJjZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxpQkFBaUIsR0FBR0EsbUJBQW1CLEdBQUdBLG9CQUFvQixHQUFHQSxvQkFBb0IsR0FBRyxLQUFLO0FBQzdGLE1BQU1NLGdCQUFnQkMsbUJBQU9BLENBQUMsb0VBQWE7QUFDM0MsTUFBTUMsV0FBV0QsbUJBQU9BLENBQUMsb0dBQVU7QUFDbkMsTUFBTUUsVUFBVUYsbUJBQU9BLENBQUMsa0dBQVM7QUFDakMsTUFBTUcsUUFBUUgsbUJBQU9BLENBQUMsOEZBQU87QUFDN0IsTUFBTUksbUJBQW1CLENBQUMsR0FBR0wsY0FBY00sS0FBSyxFQUFFO0lBQUUsSUFBR04sY0FBY08sTUFBTTtJQUFNLElBQUdQLGNBQWNRLE1BQU07SUFBTSxJQUFHUixjQUFjUyxNQUFNO0lBQUtMLE1BQU1NLGVBQWU7Q0FBQztBQUNoSyxNQUFNQyxnQkFBZ0IsQ0FBQyxHQUFHWCxjQUFjWSxNQUFNLEVBQUUsQ0FBQyxHQUFHWixjQUFjTyxNQUFNLEtBQUtGLGtCQUFrQlE7QUFDL0YsTUFBTUMsZ0JBQWdCLENBQUMsR0FBR2QsY0FBY1ksTUFBTSxFQUFFLENBQUMsR0FBR1osY0FBY1EsTUFBTSxLQUFLSCxrQkFBa0JVO0FBQy9GLE1BQU1DLGtCQUFrQixDQUFDLEdBQUdoQixjQUFjTSxLQUFLLEVBQUU7SUFBQ0YsTUFBTU0sZUFBZTtJQUFHLElBQUdWLGNBQWNpQixRQUFRLEVBQUVDO0NBQVk7QUFDakgsTUFBTUMsZUFBZSxDQUFDLEdBQUduQixjQUFjWSxNQUFNLEVBQUUsQ0FBQyxHQUFHWixjQUFjaUIsUUFBUSxFQUFFQyxhQUFhLENBQUMsR0FBR2xCLGNBQWNNLEtBQUssRUFBRTtJQUFDRixNQUFNTSxlQUFlO0NBQUMsR0FBR1AsUUFBUWlCLFVBQVU7QUFDN0osTUFBTUMsYUFBYSxDQUFDLEdBQUdyQixjQUFjWSxNQUFNLEVBQUVSLE1BQU1NLGVBQWUsRUFBRSxDQUFDLEdBQUdWLGNBQWNpQixRQUFRLEVBQUVDLGFBQWFmLFFBQVFtQixVQUFVO0FBQy9IOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F3QkMsR0FDRCxTQUFTdkIsYUFBYUosS0FBSztJQUN2QixJQUFJO1FBQ0EsTUFBTTRCLFNBQVMsQ0FBQyxHQUFHdkIsY0FBY3dCLE1BQU0sRUFBRTdCLE9BQU9nQjtRQUMvQyxJQUFHVCxTQUFTdUIsTUFBTSxFQUFFWixPQUFPYSxRQUFRLENBQUNILFNBQVMsQ0FBQyxtQ0FBbUMsRUFBRTVCLE1BQU0sRUFBRSxDQUFDO1FBQzdGLE9BQU80QjtJQUNYLEVBQ0EsT0FBT0ksT0FBTztRQUNWLElBQUlBLGlCQUFpQjNCLGNBQWM0QixXQUFXLEVBQUU7WUFDNUMsTUFBTSxJQUFJQyxNQUFNLENBQUMsbUNBQW1DLEVBQUVsQyxNQUFNLEVBQUUsQ0FBQztRQUNuRTtRQUNBLHdCQUF3QixHQUN4QixNQUFNZ0M7SUFDVjtBQUNKO0FBQ0FqQyxvQkFBb0IsR0FBR0s7QUFDdkI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXFCQyxHQUNELFNBQVNELGFBQWFILEtBQUs7SUFDdkIsSUFBSTtRQUNBLDJFQUEyRTtRQUMzRSxtREFBbUQ7UUFDbkQsT0FBTyxDQUFDLEdBQUdLLGNBQWN3QixNQUFNLEVBQUU3QixPQUFPbUI7SUFDNUMsRUFDQSxPQUFPYSxPQUFPO1FBQ1YsSUFBSUEsaUJBQWlCM0IsY0FBYzRCLFdBQVcsRUFBRTtZQUM1QyxNQUFNLElBQUlDLE1BQU0sQ0FBQyxtQ0FBbUMsRUFBRUMsT0FBT0gsTUFBTWhDLEtBQUssRUFBRSxFQUFFLENBQUM7UUFDakY7UUFDQSx3QkFBd0IsR0FDeEIsTUFBTWdDO0lBQ1Y7QUFDSjtBQUNBakMsb0JBQW9CLEdBQUdJO0FBQ3ZCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrQkMsR0FDRCxTQUFTRCxZQUFZRixLQUFLO0lBQ3RCLElBQUksT0FBT0EsVUFBVSxZQUFZQSxNQUFNb0MsV0FBVyxPQUFPLE1BQU07UUFDM0QsT0FBTyxJQUFJYjtJQUNmO0lBQ0EsSUFBSTtRQUNBLE9BQU8sQ0FBQyxHQUFHbEIsY0FBY3dCLE1BQU0sRUFBRTdCLE9BQU93QjtJQUM1QyxFQUNBLE9BQU9RLE9BQU87UUFDVixJQUFJQSxpQkFBaUIzQixjQUFjNEIsV0FBVyxFQUFFO1lBQzVDLE1BQU0sSUFBSUMsTUFBTSxDQUFDLGtDQUFrQyxFQUFFQyxPQUFPSCxNQUFNaEMsS0FBSyxFQUFFLEVBQUUsQ0FBQztRQUNoRjtRQUNBLHdCQUF3QixHQUN4QixNQUFNZ0M7SUFDVjtBQUNKO0FBQ0FqQyxtQkFBbUIsR0FBR0c7QUFDdEI7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtCQyxHQUNELFNBQVNELFVBQVVELEtBQUs7SUFDcEIsSUFBSSxpQkFBa0J1QixjQUFjdkIsTUFBTXFDLE1BQU0sS0FBSyxLQUNoRCxPQUFPckMsVUFBVSxZQUFZQSxNQUFNb0MsV0FBVyxPQUFPLE1BQU87UUFDN0QsT0FBTztJQUNYO0lBQ0EsSUFBSTtRQUNBLE9BQU8sQ0FBQyxHQUFHL0IsY0FBY3dCLE1BQU0sRUFBRTdCLE9BQU8wQjtJQUM1QyxFQUNBLE9BQU9NLE9BQU87UUFDVixJQUFJQSxpQkFBaUIzQixjQUFjNEIsV0FBVyxFQUFFO1lBQzVDLE1BQU0sSUFBSUMsTUFBTSxDQUFDLGtDQUFrQyxFQUFFQyxPQUFPSCxNQUFNaEMsS0FBSyxFQUFFLEVBQUUsQ0FBQztRQUNoRjtRQUNBLHdCQUF3QixHQUN4QixNQUFNZ0M7SUFDVjtBQUNKO0FBQ0FqQyxpQkFBaUIsR0FBR0UsV0FDcEIsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHNlLTIvbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2V0aC1ibG9jay10cmFja2VyL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9jb2VyY2Vycy5qcz8xNWYxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVIZXggPSBleHBvcnRzLmNyZWF0ZUJ5dGVzID0gZXhwb3J0cy5jcmVhdGVCaWdJbnQgPSBleHBvcnRzLmNyZWF0ZU51bWJlciA9IHZvaWQgMDtcbmNvbnN0IHN1cGVyc3RydWN0XzEgPSByZXF1aXJlKFwic3VwZXJzdHJ1Y3RcIik7XG5jb25zdCBhc3NlcnRfMSA9IHJlcXVpcmUoXCIuL2Fzc2VydFwiKTtcbmNvbnN0IGJ5dGVzXzEgPSByZXF1aXJlKFwiLi9ieXRlc1wiKTtcbmNvbnN0IGhleF8xID0gcmVxdWlyZShcIi4vaGV4XCIpO1xuY29uc3QgTnVtYmVyTGlrZVN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnVuaW9uKShbKDAsIHN1cGVyc3RydWN0XzEubnVtYmVyKSgpLCAoMCwgc3VwZXJzdHJ1Y3RfMS5iaWdpbnQpKCksICgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSwgaGV4XzEuU3RyaWN0SGV4U3RydWN0XSk7XG5jb25zdCBOdW1iZXJDb2VyY2VyID0gKDAsIHN1cGVyc3RydWN0XzEuY29lcmNlKSgoMCwgc3VwZXJzdHJ1Y3RfMS5udW1iZXIpKCksIE51bWJlckxpa2VTdHJ1Y3QsIE51bWJlcik7XG5jb25zdCBCaWdJbnRDb2VyY2VyID0gKDAsIHN1cGVyc3RydWN0XzEuY29lcmNlKSgoMCwgc3VwZXJzdHJ1Y3RfMS5iaWdpbnQpKCksIE51bWJlckxpa2VTdHJ1Y3QsIEJpZ0ludCk7XG5jb25zdCBCeXRlc0xpa2VTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS51bmlvbikoW2hleF8xLlN0cmljdEhleFN0cnVjdCwgKDAsIHN1cGVyc3RydWN0XzEuaW5zdGFuY2UpKFVpbnQ4QXJyYXkpXSk7XG5jb25zdCBCeXRlc0NvZXJjZXIgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5jb2VyY2UpKCgwLCBzdXBlcnN0cnVjdF8xLmluc3RhbmNlKShVaW50OEFycmF5KSwgKDAsIHN1cGVyc3RydWN0XzEudW5pb24pKFtoZXhfMS5TdHJpY3RIZXhTdHJ1Y3RdKSwgYnl0ZXNfMS5oZXhUb0J5dGVzKTtcbmNvbnN0IEhleENvZXJjZXIgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5jb2VyY2UpKGhleF8xLlN0cmljdEhleFN0cnVjdCwgKDAsIHN1cGVyc3RydWN0XzEuaW5zdGFuY2UpKFVpbnQ4QXJyYXkpLCBieXRlc18xLmJ5dGVzVG9IZXgpO1xuLyoqXG4gKiBDcmVhdGUgYSBudW1iZXIgZnJvbSBhIG51bWJlci1saWtlIHZhbHVlLlxuICpcbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGEgbnVtYmVyLCBpdCBpcyByZXR1cm5lZCBhcy1pcy5cbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGEgYGJpZ2ludGAsIGl0IGlzIGNvbnZlcnRlZCB0byBhIG51bWJlci5cbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGEgc3RyaW5nLCBpdCBpcyBpbnRlcnByZXRlZCBhcyBhIGRlY2ltYWwgbnVtYmVyLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBoZXggc3RyaW5nIChpLmUuLCBpdCBzdGFydHMgd2l0aCBcIjB4XCIpLCBpdCBpc1xuICogaW50ZXJwcmV0ZWQgYXMgYSBoZXhhZGVjaW1hbCBudW1iZXIuXG4gKlxuICogVGhpcyB2YWxpZGF0ZXMgdGhhdCB0aGUgdmFsdWUgaXMgYSBudW1iZXItbGlrZSB2YWx1ZSwgYW5kIHRoYXQgdGhlIHJlc3VsdGluZ1xuICogbnVtYmVyIGlzIG5vdCBgTmFOYCBvciBgSW5maW5pdHlgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCB2YWx1ZSA9IGNyZWF0ZU51bWJlcignMHgwMTAyMDMnKTtcbiAqIGNvbnNvbGUubG9nKHZhbHVlKTsgLy8gNjYwNTFcbiAqXG4gKiBjb25zdCBvdGhlclZhbHVlID0gY3JlYXRlTnVtYmVyKDEyM24pO1xuICogY29uc29sZS5sb2cob3RoZXJWYWx1ZSk7IC8vIDEyM1xuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY3JlYXRlIHRoZSBudW1iZXIgZnJvbS5cbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIG51bWJlci5cbiAqIEB0aHJvd3MgSWYgdGhlIHZhbHVlIGlzIG5vdCBhIG51bWJlci1saWtlIHZhbHVlLCBvciBpZiB0aGUgcmVzdWx0aW5nIG51bWJlclxuICogaXMgYE5hTmAgb3IgYEluZmluaXR5YC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTnVtYmVyKHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gKDAsIHN1cGVyc3RydWN0XzEuY3JlYXRlKSh2YWx1ZSwgTnVtYmVyQ29lcmNlcik7XG4gICAgICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKE51bWJlci5pc0Zpbml0ZShyZXN1bHQpLCBgRXhwZWN0ZWQgYSBudW1iZXItbGlrZSB2YWx1ZSwgZ290IFwiJHt2YWx1ZX1cIi5gKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIHN1cGVyc3RydWN0XzEuU3RydWN0RXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBudW1iZXItbGlrZSB2YWx1ZSwgZ290IFwiJHt2YWx1ZX1cIi5gKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59XG5leHBvcnRzLmNyZWF0ZU51bWJlciA9IGNyZWF0ZU51bWJlcjtcbi8qKlxuICogQ3JlYXRlIGEgYGJpZ2ludGAgZnJvbSBhIG51bWJlci1saWtlIHZhbHVlLlxuICpcbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGEgbnVtYmVyLCBpdCBpcyBjb252ZXJ0ZWQgdG8gYSBgYmlnaW50YC5cbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGEgYGJpZ2ludGAsIGl0IGlzIHJldHVybmVkIGFzLWlzLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmcsIGl0IGlzIGludGVycHJldGVkIGFzIGEgZGVjaW1hbCBudW1iZXIgYW5kXG4gKiBjb252ZXJ0ZWQgdG8gYSBgYmlnaW50YC5cbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGEgaGV4IHN0cmluZyAoaS5lLiwgaXQgc3RhcnRzIHdpdGggXCIweFwiKSwgaXQgaXNcbiAqIGludGVycHJldGVkIGFzIGEgaGV4YWRlY2ltYWwgbnVtYmVyIGFuZCBjb252ZXJ0ZWQgdG8gYSBgYmlnaW50YC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgdmFsdWUgPSBjcmVhdGVCaWdJbnQoJzB4MDEwMjAzJyk7XG4gKiBjb25zb2xlLmxvZyh2YWx1ZSk7IC8vIDE2OTA5MDYwblxuICpcbiAqIGNvbnN0IG90aGVyVmFsdWUgPSBjcmVhdGVCaWdJbnQoMTIzKTtcbiAqIGNvbnNvbGUubG9nKG90aGVyVmFsdWUpOyAvLyAxMjNuXG4gKiBgYGBcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjcmVhdGUgdGhlIGJpZ2ludCBmcm9tLlxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQgYmlnaW50LlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgbnVtYmVyLWxpa2UgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJpZ0ludCh2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIFRoZSBgQmlnSW50YCBjb25zdHJ1Y3RvciB0aHJvd3MgaWYgdGhlIHZhbHVlIGlzIG5vdCBhIG51bWJlci1saWtlIHZhbHVlLlxuICAgICAgICAvLyBUaGVyZSBpcyBubyBuZWVkIHRvIHZhbGlkYXRlIHRoZSB2YWx1ZSBtYW51YWxseS5cbiAgICAgICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmNyZWF0ZSkodmFsdWUsIEJpZ0ludENvZXJjZXIpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2Ygc3VwZXJzdHJ1Y3RfMS5TdHJ1Y3RFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIG51bWJlci1saWtlIHZhbHVlLCBnb3QgXCIke1N0cmluZyhlcnJvci52YWx1ZSl9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuZXhwb3J0cy5jcmVhdGVCaWdJbnQgPSBjcmVhdGVCaWdJbnQ7XG4vKipcbiAqIENyZWF0ZSBhIGJ5dGUgYXJyYXkgZnJvbSBhIGJ5dGVzLWxpa2UgdmFsdWUuXG4gKlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBieXRlIGFycmF5LCBpdCBpcyByZXR1cm5lZCBhcy1pcy5cbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGEgaGV4IHN0cmluZyAoaS5lLiwgaXQgc3RhcnRzIHdpdGggXCIweFwiKSwgaXQgaXMgaW50ZXJwcmV0ZWRcbiAqIGFzIGEgaGV4YWRlY2ltYWwgbnVtYmVyIGFuZCBjb252ZXJ0ZWQgdG8gYSBieXRlIGFycmF5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCB2YWx1ZSA9IGNyZWF0ZUJ5dGVzKCcweDAxMDIwMycpO1xuICogY29uc29sZS5sb2codmFsdWUpOyAvLyBVaW50OEFycmF5IFsgMSwgMiwgMyBdXG4gKlxuICogY29uc3Qgb3RoZXJWYWx1ZSA9IGNyZWF0ZUJ5dGVzKCcweDAxMDIwMycpO1xuICogY29uc29sZS5sb2cob3RoZXJWYWx1ZSk7IC8vIFVpbnQ4QXJyYXkgWyAxLCAyLCAzIF1cbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNyZWF0ZSB0aGUgYnl0ZSBhcnJheSBmcm9tLlxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQgYnl0ZSBhcnJheS5cbiAqIEB0aHJvd3MgSWYgdGhlIHZhbHVlIGlzIG5vdCBhIGJ5dGVzLWxpa2UgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ5dGVzKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gJzB4Jykge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmNyZWF0ZSkodmFsdWUsIEJ5dGVzQ29lcmNlcik7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBzdXBlcnN0cnVjdF8xLlN0cnVjdEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgYnl0ZXMtbGlrZSB2YWx1ZSwgZ290IFwiJHtTdHJpbmcoZXJyb3IudmFsdWUpfVwiLmApO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cbmV4cG9ydHMuY3JlYXRlQnl0ZXMgPSBjcmVhdGVCeXRlcztcbi8qKlxuICogQ3JlYXRlIGEgaGV4YWRlY2ltYWwgc3RyaW5nIGZyb20gYSBieXRlcy1saWtlIHZhbHVlLlxuICpcbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGEgaGV4IHN0cmluZyAoaS5lLiwgaXQgc3RhcnRzIHdpdGggXCIweFwiKSwgaXQgaXMgcmV0dXJuZWRcbiAqIGFzLWlzLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBgVWludDhBcnJheWAsIGl0IGlzIGNvbnZlcnRlZCB0byBhIGhleCBzdHJpbmcuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IHZhbHVlID0gY3JlYXRlSGV4KG5ldyBVaW50OEFycmF5KFsxLCAyLCAzXSkpO1xuICogY29uc29sZS5sb2codmFsdWUpOyAvLyAnMHgwMTAyMDMnXG4gKlxuICogY29uc3Qgb3RoZXJWYWx1ZSA9IGNyZWF0ZUhleCgnMHgwMTAyMDMnKTtcbiAqIGNvbnNvbGUubG9nKG90aGVyVmFsdWUpOyAvLyAnMHgwMTAyMDMnXG4gKiBgYGBcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjcmVhdGUgdGhlIGhleCBzdHJpbmcgZnJvbS5cbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIGhleCBzdHJpbmcuXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSBieXRlcy1saWtlIHZhbHVlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVIZXgodmFsdWUpIHtcbiAgICBpZiAoKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiB2YWx1ZS5sZW5ndGggPT09IDApIHx8XG4gICAgICAgICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09ICcweCcpKSB7XG4gICAgICAgIHJldHVybiAnMHgnO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuY3JlYXRlKSh2YWx1ZSwgSGV4Q29lcmNlcik7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBzdXBlcnN0cnVjdF8xLlN0cnVjdEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgYnl0ZXMtbGlrZSB2YWx1ZSwgZ290IFwiJHtTdHJpbmcoZXJyb3IudmFsdWUpfVwiLmApO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cbmV4cG9ydHMuY3JlYXRlSGV4ID0gY3JlYXRlSGV4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29lcmNlcnMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiY3JlYXRlSGV4IiwiY3JlYXRlQnl0ZXMiLCJjcmVhdGVCaWdJbnQiLCJjcmVhdGVOdW1iZXIiLCJzdXBlcnN0cnVjdF8xIiwicmVxdWlyZSIsImFzc2VydF8xIiwiYnl0ZXNfMSIsImhleF8xIiwiTnVtYmVyTGlrZVN0cnVjdCIsInVuaW9uIiwibnVtYmVyIiwiYmlnaW50Iiwic3RyaW5nIiwiU3RyaWN0SGV4U3RydWN0IiwiTnVtYmVyQ29lcmNlciIsImNvZXJjZSIsIk51bWJlciIsIkJpZ0ludENvZXJjZXIiLCJCaWdJbnQiLCJCeXRlc0xpa2VTdHJ1Y3QiLCJpbnN0YW5jZSIsIlVpbnQ4QXJyYXkiLCJCeXRlc0NvZXJjZXIiLCJoZXhUb0J5dGVzIiwiSGV4Q29lcmNlciIsImJ5dGVzVG9IZXgiLCJyZXN1bHQiLCJjcmVhdGUiLCJhc3NlcnQiLCJpc0Zpbml0ZSIsImVycm9yIiwiU3RydWN0RXJyb3IiLCJFcnJvciIsIlN0cmluZyIsInRvTG93ZXJDYXNlIiwibGVuZ3RoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/coercers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/collections.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/collections.js ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function(receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _FrozenMap_map, _FrozenSet_set;\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.FrozenSet = exports.FrozenMap = void 0;\n/**\n * A {@link ReadonlyMap} that cannot be modified after instantiation.\n * The implementation uses an inner map hidden via a private field, and the\n * immutability guarantee relies on it being impossible to get a reference\n * to this map.\n */ class FrozenMap {\n    constructor(entries){\n        _FrozenMap_map.set(this, void 0);\n        __classPrivateFieldSet(this, _FrozenMap_map, new Map(entries), \"f\");\n        Object.freeze(this);\n    }\n    get size() {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").size;\n    }\n    [(_FrozenMap_map = new WeakMap(), Symbol.iterator)]() {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\")[Symbol.iterator]();\n    }\n    entries() {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").entries();\n    }\n    forEach(callbackfn, thisArg) {\n        // We have to wrap the specified callback in order to prevent it from\n        // receiving a reference to the inner map.\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").forEach((value, key, _map)=>callbackfn.call(thisArg, value, key, this));\n    }\n    get(key) {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").get(key);\n    }\n    has(key) {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").has(key);\n    }\n    keys() {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").keys();\n    }\n    values() {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").values();\n    }\n    toString() {\n        return `FrozenMap(${this.size}) {${this.size > 0 ? ` ${[\n            ...this.entries()\n        ].map(([key, value])=>`${String(key)} => ${String(value)}`).join(\", \")} ` : \"\"}}`;\n    }\n}\nexports.FrozenMap = FrozenMap;\n/**\n * A {@link ReadonlySet} that cannot be modified after instantiation.\n * The implementation uses an inner set hidden via a private field, and the\n * immutability guarantee relies on it being impossible to get a reference\n * to this set.\n */ class FrozenSet {\n    constructor(values){\n        _FrozenSet_set.set(this, void 0);\n        __classPrivateFieldSet(this, _FrozenSet_set, new Set(values), \"f\");\n        Object.freeze(this);\n    }\n    get size() {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").size;\n    }\n    [(_FrozenSet_set = new WeakMap(), Symbol.iterator)]() {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\")[Symbol.iterator]();\n    }\n    entries() {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").entries();\n    }\n    forEach(callbackfn, thisArg) {\n        // We have to wrap the specified callback in order to prevent it from\n        // receiving a reference to the inner set.\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").forEach((value, value2, _set)=>callbackfn.call(thisArg, value, value2, this));\n    }\n    has(value) {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").has(value);\n    }\n    keys() {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").keys();\n    }\n    values() {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").values();\n    }\n    toString() {\n        return `FrozenSet(${this.size}) {${this.size > 0 ? ` ${[\n            ...this.values()\n        ].map((member)=>String(member)).join(\", \")} ` : \"\"}}`;\n    }\n}\nexports.FrozenSet = FrozenSet;\nObject.freeze(FrozenMap);\nObject.freeze(FrozenMap.prototype);\nObject.freeze(FrozenSet);\nObject.freeze(FrozenSet.prototype); //# sourceMappingURL=collections.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2NvbGxlY3Rpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEseUJBQXlCLElBQUssSUFBSSxJQUFJLENBQUNBLHNCQUFzQixJQUFLLFNBQVVDLFFBQVEsRUFBRUMsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsQ0FBQztJQUMzRyxJQUFJRCxTQUFTLEtBQUssTUFBTSxJQUFJRSxVQUFVO0lBQ3RDLElBQUlGLFNBQVMsT0FBTyxDQUFDQyxHQUFHLE1BQU0sSUFBSUMsVUFBVTtJQUM1QyxJQUFJLE9BQU9KLFVBQVUsYUFBYUQsYUFBYUMsU0FBUyxDQUFDRyxJQUFJLENBQUNILE1BQU1LLEdBQUcsQ0FBQ04sV0FBVyxNQUFNLElBQUlLLFVBQVU7SUFDdkcsT0FBTyxTQUFVLE1BQU1ELEVBQUVHLElBQUksQ0FBQ1AsVUFBVUUsU0FBU0UsSUFBSUEsRUFBRUYsS0FBSyxHQUFHQSxRQUFRRCxNQUFNTyxHQUFHLENBQUNSLFVBQVVFLFFBQVNBO0FBQ3hHO0FBQ0EsSUFBSU8seUJBQXlCLElBQUssSUFBSSxJQUFJLENBQUNBLHNCQUFzQixJQUFLLFNBQVVULFFBQVEsRUFBRUMsS0FBSyxFQUFFRSxJQUFJLEVBQUVDLENBQUM7SUFDcEcsSUFBSUQsU0FBUyxPQUFPLENBQUNDLEdBQUcsTUFBTSxJQUFJQyxVQUFVO0lBQzVDLElBQUksT0FBT0osVUFBVSxhQUFhRCxhQUFhQyxTQUFTLENBQUNHLElBQUksQ0FBQ0gsTUFBTUssR0FBRyxDQUFDTixXQUFXLE1BQU0sSUFBSUssVUFBVTtJQUN2RyxPQUFPRixTQUFTLE1BQU1DLElBQUlELFNBQVMsTUFBTUMsRUFBRUcsSUFBSSxDQUFDUCxZQUFZSSxJQUFJQSxFQUFFRixLQUFLLEdBQUdELE1BQU1TLEdBQUcsQ0FBQ1Y7QUFDeEY7QUFDQSxJQUFJVyxnQkFBZ0JDO0FBQ3BC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QUMxQyxPQUFPbkIsdUJBQXVCLElBQUksRUFBRUcsZ0JBQWdCLEtBQUtjLE9BQU8sQ0FBQyxDQUFDeEIsT0FBT29DLFFBQVFDLE9BQVNaLFdBQVdwQixJQUFJLENBQUNxQixTQUFTMUIsT0FBT29DLFFBQVEsSUFBSTtJQUMxSTtJQUNBaEMsSUFBSUosS0FBSyxFQUFFO1FBQ1AsT0FBT08sdUJBQXVCLElBQUksRUFBRUcsZ0JBQWdCLEtBQUtOLEdBQUcsQ0FBQ0o7SUFDakU7SUFDQTZCLE9BQU87UUFDSCxPQUFPdEIsdUJBQXVCLElBQUksRUFBRUcsZ0JBQWdCLEtBQUttQixJQUFJO0lBQ2pFO0lBQ0FDLFNBQVM7UUFDTCxPQUFPdkIsdUJBQXVCLElBQUksRUFBRUcsZ0JBQWdCLEtBQUtvQixNQUFNO0lBQ25FO0lBQ0FDLFdBQVc7UUFDUCxPQUFPLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQ1gsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUNBLElBQUksR0FBRyxJQUN6QyxDQUFDLENBQUMsRUFBRTtlQUFJLElBQUksQ0FBQ1UsTUFBTTtTQUFHLENBQUNFLEdBQUcsQ0FBQyxDQUFDTSxTQUFXTCxPQUFPSyxTQUFTSixJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsR0FDcEUsR0FBRyxDQUFDLENBQUM7SUFDZjtBQUNKO0FBQ0FyQixpQkFBaUIsR0FBR0M7QUFDcEJILE9BQU9RLE1BQU0sQ0FBQ0o7QUFDZEosT0FBT1EsTUFBTSxDQUFDSixVQUFVd0IsU0FBUztBQUNqQzVCLE9BQU9RLE1BQU0sQ0FBQ0w7QUFDZEgsT0FBT1EsTUFBTSxDQUFDTCxVQUFVeUIsU0FBUyxHQUNqQyx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac2UtMi9uZXh0anMvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2NvbGxlY3Rpb25zLmpzPzk3ZDciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX0Zyb3plbk1hcF9tYXAsIF9Gcm96ZW5TZXRfc2V0O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Gcm96ZW5TZXQgPSBleHBvcnRzLkZyb3plbk1hcCA9IHZvaWQgMDtcbi8qKlxuICogQSB7QGxpbmsgUmVhZG9ubHlNYXB9IHRoYXQgY2Fubm90IGJlIG1vZGlmaWVkIGFmdGVyIGluc3RhbnRpYXRpb24uXG4gKiBUaGUgaW1wbGVtZW50YXRpb24gdXNlcyBhbiBpbm5lciBtYXAgaGlkZGVuIHZpYSBhIHByaXZhdGUgZmllbGQsIGFuZCB0aGVcbiAqIGltbXV0YWJpbGl0eSBndWFyYW50ZWUgcmVsaWVzIG9uIGl0IGJlaW5nIGltcG9zc2libGUgdG8gZ2V0IGEgcmVmZXJlbmNlXG4gKiB0byB0aGlzIG1hcC5cbiAqL1xuY2xhc3MgRnJvemVuTWFwIHtcbiAgICBjb25zdHJ1Y3RvcihlbnRyaWVzKSB7XG4gICAgICAgIF9Gcm96ZW5NYXBfbWFwLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBuZXcgTWFwKGVudHJpZXMpLCBcImZcIik7XG4gICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgXCJmXCIpLnNpemU7XG4gICAgfVxuICAgIFsoX0Zyb3plbk1hcF9tYXAgPSBuZXcgV2Vha01hcCgpLCBTeW1ib2wuaXRlcmF0b3IpXSgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIFwiZlwiKVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgfVxuICAgIGVudHJpZXMoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikuZW50cmllcygpO1xuICAgIH1cbiAgICBmb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSB0byB3cmFwIHRoZSBzcGVjaWZpZWQgY2FsbGJhY2sgaW4gb3JkZXIgdG8gcHJldmVudCBpdCBmcm9tXG4gICAgICAgIC8vIHJlY2VpdmluZyBhIHJlZmVyZW5jZSB0byB0aGUgaW5uZXIgbWFwLlxuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgXCJmXCIpLmZvckVhY2goKHZhbHVlLCBrZXksIF9tYXApID0+IGNhbGxiYWNrZm4uY2FsbCh0aGlzQXJnLCB2YWx1ZSwga2V5LCB0aGlzKSk7XG4gICAgfVxuICAgIGdldChrZXkpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIFwiZlwiKS5nZXQoa2V5KTtcbiAgICB9XG4gICAgaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgXCJmXCIpLmhhcyhrZXkpO1xuICAgIH1cbiAgICBrZXlzKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgXCJmXCIpLmtleXMoKTtcbiAgICB9XG4gICAgdmFsdWVzKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgXCJmXCIpLnZhbHVlcygpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBGcm96ZW5NYXAoJHt0aGlzLnNpemV9KSB7JHt0aGlzLnNpemUgPiAwXG4gICAgICAgICAgICA/IGAgJHtbLi4udGhpcy5lbnRyaWVzKCldXG4gICAgICAgICAgICAgICAgLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBgJHtTdHJpbmcoa2V5KX0gPT4gJHtTdHJpbmcodmFsdWUpfWApXG4gICAgICAgICAgICAgICAgLmpvaW4oJywgJyl9IGBcbiAgICAgICAgICAgIDogJyd9fWA7XG4gICAgfVxufVxuZXhwb3J0cy5Gcm96ZW5NYXAgPSBGcm96ZW5NYXA7XG4vKipcbiAqIEEge0BsaW5rIFJlYWRvbmx5U2V0fSB0aGF0IGNhbm5vdCBiZSBtb2RpZmllZCBhZnRlciBpbnN0YW50aWF0aW9uLlxuICogVGhlIGltcGxlbWVudGF0aW9uIHVzZXMgYW4gaW5uZXIgc2V0IGhpZGRlbiB2aWEgYSBwcml2YXRlIGZpZWxkLCBhbmQgdGhlXG4gKiBpbW11dGFiaWxpdHkgZ3VhcmFudGVlIHJlbGllcyBvbiBpdCBiZWluZyBpbXBvc3NpYmxlIHRvIGdldCBhIHJlZmVyZW5jZVxuICogdG8gdGhpcyBzZXQuXG4gKi9cbmNsYXNzIEZyb3plblNldCB7XG4gICAgY29uc3RydWN0b3IodmFsdWVzKSB7XG4gICAgICAgIF9Gcm96ZW5TZXRfc2V0LnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9Gcm96ZW5TZXRfc2V0LCBuZXcgU2V0KHZhbHVlcyksIFwiZlwiKTtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5TZXRfc2V0LCBcImZcIikuc2l6ZTtcbiAgICB9XG4gICAgWyhfRnJvemVuU2V0X3NldCA9IG5ldyBXZWFrTWFwKCksIFN5bWJvbC5pdGVyYXRvcildKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgXCJmXCIpW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICB9XG4gICAgZW50cmllcygpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plblNldF9zZXQsIFwiZlwiKS5lbnRyaWVzKCk7XG4gICAgfVxuICAgIGZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZykge1xuICAgICAgICAvLyBXZSBoYXZlIHRvIHdyYXAgdGhlIHNwZWNpZmllZCBjYWxsYmFjayBpbiBvcmRlciB0byBwcmV2ZW50IGl0IGZyb21cbiAgICAgICAgLy8gcmVjZWl2aW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBpbm5lciBzZXQuXG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5TZXRfc2V0LCBcImZcIikuZm9yRWFjaCgodmFsdWUsIHZhbHVlMiwgX3NldCkgPT4gY2FsbGJhY2tmbi5jYWxsKHRoaXNBcmcsIHZhbHVlLCB2YWx1ZTIsIHRoaXMpKTtcbiAgICB9XG4gICAgaGFzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5TZXRfc2V0LCBcImZcIikuaGFzKHZhbHVlKTtcbiAgICB9XG4gICAga2V5cygpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plblNldF9zZXQsIFwiZlwiKS5rZXlzKCk7XG4gICAgfVxuICAgIHZhbHVlcygpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plblNldF9zZXQsIFwiZlwiKS52YWx1ZXMoKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgRnJvemVuU2V0KCR7dGhpcy5zaXplfSkgeyR7dGhpcy5zaXplID4gMFxuICAgICAgICAgICAgPyBgICR7Wy4uLnRoaXMudmFsdWVzKCldLm1hcCgobWVtYmVyKSA9PiBTdHJpbmcobWVtYmVyKSkuam9pbignLCAnKX0gYFxuICAgICAgICAgICAgOiAnJ319YDtcbiAgICB9XG59XG5leHBvcnRzLkZyb3plblNldCA9IEZyb3plblNldDtcbk9iamVjdC5mcmVlemUoRnJvemVuTWFwKTtcbk9iamVjdC5mcmVlemUoRnJvemVuTWFwLnByb3RvdHlwZSk7XG5PYmplY3QuZnJlZXplKEZyb3plblNldCk7XG5PYmplY3QuZnJlZXplKEZyb3plblNldC5wcm90b3R5cGUpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29sbGVjdGlvbnMuanMubWFwIl0sIm5hbWVzIjpbIl9fY2xhc3NQcml2YXRlRmllbGRTZXQiLCJyZWNlaXZlciIsInN0YXRlIiwidmFsdWUiLCJraW5kIiwiZiIsIlR5cGVFcnJvciIsImhhcyIsImNhbGwiLCJzZXQiLCJfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0IiwiZ2V0IiwiX0Zyb3plbk1hcF9tYXAiLCJfRnJvemVuU2V0X3NldCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsIkZyb3plblNldCIsIkZyb3plbk1hcCIsImNvbnN0cnVjdG9yIiwiZW50cmllcyIsIk1hcCIsImZyZWV6ZSIsInNpemUiLCJXZWFrTWFwIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJmb3JFYWNoIiwiY2FsbGJhY2tmbiIsInRoaXNBcmciLCJrZXkiLCJfbWFwIiwia2V5cyIsInZhbHVlcyIsInRvU3RyaW5nIiwibWFwIiwiU3RyaW5nIiwiam9pbiIsIlNldCIsInZhbHVlMiIsIl9zZXQiLCJtZW1iZXIiLCJwcm90b3R5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/collections.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/encryption-types.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/encryption-types.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n})); //# sourceMappingURL=encryption-types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2VuY3J5cHRpb24tdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUMsRUFDN0QsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHNlLTIvbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2V0aC1ibG9jay10cmFja2VyL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9lbmNyeXB0aW9uLXR5cGVzLmpzPzEzYzkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbmNyeXB0aW9uLXR5cGVzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/encryption-types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/hex.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/hex.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.remove0x = exports.add0x = exports.assertIsStrictHexString = exports.assertIsHexString = exports.isStrictHexString = exports.isHexString = exports.StrictHexStruct = exports.HexStruct = void 0;\nconst superstruct_1 = __webpack_require__(/*! superstruct */ \"(ssr)/./node_modules/superstruct/dist/index.mjs\");\nconst assert_1 = __webpack_require__(/*! ./assert */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/assert.js\");\nexports.HexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^(?:0x)?[0-9a-f]+$/iu);\nexports.StrictHexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^0x[0-9a-f]+$/iu);\n/**\n * Check if a string is a valid hex string.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex string.\n */ function isHexString(value) {\n    return (0, superstruct_1.is)(value, exports.HexStruct);\n}\nexports.isHexString = isHexString;\n/**\n * Strictly check if a string is a valid hex string. A valid hex string must\n * start with the \"0x\"-prefix.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex string.\n */ function isStrictHexString(value) {\n    return (0, superstruct_1.is)(value, exports.StrictHexStruct);\n}\nexports.isStrictHexString = isStrictHexString;\n/**\n * Assert that a value is a valid hex string.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid hex string.\n */ function assertIsHexString(value) {\n    (0, assert_1.assert)(isHexString(value), \"Value must be a hexadecimal string.\");\n}\nexports.assertIsHexString = assertIsHexString;\n/**\n * Assert that a value is a valid hex string. A valid hex string must start with\n * the \"0x\"-prefix.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid hex string.\n */ function assertIsStrictHexString(value) {\n    (0, assert_1.assert)(isStrictHexString(value), 'Value must be a hexadecimal string, starting with \"0x\".');\n}\nexports.assertIsStrictHexString = assertIsStrictHexString;\n/**\n * Add the `0x`-prefix to a hexadecimal string. If the string already has the\n * prefix, it is returned as-is.\n *\n * @param hexadecimal - The hexadecimal string to add the prefix to.\n * @returns The prefixed hexadecimal string.\n */ function add0x(hexadecimal) {\n    if (hexadecimal.startsWith(\"0x\")) {\n        return hexadecimal;\n    }\n    if (hexadecimal.startsWith(\"0X\")) {\n        return `0x${hexadecimal.substring(2)}`;\n    }\n    return `0x${hexadecimal}`;\n}\nexports.add0x = add0x;\n/**\n * Remove the `0x`-prefix from a hexadecimal string. If the string doesn't have\n * the prefix, it is returned as-is.\n *\n * @param hexadecimal - The hexadecimal string to remove the prefix from.\n * @returns The un-prefixed hexadecimal string.\n */ function remove0x(hexadecimal) {\n    if (hexadecimal.startsWith(\"0x\") || hexadecimal.startsWith(\"0X\")) {\n        return hexadecimal.substring(2);\n    }\n    return hexadecimal;\n}\nexports.remove0x = remove0x; //# sourceMappingURL=hex.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2hleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZ0JBQWdCLEdBQUdBLGFBQWEsR0FBR0EsK0JBQStCLEdBQUdBLHlCQUF5QixHQUFHQSx5QkFBeUIsR0FBR0EsbUJBQW1CLEdBQUdBLHVCQUF1QixHQUFHQSxpQkFBaUIsR0FBRyxLQUFLO0FBQ3RNLE1BQU1VLGdCQUFnQkMsbUJBQU9BLENBQUMsb0VBQWE7QUFDM0MsTUFBTUMsV0FBV0QsbUJBQU9BLENBQUMsb0dBQVU7QUFDbkNYLGlCQUFpQixHQUFHLENBQUMsR0FBR1UsY0FBY0csT0FBTyxFQUFFLENBQUMsR0FBR0gsY0FBY0ksTUFBTSxLQUFLO0FBQzVFZCx1QkFBdUIsR0FBRyxDQUFDLEdBQUdVLGNBQWNHLE9BQU8sRUFBRSxDQUFDLEdBQUdILGNBQWNJLE1BQU0sS0FBSztBQUNsRjs7Ozs7Q0FLQyxHQUNELFNBQVNQLFlBQVlOLEtBQUs7SUFDdEIsT0FBTyxDQUFDLEdBQUdTLGNBQWNLLEVBQUUsRUFBRWQsT0FBT0QsUUFBUVMsU0FBUztBQUN6RDtBQUNBVCxtQkFBbUIsR0FBR087QUFDdEI7Ozs7OztDQU1DLEdBQ0QsU0FBU0Qsa0JBQWtCTCxLQUFLO0lBQzVCLE9BQU8sQ0FBQyxHQUFHUyxjQUFjSyxFQUFFLEVBQUVkLE9BQU9ELFFBQVFRLGVBQWU7QUFDL0Q7QUFDQVIseUJBQXlCLEdBQUdNO0FBQzVCOzs7OztDQUtDLEdBQ0QsU0FBU0Qsa0JBQWtCSixLQUFLO0lBQzNCLElBQUdXLFNBQVNJLE1BQU0sRUFBRVQsWUFBWU4sUUFBUTtBQUM3QztBQUNBRCx5QkFBeUIsR0FBR0s7QUFDNUI7Ozs7OztDQU1DLEdBQ0QsU0FBU0Qsd0JBQXdCSCxLQUFLO0lBQ2pDLElBQUdXLFNBQVNJLE1BQU0sRUFBRVYsa0JBQWtCTCxRQUFRO0FBQ25EO0FBQ0FELCtCQUErQixHQUFHSTtBQUNsQzs7Ozs7O0NBTUMsR0FDRCxTQUFTRCxNQUFNYyxXQUFXO0lBQ3RCLElBQUlBLFlBQVlDLFVBQVUsQ0FBQyxPQUFPO1FBQzlCLE9BQU9EO0lBQ1g7SUFDQSxJQUFJQSxZQUFZQyxVQUFVLENBQUMsT0FBTztRQUM5QixPQUFPLENBQUMsRUFBRSxFQUFFRCxZQUFZRSxTQUFTLENBQUMsR0FBRyxDQUFDO0lBQzFDO0lBQ0EsT0FBTyxDQUFDLEVBQUUsRUFBRUYsWUFBWSxDQUFDO0FBQzdCO0FBQ0FqQixhQUFhLEdBQUdHO0FBQ2hCOzs7Ozs7Q0FNQyxHQUNELFNBQVNELFNBQVNlLFdBQVc7SUFDekIsSUFBSUEsWUFBWUMsVUFBVSxDQUFDLFNBQVNELFlBQVlDLFVBQVUsQ0FBQyxPQUFPO1FBQzlELE9BQU9ELFlBQVlFLFNBQVMsQ0FBQztJQUNqQztJQUNBLE9BQU9GO0FBQ1g7QUFDQWpCLGdCQUFnQixHQUFHRSxVQUNuQiwrQkFBK0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac2UtMi9uZXh0anMvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2hleC5qcz9jNTJlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZW1vdmUweCA9IGV4cG9ydHMuYWRkMHggPSBleHBvcnRzLmFzc2VydElzU3RyaWN0SGV4U3RyaW5nID0gZXhwb3J0cy5hc3NlcnRJc0hleFN0cmluZyA9IGV4cG9ydHMuaXNTdHJpY3RIZXhTdHJpbmcgPSBleHBvcnRzLmlzSGV4U3RyaW5nID0gZXhwb3J0cy5TdHJpY3RIZXhTdHJ1Y3QgPSBleHBvcnRzLkhleFN0cnVjdCA9IHZvaWQgMDtcbmNvbnN0IHN1cGVyc3RydWN0XzEgPSByZXF1aXJlKFwic3VwZXJzdHJ1Y3RcIik7XG5jb25zdCBhc3NlcnRfMSA9IHJlcXVpcmUoXCIuL2Fzc2VydFwiKTtcbmV4cG9ydHMuSGV4U3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEucGF0dGVybikoKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCAvXig/OjB4KT9bMC05YS1mXSskL2l1KTtcbmV4cG9ydHMuU3RyaWN0SGV4U3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEucGF0dGVybikoKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCAvXjB4WzAtOWEtZl0rJC9pdSk7XG4vKipcbiAqIENoZWNrIGlmIGEgc3RyaW5nIGlzIGEgdmFsaWQgaGV4IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIHZhbGlkIGhleCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGlzSGV4U3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2YWx1ZSwgZXhwb3J0cy5IZXhTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc0hleFN0cmluZyA9IGlzSGV4U3RyaW5nO1xuLyoqXG4gKiBTdHJpY3RseSBjaGVjayBpZiBhIHN0cmluZyBpcyBhIHZhbGlkIGhleCBzdHJpbmcuIEEgdmFsaWQgaGV4IHN0cmluZyBtdXN0XG4gKiBzdGFydCB3aXRoIHRoZSBcIjB4XCItcHJlZml4LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgdmFsaWQgaGV4IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpY3RIZXhTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLlN0cmljdEhleFN0cnVjdCk7XG59XG5leHBvcnRzLmlzU3RyaWN0SGV4U3RyaW5nID0gaXNTdHJpY3RIZXhTdHJpbmc7XG4vKipcbiAqIEFzc2VydCB0aGF0IGEgdmFsdWUgaXMgYSB2YWxpZCBoZXggc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEB0aHJvd3MgSWYgdGhlIHZhbHVlIGlzIG5vdCBhIHZhbGlkIGhleCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzSGV4U3RyaW5nKHZhbHVlKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoaXNIZXhTdHJpbmcodmFsdWUpLCAnVmFsdWUgbXVzdCBiZSBhIGhleGFkZWNpbWFsIHN0cmluZy4nKTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNIZXhTdHJpbmcgPSBhc3NlcnRJc0hleFN0cmluZztcbi8qKlxuICogQXNzZXJ0IHRoYXQgYSB2YWx1ZSBpcyBhIHZhbGlkIGhleCBzdHJpbmcuIEEgdmFsaWQgaGV4IHN0cmluZyBtdXN0IHN0YXJ0IHdpdGhcbiAqIHRoZSBcIjB4XCItcHJlZml4LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEB0aHJvd3MgSWYgdGhlIHZhbHVlIGlzIG5vdCBhIHZhbGlkIGhleCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzU3RyaWN0SGV4U3RyaW5nKHZhbHVlKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoaXNTdHJpY3RIZXhTdHJpbmcodmFsdWUpLCAnVmFsdWUgbXVzdCBiZSBhIGhleGFkZWNpbWFsIHN0cmluZywgc3RhcnRpbmcgd2l0aCBcIjB4XCIuJyk7XG59XG5leHBvcnRzLmFzc2VydElzU3RyaWN0SGV4U3RyaW5nID0gYXNzZXJ0SXNTdHJpY3RIZXhTdHJpbmc7XG4vKipcbiAqIEFkZCB0aGUgYDB4YC1wcmVmaXggdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuIElmIHRoZSBzdHJpbmcgYWxyZWFkeSBoYXMgdGhlXG4gKiBwcmVmaXgsIGl0IGlzIHJldHVybmVkIGFzLWlzLlxuICpcbiAqIEBwYXJhbSBoZXhhZGVjaW1hbCAtIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYWRkIHRoZSBwcmVmaXggdG8uXG4gKiBAcmV0dXJucyBUaGUgcHJlZml4ZWQgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBhZGQweChoZXhhZGVjaW1hbCkge1xuICAgIGlmIChoZXhhZGVjaW1hbC5zdGFydHNXaXRoKCcweCcpKSB7XG4gICAgICAgIHJldHVybiBoZXhhZGVjaW1hbDtcbiAgICB9XG4gICAgaWYgKGhleGFkZWNpbWFsLnN0YXJ0c1dpdGgoJzBYJykpIHtcbiAgICAgICAgcmV0dXJuIGAweCR7aGV4YWRlY2ltYWwuc3Vic3RyaW5nKDIpfWA7XG4gICAgfVxuICAgIHJldHVybiBgMHgke2hleGFkZWNpbWFsfWA7XG59XG5leHBvcnRzLmFkZDB4ID0gYWRkMHg7XG4vKipcbiAqIFJlbW92ZSB0aGUgYDB4YC1wcmVmaXggZnJvbSBhIGhleGFkZWNpbWFsIHN0cmluZy4gSWYgdGhlIHN0cmluZyBkb2Vzbid0IGhhdmVcbiAqIHRoZSBwcmVmaXgsIGl0IGlzIHJldHVybmVkIGFzLWlzLlxuICpcbiAqIEBwYXJhbSBoZXhhZGVjaW1hbCAtIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gcmVtb3ZlIHRoZSBwcmVmaXggZnJvbS5cbiAqIEByZXR1cm5zIFRoZSB1bi1wcmVmaXhlZCBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZTB4KGhleGFkZWNpbWFsKSB7XG4gICAgaWYgKGhleGFkZWNpbWFsLnN0YXJ0c1dpdGgoJzB4JykgfHwgaGV4YWRlY2ltYWwuc3RhcnRzV2l0aCgnMFgnKSkge1xuICAgICAgICByZXR1cm4gaGV4YWRlY2ltYWwuc3Vic3RyaW5nKDIpO1xuICAgIH1cbiAgICByZXR1cm4gaGV4YWRlY2ltYWw7XG59XG5leHBvcnRzLnJlbW92ZTB4ID0gcmVtb3ZlMHg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZXguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwicmVtb3ZlMHgiLCJhZGQweCIsImFzc2VydElzU3RyaWN0SGV4U3RyaW5nIiwiYXNzZXJ0SXNIZXhTdHJpbmciLCJpc1N0cmljdEhleFN0cmluZyIsImlzSGV4U3RyaW5nIiwiU3RyaWN0SGV4U3RydWN0IiwiSGV4U3RydWN0Iiwic3VwZXJzdHJ1Y3RfMSIsInJlcXVpcmUiLCJhc3NlcnRfMSIsInBhdHRlcm4iLCJzdHJpbmciLCJpcyIsImFzc2VydCIsImhleGFkZWNpbWFsIiwic3RhcnRzV2l0aCIsInN1YnN0cmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/hex.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/index.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __exportStar = this && this.__exportStar || function(m, exports1) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n__exportStar(__webpack_require__(/*! ./assert */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/assert.js\"), exports);\n__exportStar(__webpack_require__(/*! ./base64 */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/base64.js\"), exports);\n__exportStar(__webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/bytes.js\"), exports);\n__exportStar(__webpack_require__(/*! ./checksum */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/checksum.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coercers */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/coercers.js\"), exports);\n__exportStar(__webpack_require__(/*! ./collections */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/collections.js\"), exports);\n__exportStar(__webpack_require__(/*! ./encryption-types */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/encryption-types.js\"), exports);\n__exportStar(__webpack_require__(/*! ./hex */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/hex.js\"), exports);\n__exportStar(__webpack_require__(/*! ./json */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/json.js\"), exports);\n__exportStar(__webpack_require__(/*! ./keyring */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/keyring.js\"), exports);\n__exportStar(__webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/logging.js\"), exports);\n__exportStar(__webpack_require__(/*! ./misc */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/misc.js\"), exports);\n__exportStar(__webpack_require__(/*! ./number */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/number.js\"), exports);\n__exportStar(__webpack_require__(/*! ./opaque */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/opaque.js\"), exports);\n__exportStar(__webpack_require__(/*! ./time */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/time.js\"), exports);\n__exportStar(__webpack_require__(/*! ./transaction-types */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/transaction-types.js\"), exports);\n__exportStar(__webpack_require__(/*! ./versions */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/versions.js\"), exports); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLElBQUssSUFBSSxJQUFJLENBQUNBLGVBQWUsSUFBTUMsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDMUYsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0IsSUFBSUcsT0FBT1AsT0FBT1Esd0JBQXdCLENBQUNMLEdBQUdDO0lBQzlDLElBQUksQ0FBQ0csUUFBUyxVQUFTQSxPQUFPLENBQUNKLEVBQUVNLFVBQVUsR0FBR0YsS0FBS0csUUFBUSxJQUFJSCxLQUFLSSxZQUFZLEdBQUc7UUFDakZKLE9BQU87WUFBRUssWUFBWTtZQUFNQyxLQUFLO2dCQUFhLE9BQU9WLENBQUMsQ0FBQ0MsRUFBRTtZQUFFO1FBQUU7SUFDOUQ7SUFDQUosT0FBT2MsY0FBYyxDQUFDWixHQUFHRyxJQUFJRTtBQUNqQyxJQUFNLFNBQVNMLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDdEIsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0JGLENBQUMsQ0FBQ0csR0FBRyxHQUFHRixDQUFDLENBQUNDLEVBQUU7QUFDaEIsQ0FBQztBQUNELElBQUlXLGVBQWUsSUFBSyxJQUFJLElBQUksQ0FBQ0EsWUFBWSxJQUFLLFNBQVNaLENBQUMsRUFBRWEsUUFBTztJQUNqRSxJQUFLLElBQUlDLEtBQUtkLEVBQUcsSUFBSWMsTUFBTSxhQUFhLENBQUNqQixPQUFPa0IsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0osVUFBU0MsSUFBSWxCLGdCQUFnQmlCLFVBQVNiLEdBQUdjO0FBQzNIO0FBQ0FqQiw4Q0FBNkM7SUFBRXFCLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0ROLGFBQWFPLG1CQUFPQSxDQUFDLG9HQUFVLEdBQUdOO0FBQ2xDRCxhQUFhTyxtQkFBT0EsQ0FBQyxvR0FBVSxHQUFHTjtBQUNsQ0QsYUFBYU8sbUJBQU9BLENBQUMsa0dBQVMsR0FBR047QUFDakNELGFBQWFPLG1CQUFPQSxDQUFDLHdHQUFZLEdBQUdOO0FBQ3BDRCxhQUFhTyxtQkFBT0EsQ0FBQyx3R0FBWSxHQUFHTjtBQUNwQ0QsYUFBYU8sbUJBQU9BLENBQUMsOEdBQWUsR0FBR047QUFDdkNELGFBQWFPLG1CQUFPQSxDQUFDLHdIQUFvQixHQUFHTjtBQUM1Q0QsYUFBYU8sbUJBQU9BLENBQUMsOEZBQU8sR0FBR047QUFDL0JELGFBQWFPLG1CQUFPQSxDQUFDLGdHQUFRLEdBQUdOO0FBQ2hDRCxhQUFhTyxtQkFBT0EsQ0FBQyxzR0FBVyxHQUFHTjtBQUNuQ0QsYUFBYU8sbUJBQU9BLENBQUMsc0dBQVcsR0FBR047QUFDbkNELGFBQWFPLG1CQUFPQSxDQUFDLGdHQUFRLEdBQUdOO0FBQ2hDRCxhQUFhTyxtQkFBT0EsQ0FBQyxvR0FBVSxHQUFHTjtBQUNsQ0QsYUFBYU8sbUJBQU9BLENBQUMsb0dBQVUsR0FBR047QUFDbENELGFBQWFPLG1CQUFPQSxDQUFDLGdHQUFRLEdBQUdOO0FBQ2hDRCxhQUFhTyxtQkFBT0EsQ0FBQywwSEFBcUIsR0FBR047QUFDN0NELGFBQWFPLG1CQUFPQSxDQUFDLHdHQUFZLEdBQUdOLFVBQ3BDLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BzZS0yL25leHRqcy8uL25vZGVfbW9kdWxlcy9ldGgtYmxvY2stdHJhY2tlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvaW5kZXguanM/MGNlMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Fzc2VydFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYmFzZTY0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ieXRlc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY2hlY2tzdW1cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvZXJjZXJzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb2xsZWN0aW9uc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZW5jcnlwdGlvbi10eXBlc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaGV4XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9qc29uXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9rZXlyaW5nXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9sb2dnaW5nXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9taXNjXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9udW1iZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL29wYXF1ZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdGltZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHJhbnNhY3Rpb24tdHlwZXNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZlcnNpb25zXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJfX2NyZWF0ZUJpbmRpbmciLCJPYmplY3QiLCJjcmVhdGUiLCJvIiwibSIsImsiLCJrMiIsInVuZGVmaW5lZCIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfX2VzTW9kdWxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZGVmaW5lUHJvcGVydHkiLCJfX2V4cG9ydFN0YXIiLCJleHBvcnRzIiwicCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsInZhbHVlIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/json.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/json.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getJsonRpcIdValidator = exports.assertIsJsonRpcError = exports.isJsonRpcError = exports.assertIsJsonRpcFailure = exports.isJsonRpcFailure = exports.assertIsJsonRpcSuccess = exports.isJsonRpcSuccess = exports.assertIsJsonRpcResponse = exports.isJsonRpcResponse = exports.assertIsPendingJsonRpcResponse = exports.isPendingJsonRpcResponse = exports.JsonRpcResponseStruct = exports.JsonRpcFailureStruct = exports.JsonRpcSuccessStruct = exports.PendingJsonRpcResponseStruct = exports.assertIsJsonRpcRequest = exports.isJsonRpcRequest = exports.assertIsJsonRpcNotification = exports.isJsonRpcNotification = exports.JsonRpcNotificationStruct = exports.JsonRpcRequestStruct = exports.JsonRpcParamsStruct = exports.JsonRpcErrorStruct = exports.JsonRpcIdStruct = exports.JsonRpcVersionStruct = exports.jsonrpc2 = exports.getJsonSize = exports.isValidJson = exports.JsonStruct = exports.UnsafeJsonStruct = void 0;\nconst superstruct_1 = __webpack_require__(/*! superstruct */ \"(ssr)/./node_modules/superstruct/dist/index.mjs\");\nconst assert_1 = __webpack_require__(/*! ./assert */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/assert.js\");\n/**\n * A struct to check if the given value is finite number. Superstruct's\n * `number()` struct does not check if the value is finite.\n *\n * @returns A struct to check if the given value is finite number.\n */ const finiteNumber = ()=>(0, superstruct_1.define)(\"finite number\", (value)=>{\n        return (0, superstruct_1.is)(value, (0, superstruct_1.number)()) && Number.isFinite(value);\n    });\n/**\n * A struct to check if the given value is a valid JSON-serializable value.\n *\n * Note that this struct is unsafe. For safe validation, use {@link JsonStruct}.\n */ // We cannot infer the type of the struct, because it is recursive.\nexports.UnsafeJsonStruct = (0, superstruct_1.union)([\n    (0, superstruct_1.literal)(null),\n    (0, superstruct_1.boolean)(),\n    finiteNumber(),\n    (0, superstruct_1.string)(),\n    (0, superstruct_1.array)((0, superstruct_1.lazy)(()=>exports.UnsafeJsonStruct)),\n    (0, superstruct_1.record)((0, superstruct_1.string)(), (0, superstruct_1.lazy)(()=>exports.UnsafeJsonStruct))\n]);\n/**\n * A struct to check if the given value is a valid JSON-serializable value.\n *\n * This struct sanitizes the value before validating it, so that it is safe to\n * use with untrusted input.\n */ exports.JsonStruct = (0, superstruct_1.define)(\"Json\", (value, context)=>{\n    /**\n     * Helper function that runs the given struct validator and returns the\n     * validation errors, if any. If the value is valid, it returns `true`.\n     *\n     * @param innerValue - The value to validate.\n     * @param struct - The struct to use for validation.\n     * @returns The validation errors, or `true` if the value is valid.\n     */ function checkStruct(innerValue, struct) {\n        const iterator = struct.validator(innerValue, context);\n        const errors = [\n            ...iterator\n        ];\n        if (errors.length > 0) {\n            return errors;\n        }\n        return true;\n    }\n    try {\n        // The plain value must be a valid JSON value, but it may be altered in the\n        // process of JSON serialization, so we need to validate it again after\n        // serialization. This has the added benefit that the returned error messages\n        // will be more helpful, as they will point to the exact location of the\n        // invalid value.\n        //\n        // This seems overcomplicated, but without checking the plain value first,\n        // there are some cases where the validation passes, even though the value is\n        // not valid JSON. For example, `undefined` is not valid JSON, but serializing\n        // it will remove it from the object, so the validation will pass.\n        const unsafeResult = checkStruct(value, exports.UnsafeJsonStruct);\n        if (unsafeResult !== true) {\n            return unsafeResult;\n        }\n        // JavaScript engines are highly optimized for this specific use case of\n        // JSON parsing and stringifying, so there should be no performance impact.\n        return checkStruct(JSON.parse(JSON.stringify(value)), exports.UnsafeJsonStruct);\n    } catch (error) {\n        if (error instanceof RangeError) {\n            return \"Circular reference detected\";\n        }\n        return false;\n    }\n});\n/**\n * Check if the given value is a valid {@link Json} value, i.e., a value that is\n * serializable to JSON.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid {@link Json} value.\n */ function isValidJson(value) {\n    return (0, superstruct_1.is)(value, exports.JsonStruct);\n}\nexports.isValidJson = isValidJson;\n/**\n * Get the size of a JSON value in bytes. This also validates the value.\n *\n * @param value - The JSON value to get the size of.\n * @returns The size of the JSON value in bytes.\n */ function getJsonSize(value) {\n    (0, assert_1.assertStruct)(value, exports.JsonStruct, \"Invalid JSON value\");\n    const json = JSON.stringify(value);\n    return new TextEncoder().encode(json).byteLength;\n}\nexports.getJsonSize = getJsonSize;\n/**\n * The string '2.0'.\n */ exports.jsonrpc2 = \"2.0\";\nexports.JsonRpcVersionStruct = (0, superstruct_1.literal)(exports.jsonrpc2);\nexports.JsonRpcIdStruct = (0, superstruct_1.nullable)((0, superstruct_1.union)([\n    (0, superstruct_1.number)(),\n    (0, superstruct_1.string)()\n]));\nexports.JsonRpcErrorStruct = (0, superstruct_1.object)({\n    code: (0, superstruct_1.integer)(),\n    message: (0, superstruct_1.string)(),\n    data: (0, superstruct_1.optional)(exports.JsonStruct),\n    stack: (0, superstruct_1.optional)((0, superstruct_1.string)())\n});\nexports.JsonRpcParamsStruct = (0, superstruct_1.optional)((0, superstruct_1.union)([\n    (0, superstruct_1.record)((0, superstruct_1.string)(), exports.JsonStruct),\n    (0, superstruct_1.array)(exports.JsonStruct)\n]));\nexports.JsonRpcRequestStruct = (0, superstruct_1.object)({\n    id: exports.JsonRpcIdStruct,\n    jsonrpc: exports.JsonRpcVersionStruct,\n    method: (0, superstruct_1.string)(),\n    params: exports.JsonRpcParamsStruct\n});\nexports.JsonRpcNotificationStruct = (0, superstruct_1.omit)(exports.JsonRpcRequestStruct, [\n    \"id\"\n]);\n/**\n * Check if the given value is a valid {@link JsonRpcNotification} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcNotification}\n * object.\n */ function isJsonRpcNotification(value) {\n    return (0, superstruct_1.is)(value, exports.JsonRpcNotificationStruct);\n}\nexports.isJsonRpcNotification = isJsonRpcNotification;\n/**\n * Assert that the given value is a valid {@link JsonRpcNotification} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcNotification} object.\n */ function assertIsJsonRpcNotification(value, // eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcNotificationStruct, \"Invalid JSON-RPC notification\", ErrorWrapper);\n}\nexports.assertIsJsonRpcNotification = assertIsJsonRpcNotification;\n/**\n * Check if the given value is a valid {@link JsonRpcRequest} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcRequest} object.\n */ function isJsonRpcRequest(value) {\n    return (0, superstruct_1.is)(value, exports.JsonRpcRequestStruct);\n}\nexports.isJsonRpcRequest = isJsonRpcRequest;\n/**\n * Assert that the given value is a valid {@link JsonRpcRequest} object.\n *\n * @param value - The JSON-RPC request or notification to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcRequest} object.\n */ function assertIsJsonRpcRequest(value, // eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcRequestStruct, \"Invalid JSON-RPC request\", ErrorWrapper);\n}\nexports.assertIsJsonRpcRequest = assertIsJsonRpcRequest;\nexports.PendingJsonRpcResponseStruct = (0, superstruct_1.object)({\n    id: exports.JsonRpcIdStruct,\n    jsonrpc: exports.JsonRpcVersionStruct,\n    result: (0, superstruct_1.optional)((0, superstruct_1.unknown)()),\n    error: (0, superstruct_1.optional)(exports.JsonRpcErrorStruct)\n});\nexports.JsonRpcSuccessStruct = (0, superstruct_1.object)({\n    id: exports.JsonRpcIdStruct,\n    jsonrpc: exports.JsonRpcVersionStruct,\n    result: exports.JsonStruct\n});\nexports.JsonRpcFailureStruct = (0, superstruct_1.object)({\n    id: exports.JsonRpcIdStruct,\n    jsonrpc: exports.JsonRpcVersionStruct,\n    error: exports.JsonRpcErrorStruct\n});\nexports.JsonRpcResponseStruct = (0, superstruct_1.union)([\n    exports.JsonRpcSuccessStruct,\n    exports.JsonRpcFailureStruct\n]);\n/**\n * Type guard to check whether specified JSON-RPC response is a\n * {@link PendingJsonRpcResponse}.\n *\n * @param response - The JSON-RPC response to check.\n * @returns Whether the specified JSON-RPC response is pending.\n */ function isPendingJsonRpcResponse(response) {\n    return (0, superstruct_1.is)(response, exports.PendingJsonRpcResponseStruct);\n}\nexports.isPendingJsonRpcResponse = isPendingJsonRpcResponse;\n/**\n * Assert that the given value is a valid {@link PendingJsonRpcResponse} object.\n *\n * @param response - The JSON-RPC response to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link PendingJsonRpcResponse}\n * object.\n */ function assertIsPendingJsonRpcResponse(response, // eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(response, exports.PendingJsonRpcResponseStruct, \"Invalid pending JSON-RPC response\", ErrorWrapper);\n}\nexports.assertIsPendingJsonRpcResponse = assertIsPendingJsonRpcResponse;\n/**\n * Type guard to check if a value is a {@link JsonRpcResponse}.\n *\n * @param response - The object to check.\n * @returns Whether the object is a JsonRpcResponse.\n */ function isJsonRpcResponse(response) {\n    return (0, superstruct_1.is)(response, exports.JsonRpcResponseStruct);\n}\nexports.isJsonRpcResponse = isJsonRpcResponse;\n/**\n * Assert that the given value is a valid {@link JsonRpcResponse} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcResponse} object.\n */ function assertIsJsonRpcResponse(value, // eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcResponseStruct, \"Invalid JSON-RPC response\", ErrorWrapper);\n}\nexports.assertIsJsonRpcResponse = assertIsJsonRpcResponse;\n/**\n * Check if the given value is a valid {@link JsonRpcSuccess} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcSuccess} object.\n */ function isJsonRpcSuccess(value) {\n    return (0, superstruct_1.is)(value, exports.JsonRpcSuccessStruct);\n}\nexports.isJsonRpcSuccess = isJsonRpcSuccess;\n/**\n * Assert that the given value is a valid {@link JsonRpcSuccess} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcSuccess} object.\n */ function assertIsJsonRpcSuccess(value, // eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcSuccessStruct, \"Invalid JSON-RPC success response\", ErrorWrapper);\n}\nexports.assertIsJsonRpcSuccess = assertIsJsonRpcSuccess;\n/**\n * Check if the given value is a valid {@link JsonRpcFailure} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcFailure} object.\n */ function isJsonRpcFailure(value) {\n    return (0, superstruct_1.is)(value, exports.JsonRpcFailureStruct);\n}\nexports.isJsonRpcFailure = isJsonRpcFailure;\n/**\n * Assert that the given value is a valid {@link JsonRpcFailure} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcFailure} object.\n */ function assertIsJsonRpcFailure(value, // eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcFailureStruct, \"Invalid JSON-RPC failure response\", ErrorWrapper);\n}\nexports.assertIsJsonRpcFailure = assertIsJsonRpcFailure;\n/**\n * Check if the given value is a valid {@link JsonRpcError} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcError} object.\n */ function isJsonRpcError(value) {\n    return (0, superstruct_1.is)(value, exports.JsonRpcErrorStruct);\n}\nexports.isJsonRpcError = isJsonRpcError;\n/**\n * Assert that the given value is a valid {@link JsonRpcError} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcError} object.\n */ function assertIsJsonRpcError(value, // eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcErrorStruct, \"Invalid JSON-RPC error\", ErrorWrapper);\n}\nexports.assertIsJsonRpcError = assertIsJsonRpcError;\n/**\n * Gets a function for validating JSON-RPC request / response `id` values.\n *\n * By manipulating the options of this factory, you can control the behavior\n * of the resulting validator for some edge cases. This is useful because e.g.\n * `null` should sometimes but not always be permitted.\n *\n * Note that the empty string (`''`) is always permitted by the JSON-RPC\n * specification, but that kind of sucks and you may want to forbid it in some\n * instances anyway.\n *\n * For more details, see the\n * [JSON-RPC Specification](https://www.jsonrpc.org/specification).\n *\n * @param options - An options object.\n * @param options.permitEmptyString - Whether the empty string (i.e. `''`)\n * should be treated as a valid ID. Default: `true`\n * @param options.permitFractions - Whether fractional numbers (e.g. `1.2`)\n * should be treated as valid IDs. Default: `false`\n * @param options.permitNull - Whether `null` should be treated as a valid ID.\n * Default: `true`\n * @returns The JSON-RPC ID validator function.\n */ function getJsonRpcIdValidator(options) {\n    const { permitEmptyString, permitFractions, permitNull } = Object.assign({\n        permitEmptyString: true,\n        permitFractions: false,\n        permitNull: true\n    }, options);\n    /**\n     * Type guard for {@link JsonRpcId}.\n     *\n     * @param id - The JSON-RPC ID value to check.\n     * @returns Whether the given ID is valid per the options given to the\n     * factory.\n     */ const isValidJsonRpcId = (id)=>{\n        return Boolean(typeof id === \"number\" && (permitFractions || Number.isInteger(id)) || typeof id === \"string\" && (permitEmptyString || id.length > 0) || permitNull && id === null);\n    };\n    return isValidJsonRpcId;\n}\nexports.getJsonRpcIdValidator = getJsonRpcIdValidator; //# sourceMappingURL=json.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2pzb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDZCQUE2QixHQUFHQSw0QkFBNEIsR0FBR0Esc0JBQXNCLEdBQUdBLDhCQUE4QixHQUFHQSx3QkFBd0IsR0FBR0EsOEJBQThCLEdBQUdBLHdCQUF3QixHQUFHQSwrQkFBK0IsR0FBR0EseUJBQXlCLEdBQUdBLHNDQUFzQyxHQUFHQSxnQ0FBZ0MsR0FBR0EsNkJBQTZCLEdBQUdBLDRCQUE0QixHQUFHQSw0QkFBNEIsR0FBR0Esb0NBQW9DLEdBQUdBLDhCQUE4QixHQUFHQSx3QkFBd0IsR0FBR0EsbUNBQW1DLEdBQUdBLDZCQUE2QixHQUFHQSxpQ0FBaUMsR0FBR0EsNEJBQTRCLEdBQUdBLDJCQUEyQixHQUFHQSwwQkFBMEIsR0FBR0EsdUJBQXVCLEdBQUdBLDRCQUE0QixHQUFHQSxnQkFBZ0IsR0FBR0EsbUJBQW1CLEdBQUdBLG1CQUFtQixHQUFHQSxrQkFBa0IsR0FBR0Esd0JBQXdCLEdBQUcsS0FBSztBQUM1NEIsTUFBTWdDLGdCQUFnQkMsbUJBQU9BLENBQUMsb0VBQWE7QUFDM0MsTUFBTUMsV0FBV0QsbUJBQU9BLENBQUMsb0dBQVU7QUFDbkM7Ozs7O0NBS0MsR0FDRCxNQUFNRSxlQUFlLElBQU0sQ0FBQyxHQUFHSCxjQUFjSSxNQUFNLEVBQUUsaUJBQWlCLENBQUNuQztRQUNuRSxPQUFPLENBQUMsR0FBRytCLGNBQWNLLEVBQUUsRUFBRXBDLE9BQU8sQ0FBQyxHQUFHK0IsY0FBY00sTUFBTSxRQUFRQyxPQUFPQyxRQUFRLENBQUN2QztJQUN4RjtBQUNBOzs7O0NBSUMsR0FDRCxtRUFBbUU7QUFDbkVELHdCQUF3QixHQUFHLENBQUMsR0FBR2dDLGNBQWNTLEtBQUssRUFBRTtJQUMvQyxJQUFHVCxjQUFj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QUs7SUFDekIsT0FBTyxDQUFDLEdBQUcrQixjQUFjSyxFQUFFLEVBQUVwQyxPQUFPRCxRQUFRd0Isa0JBQWtCO0FBQ2xFO0FBQ0F4QixzQkFBc0IsR0FBR0k7QUFDekI7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNELHFCQUFxQkYsS0FBSyxFQUNuQyxnRUFBZ0U7QUFDaEUrRSxZQUFZO0lBQ1AsSUFBRzlDLFNBQVM0QixZQUFZLEVBQUU3RCxPQUFPRCxRQUFRd0Isa0JBQWtCLEVBQUUsMEJBQTBCd0Q7QUFDNUY7QUFDQWhGLDRCQUE0QixHQUFHRztBQUMvQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXNCQyxHQUNELFNBQVNELHNCQUFzQmtGLE9BQU87SUFDbEMsTUFBTSxFQUFFQyxpQkFBaUIsRUFBRUMsZUFBZSxFQUFFQyxVQUFVLEVBQUUsR0FBR3pGLE9BQU8wRixNQUFNLENBQUM7UUFBRUgsbUJBQW1CO1FBQU1DLGlCQUFpQjtRQUFPQyxZQUFZO0lBQUssR0FBR0g7SUFDaEo7Ozs7OztLQU1DLEdBQ0QsTUFBTUssbUJBQW1CLENBQUNkO1FBQ3RCLE9BQU9lLFFBQVEsT0FBUWYsT0FBTyxZQUFhVyxDQUFBQSxtQkFBbUIvQyxPQUFPb0QsU0FBUyxDQUFDaEIsR0FBRSxLQUM1RSxPQUFPQSxPQUFPLFlBQWFVLENBQUFBLHFCQUFxQlYsR0FBR3BCLE1BQU0sR0FBRyxNQUM1RGdDLGNBQWNaLE9BQU87SUFDOUI7SUFDQSxPQUFPYztBQUNYO0FBQ0F6Riw2QkFBNkIsR0FBR0UsdUJBQ2hDLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BzZS0yL25leHRqcy8uL25vZGVfbW9kdWxlcy9ldGgtYmxvY2stdHJhY2tlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvanNvbi5qcz9iNzNiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRKc29uUnBjSWRWYWxpZGF0b3IgPSBleHBvcnRzLmFzc2VydElzSnNvblJwY0Vycm9yID0gZXhwb3J0cy5pc0pzb25ScGNFcnJvciA9IGV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjRmFpbHVyZSA9IGV4cG9ydHMuaXNKc29uUnBjRmFpbHVyZSA9IGV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjU3VjY2VzcyA9IGV4cG9ydHMuaXNKc29uUnBjU3VjY2VzcyA9IGV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjUmVzcG9uc2UgPSBleHBvcnRzLmlzSnNvblJwY1Jlc3BvbnNlID0gZXhwb3J0cy5hc3NlcnRJc1BlbmRpbmdKc29uUnBjUmVzcG9uc2UgPSBleHBvcnRzLmlzUGVuZGluZ0pzb25ScGNSZXNwb25zZSA9IGV4cG9ydHMuSnNvblJwY1Jlc3BvbnNlU3RydWN0ID0gZXhwb3J0cy5Kc29uUnBjRmFpbHVyZVN0cnVjdCA9IGV4cG9ydHMuSnNvblJwY1N1Y2Nlc3NTdHJ1Y3QgPSBleHBvcnRzLlBlbmRpbmdKc29uUnBjUmVzcG9uc2VTdHJ1Y3QgPSBleHBvcnRzLmFzc2VydElzSnNvblJwY1JlcXVlc3QgPSBleHBvcnRzLmlzSnNvblJwY1JlcXVlc3QgPSBleHBvcnRzLmFzc2VydElzSnNvblJwY05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuaXNKc29uUnBjTm90aWZpY2F0aW9uID0gZXhwb3J0cy5Kc29uUnBjTm90aWZpY2F0aW9uU3RydWN0ID0gZXhwb3J0cy5Kc29uUnBjUmVxdWVzdFN0cnVjdCA9IGV4cG9ydHMuSnNvblJwY1BhcmFtc1N0cnVjdCA9IGV4cG9ydHMuSnNvblJwY0Vycm9yU3RydWN0ID0gZXhwb3J0cy5Kc29uUnBjSWRTdHJ1Y3QgPSBleHBvcnRzLkpzb25ScGNWZXJzaW9uU3RydWN0ID0gZXhwb3J0cy5qc29ucnBjMiA9IGV4cG9ydHMuZ2V0SnNvblNpemUgPSBleHBvcnRzLmlzVmFsaWRKc29uID0gZXhwb3J0cy5Kc29uU3RydWN0ID0gZXhwb3J0cy5VbnNhZmVKc29uU3RydWN0ID0gdm9pZCAwO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJzdXBlcnN0cnVjdFwiKTtcbmNvbnN0IGFzc2VydF8xID0gcmVxdWlyZShcIi4vYXNzZXJ0XCIpO1xuLyoqXG4gKiBBIHN0cnVjdCB0byBjaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgZmluaXRlIG51bWJlci4gU3VwZXJzdHJ1Y3Qnc1xuICogYG51bWJlcigpYCBzdHJ1Y3QgZG9lcyBub3QgY2hlY2sgaWYgdGhlIHZhbHVlIGlzIGZpbml0ZS5cbiAqXG4gKiBAcmV0dXJucyBBIHN0cnVjdCB0byBjaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgZmluaXRlIG51bWJlci5cbiAqL1xuY29uc3QgZmluaXRlTnVtYmVyID0gKCkgPT4gKDAsIHN1cGVyc3RydWN0XzEuZGVmaW5lKSgnZmluaXRlIG51bWJlcicsICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsICgwLCBzdXBlcnN0cnVjdF8xLm51bWJlcikoKSkgJiYgTnVtYmVyLmlzRmluaXRlKHZhbHVlKTtcbn0pO1xuLyoqXG4gKiBBIHN0cnVjdCB0byBjaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCBKU09OLXNlcmlhbGl6YWJsZSB2YWx1ZS5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBzdHJ1Y3QgaXMgdW5zYWZlLiBGb3Igc2FmZSB2YWxpZGF0aW9uLCB1c2Uge0BsaW5rIEpzb25TdHJ1Y3R9LlxuICovXG4vLyBXZSBjYW5ub3QgaW5mZXIgdGhlIHR5cGUgb2YgdGhlIHN0cnVjdCwgYmVjYXVzZSBpdCBpcyByZWN1cnNpdmUuXG5leHBvcnRzLlVuc2FmZUpzb25TdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS51bmlvbikoW1xuICAgICgwLCBzdXBlcnN0cnVjdF8xLmxpdGVyYWwpKG51bGwpLFxuICAgICgwLCBzdXBlcnN0cnVjdF8xLmJvb2xlYW4pKCksXG4gICAgZmluaXRlTnVtYmVyKCksXG4gICAgKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLFxuICAgICgwLCBzdXBlcnN0cnVjdF8xLmFycmF5KSgoMCwgc3VwZXJzdHJ1Y3RfMS5sYXp5KSgoKSA9PiBleHBvcnRzLlVuc2FmZUpzb25TdHJ1Y3QpKSxcbiAgICAoMCwgc3VwZXJzdHJ1Y3RfMS5yZWNvcmQpKCgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSwgKDAsIHN1cGVyc3RydWN0XzEubGF6eSkoKCkgPT4gZXhwb3J0cy5VbnNhZmVKc29uU3RydWN0KSksXG5dKTtcbi8qKlxuICogQSBzdHJ1Y3QgdG8gY2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQgSlNPTi1zZXJpYWxpemFibGUgdmFsdWUuXG4gKlxuICogVGhpcyBzdHJ1Y3Qgc2FuaXRpemVzIHRoZSB2YWx1ZSBiZWZvcmUgdmFsaWRhdGluZyBpdCwgc28gdGhhdCBpdCBpcyBzYWZlIHRvXG4gKiB1c2Ugd2l0aCB1bnRydXN0ZWQgaW5wdXQuXG4gKi9cbmV4cG9ydHMuSnNvblN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLmRlZmluZSkoJ0pzb24nLCAodmFsdWUsIGNvbnRleHQpID0+IHtcbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBydW5zIHRoZSBnaXZlbiBzdHJ1Y3QgdmFsaWRhdG9yIGFuZCByZXR1cm5zIHRoZVxuICAgICAqIHZhbGlkYXRpb24gZXJyb3JzLCBpZiBhbnkuIElmIHRoZSB2YWx1ZSBpcyB2YWxpZCwgaXQgcmV0dXJucyBgdHJ1ZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5uZXJWYWx1ZSAtIFRoZSB2YWx1ZSB0byB2YWxpZGF0ZS5cbiAgICAgKiBAcGFyYW0gc3RydWN0IC0gVGhlIHN0cnVjdCB0byB1c2UgZm9yIHZhbGlkYXRpb24uXG4gICAgICogQHJldHVybnMgVGhlIHZhbGlkYXRpb24gZXJyb3JzLCBvciBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIHZhbGlkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoZWNrU3RydWN0KGlubmVyVmFsdWUsIHN0cnVjdCkge1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHN0cnVjdC52YWxpZGF0b3IoaW5uZXJWYWx1ZSwgY29udGV4dCk7XG4gICAgICAgIGNvbnN0IGVycm9ycyA9IFsuLi5pdGVyYXRvcl07XG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gVGhlIHBsYWluIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBKU09OIHZhbHVlLCBidXQgaXQgbWF5IGJlIGFsdGVyZWQgaW4gdGhlXG4gICAgICAgIC8vIHByb2Nlc3Mgb2YgSlNPTiBzZXJpYWxpemF0aW9uLCBzbyB3ZSBuZWVkIHRvIHZhbGlkYXRlIGl0IGFnYWluIGFmdGVyXG4gICAgICAgIC8vIHNlcmlhbGl6YXRpb24uIFRoaXMgaGFzIHRoZSBhZGRlZCBiZW5lZml0IHRoYXQgdGhlIHJldHVybmVkIGVycm9yIG1lc3NhZ2VzXG4gICAgICAgIC8vIHdpbGwgYmUgbW9yZSBoZWxwZnVsLCBhcyB0aGV5IHdpbGwgcG9pbnQgdG8gdGhlIGV4YWN0IGxvY2F0aW9uIG9mIHRoZVxuICAgICAgICAvLyBpbnZhbGlkIHZhbHVlLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGlzIHNlZW1zIG92ZXJjb21wbGljYXRlZCwgYnV0IHdpdGhvdXQgY2hlY2tpbmcgdGhlIHBsYWluIHZhbHVlIGZpcnN0LFxuICAgICAgICAvLyB0aGVyZSBhcmUgc29tZSBjYXNlcyB3aGVyZSB0aGUgdmFsaWRhdGlvbiBwYXNzZXMsIGV2ZW4gdGhvdWdoIHRoZSB2YWx1ZSBpc1xuICAgICAgICAvLyBub3QgdmFsaWQgSlNPTi4gRm9yIGV4YW1wbGUsIGB1bmRlZmluZWRgIGlzIG5vdCB2YWxpZCBKU09OLCBidXQgc2VyaWFsaXppbmdcbiAgICAgICAgLy8gaXQgd2lsbCByZW1vdmUgaXQgZnJvbSB0aGUgb2JqZWN0LCBzbyB0aGUgdmFsaWRhdGlvbiB3aWxsIHBhc3MuXG4gICAgICAgIGNvbnN0IHVuc2FmZVJlc3VsdCA9IGNoZWNrU3RydWN0KHZhbHVlLCBleHBvcnRzLlVuc2FmZUpzb25TdHJ1Y3QpO1xuICAgICAgICBpZiAodW5zYWZlUmVzdWx0ICE9PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5zYWZlUmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8vIEphdmFTY3JpcHQgZW5naW5lcyBhcmUgaGlnaGx5IG9wdGltaXplZCBmb3IgdGhpcyBzcGVjaWZpYyB1c2UgY2FzZSBvZlxuICAgICAgICAvLyBKU09OIHBhcnNpbmcgYW5kIHN0cmluZ2lmeWluZywgc28gdGhlcmUgc2hvdWxkIGJlIG5vIHBlcmZvcm1hbmNlIGltcGFjdC5cbiAgICAgICAgcmV0dXJuIGNoZWNrU3RydWN0KEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodmFsdWUpKSwgZXhwb3J0cy5VbnNhZmVKc29uU3RydWN0KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFJhbmdlRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiAnQ2lyY3VsYXIgcmVmZXJlbmNlIGRldGVjdGVkJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufSk7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29ufSB2YWx1ZSwgaS5lLiwgYSB2YWx1ZSB0aGF0IGlzXG4gKiBzZXJpYWxpemFibGUgdG8gSlNPTi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29ufSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEpzb24odmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLkpzb25TdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc1ZhbGlkSnNvbiA9IGlzVmFsaWRKc29uO1xuLyoqXG4gKiBHZXQgdGhlIHNpemUgb2YgYSBKU09OIHZhbHVlIGluIGJ5dGVzLiBUaGlzIGFsc28gdmFsaWRhdGVzIHRoZSB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgSlNPTiB2YWx1ZSB0byBnZXQgdGhlIHNpemUgb2YuXG4gKiBAcmV0dXJucyBUaGUgc2l6ZSBvZiB0aGUgSlNPTiB2YWx1ZSBpbiBieXRlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0SnNvblNpemUodmFsdWUpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2YWx1ZSwgZXhwb3J0cy5Kc29uU3RydWN0LCAnSW52YWxpZCBKU09OIHZhbHVlJyk7XG4gICAgY29uc3QganNvbiA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICByZXR1cm4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKGpzb24pLmJ5dGVMZW5ndGg7XG59XG5leHBvcnRzLmdldEpzb25TaXplID0gZ2V0SnNvblNpemU7XG4vKipcbiAqIFRoZSBzdHJpbmcgJzIuMCcuXG4gKi9cbmV4cG9ydHMuanNvbnJwYzIgPSAnMi4wJztcbmV4cG9ydHMuSnNvblJwY1ZlcnNpb25TdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5saXRlcmFsKShleHBvcnRzLmpzb25ycGMyKTtcbmV4cG9ydHMuSnNvblJwY0lkU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEubnVsbGFibGUpKCgwLCBzdXBlcnN0cnVjdF8xLnVuaW9uKShbKDAsIHN1cGVyc3RydWN0XzEubnVtYmVyKSgpLCAoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCldKSk7XG5leHBvcnRzLkpzb25ScGNFcnJvclN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLm9iamVjdCkoe1xuICAgIGNvZGU6ICgwLCBzdXBlcnN0cnVjdF8xLmludGVnZXIpKCksXG4gICAgbWVzc2FnZTogKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLFxuICAgIGRhdGE6ICgwLCBzdXBlcnN0cnVjdF8xLm9wdGlvbmFsKShleHBvcnRzLkpzb25TdHJ1Y3QpLFxuICAgIHN0YWNrOiAoMCwgc3VwZXJzdHJ1Y3RfMS5vcHRpb25hbCkoKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpKSxcbn0pO1xuZXhwb3J0cy5Kc29uUnBjUGFyYW1zU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEub3B0aW9uYWwpKCgwLCBzdXBlcnN0cnVjdF8xLnVuaW9uKShbKDAsIHN1cGVyc3RydWN0XzEucmVjb3JkKSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksIGV4cG9ydHMuSnNvblN0cnVjdCksICgwLCBzdXBlcnN0cnVjdF8xLmFycmF5KShleHBvcnRzLkpzb25TdHJ1Y3QpXSkpO1xuZXhwb3J0cy5Kc29uUnBjUmVxdWVzdFN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLm9iamVjdCkoe1xuICAgIGlkOiBleHBvcnRzLkpzb25ScGNJZFN0cnVjdCxcbiAgICBqc29ucnBjOiBleHBvcnRzLkpzb25ScGNWZXJzaW9uU3RydWN0LFxuICAgIG1ldGhvZDogKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLFxuICAgIHBhcmFtczogZXhwb3J0cy5Kc29uUnBjUGFyYW1zU3RydWN0LFxufSk7XG5leHBvcnRzLkpzb25ScGNOb3RpZmljYXRpb25TdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5vbWl0KShleHBvcnRzLkpzb25ScGNSZXF1ZXN0U3RydWN0LCBbJ2lkJ10pO1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY05vdGlmaWNhdGlvbn0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNOb3RpZmljYXRpb259XG4gKiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzSnNvblJwY05vdGlmaWNhdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsIGV4cG9ydHMuSnNvblJwY05vdGlmaWNhdGlvblN0cnVjdCk7XG59XG5leHBvcnRzLmlzSnNvblJwY05vdGlmaWNhdGlvbiA9IGlzSnNvblJwY05vdGlmaWNhdGlvbjtcbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNOb3RpZmljYXRpb259IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHRocm93IGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9LlxuICogQHRocm93cyBJZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgdmFsaWQge0BsaW5rIEpzb25ScGNOb3RpZmljYXRpb259IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjTm90aWZpY2F0aW9uKHZhbHVlLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlcikge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNOb3RpZmljYXRpb25TdHJ1Y3QsICdJbnZhbGlkIEpTT04tUlBDIG5vdGlmaWNhdGlvbicsIEVycm9yV3JhcHBlcik7XG59XG5leHBvcnRzLmFzc2VydElzSnNvblJwY05vdGlmaWNhdGlvbiA9IGFzc2VydElzSnNvblJwY05vdGlmaWNhdGlvbjtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNSZXF1ZXN0fSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1JlcXVlc3R9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaXNKc29uUnBjUmVxdWVzdCh2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsIGV4cG9ydHMuSnNvblJwY1JlcXVlc3RTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc0pzb25ScGNSZXF1ZXN0ID0gaXNKc29uUnBjUmVxdWVzdDtcbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNSZXF1ZXN0fSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIEpTT04tUlBDIHJlcXVlc3Qgb3Igbm90aWZpY2F0aW9uIHRvIGNoZWNrLlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS5cbiAqIEB0aHJvd3MgSWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHtAbGluayBKc29uUnBjUmVxdWVzdH0gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc0pzb25ScGNSZXF1ZXN0KHZhbHVlLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlcikge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNSZXF1ZXN0U3RydWN0LCAnSW52YWxpZCBKU09OLVJQQyByZXF1ZXN0JywgRXJyb3JXcmFwcGVyKTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjUmVxdWVzdCA9IGFzc2VydElzSnNvblJwY1JlcXVlc3Q7XG5leHBvcnRzLlBlbmRpbmdKc29uUnBjUmVzcG9uc2VTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5vYmplY3QpKHtcbiAgICBpZDogZXhwb3J0cy5Kc29uUnBjSWRTdHJ1Y3QsXG4gICAganNvbnJwYzogZXhwb3J0cy5Kc29uUnBjVmVyc2lvblN0cnVjdCxcbiAgICByZXN1bHQ6ICgwLCBzdXBlcnN0cnVjdF8xLm9wdGlvbmFsKSgoMCwgc3VwZXJzdHJ1Y3RfMS51bmtub3duKSgpKSxcbiAgICBlcnJvcjogKDAsIHN1cGVyc3RydWN0XzEub3B0aW9uYWwpKGV4cG9ydHMuSnNvblJwY0Vycm9yU3RydWN0KSxcbn0pO1xuZXhwb3J0cy5Kc29uUnBjU3VjY2Vzc1N0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLm9iamVjdCkoe1xuICAgIGlkOiBleHBvcnRzLkpzb25ScGNJZFN0cnVjdCxcbiAgICBqc29ucnBjOiBleHBvcnRzLkpzb25ScGNWZXJzaW9uU3RydWN0LFxuICAgIHJlc3VsdDogZXhwb3J0cy5Kc29uU3RydWN0LFxufSk7XG5leHBvcnRzLkpzb25ScGNGYWlsdXJlU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEub2JqZWN0KSh7XG4gICAgaWQ6IGV4cG9ydHMuSnNvblJwY0lkU3RydWN0LFxuICAgIGpzb25ycGM6IGV4cG9ydHMuSnNvblJwY1ZlcnNpb25TdHJ1Y3QsXG4gICAgZXJyb3I6IGV4cG9ydHMuSnNvblJwY0Vycm9yU3RydWN0LFxufSk7XG5leHBvcnRzLkpzb25ScGNSZXNwb25zZVN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnVuaW9uKShbXG4gICAgZXhwb3J0cy5Kc29uUnBjU3VjY2Vzc1N0cnVjdCxcbiAgICBleHBvcnRzLkpzb25ScGNGYWlsdXJlU3RydWN0LFxuXSk7XG4vKipcbiAqIFR5cGUgZ3VhcmQgdG8gY2hlY2sgd2hldGhlciBzcGVjaWZpZWQgSlNPTi1SUEMgcmVzcG9uc2UgaXMgYVxuICoge0BsaW5rIFBlbmRpbmdKc29uUnBjUmVzcG9uc2V9LlxuICpcbiAqIEBwYXJhbSByZXNwb25zZSAtIFRoZSBKU09OLVJQQyByZXNwb25zZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHNwZWNpZmllZCBKU09OLVJQQyByZXNwb25zZSBpcyBwZW5kaW5nLlxuICovXG5mdW5jdGlvbiBpc1BlbmRpbmdKc29uUnBjUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHJlc3BvbnNlLCBleHBvcnRzLlBlbmRpbmdKc29uUnBjUmVzcG9uc2VTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc1BlbmRpbmdKc29uUnBjUmVzcG9uc2UgPSBpc1BlbmRpbmdKc29uUnBjUmVzcG9uc2U7XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBQZW5kaW5nSnNvblJwY1Jlc3BvbnNlfSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHJlc3BvbnNlIC0gVGhlIEpTT04tUlBDIHJlc3BvbnNlIHRvIGNoZWNrLlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS5cbiAqIEB0aHJvd3MgSWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHtAbGluayBQZW5kaW5nSnNvblJwY1Jlc3BvbnNlfVxuICogb2JqZWN0LlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc1BlbmRpbmdKc29uUnBjUmVzcG9uc2UocmVzcG9uc2UsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydFN0cnVjdCkocmVzcG9uc2UsIGV4cG9ydHMuUGVuZGluZ0pzb25ScGNSZXNwb25zZVN0cnVjdCwgJ0ludmFsaWQgcGVuZGluZyBKU09OLVJQQyByZXNwb25zZScsIEVycm9yV3JhcHBlcik7XG59XG5leHBvcnRzLmFzc2VydElzUGVuZGluZ0pzb25ScGNSZXNwb25zZSA9IGFzc2VydElzUGVuZGluZ0pzb25ScGNSZXNwb25zZTtcbi8qKlxuICogVHlwZSBndWFyZCB0byBjaGVjayBpZiBhIHZhbHVlIGlzIGEge0BsaW5rIEpzb25ScGNSZXNwb25zZX0uXG4gKlxuICogQHBhcmFtIHJlc3BvbnNlIC0gVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIG9iamVjdCBpcyBhIEpzb25ScGNSZXNwb25zZS5cbiAqL1xuZnVuY3Rpb24gaXNKc29uUnBjUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHJlc3BvbnNlLCBleHBvcnRzLkpzb25ScGNSZXNwb25zZVN0cnVjdCk7XG59XG5leHBvcnRzLmlzSnNvblJwY1Jlc3BvbnNlID0gaXNKc29uUnBjUmVzcG9uc2U7XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjUmVzcG9uc2V9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHRocm93IGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9LlxuICogQHRocm93cyBJZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgdmFsaWQge0BsaW5rIEpzb25ScGNSZXNwb25zZX0gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc0pzb25ScGNSZXNwb25zZSh2YWx1ZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjUmVzcG9uc2VTdHJ1Y3QsICdJbnZhbGlkIEpTT04tUlBDIHJlc3BvbnNlJywgRXJyb3JXcmFwcGVyKTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjUmVzcG9uc2UgPSBhc3NlcnRJc0pzb25ScGNSZXNwb25zZTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNTdWNjZXNzfSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1N1Y2Nlc3N9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaXNKc29uUnBjU3VjY2Vzcyh2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsIGV4cG9ydHMuSnNvblJwY1N1Y2Nlc3NTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc0pzb25ScGNTdWNjZXNzID0gaXNKc29uUnBjU3VjY2Vzcztcbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNTdWNjZXNzfSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS5cbiAqIEB0aHJvd3MgSWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHtAbGluayBKc29uUnBjU3VjY2Vzc30gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc0pzb25ScGNTdWNjZXNzKHZhbHVlLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlcikge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNTdWNjZXNzU3RydWN0LCAnSW52YWxpZCBKU09OLVJQQyBzdWNjZXNzIHJlc3BvbnNlJywgRXJyb3JXcmFwcGVyKTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjU3VjY2VzcyA9IGFzc2VydElzSnNvblJwY1N1Y2Nlc3M7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjRmFpbHVyZX0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNGYWlsdXJlfSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzSnNvblJwY0ZhaWx1cmUodmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNGYWlsdXJlU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNKc29uUnBjRmFpbHVyZSA9IGlzSnNvblJwY0ZhaWx1cmU7XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjRmFpbHVyZX0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0ZhaWx1cmV9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjRmFpbHVyZSh2YWx1ZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjRmFpbHVyZVN0cnVjdCwgJ0ludmFsaWQgSlNPTi1SUEMgZmFpbHVyZSByZXNwb25zZScsIEVycm9yV3JhcHBlcik7XG59XG5leHBvcnRzLmFzc2VydElzSnNvblJwY0ZhaWx1cmUgPSBhc3NlcnRJc0pzb25ScGNGYWlsdXJlO1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0Vycm9yfSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0Vycm9yfSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzSnNvblJwY0Vycm9yKHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjRXJyb3JTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc0pzb25ScGNFcnJvciA9IGlzSnNvblJwY0Vycm9yO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0Vycm9yfSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS5cbiAqIEB0aHJvd3MgSWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHtAbGluayBKc29uUnBjRXJyb3J9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjRXJyb3IodmFsdWUsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydFN0cnVjdCkodmFsdWUsIGV4cG9ydHMuSnNvblJwY0Vycm9yU3RydWN0LCAnSW52YWxpZCBKU09OLVJQQyBlcnJvcicsIEVycm9yV3JhcHBlcik7XG59XG5leHBvcnRzLmFzc2VydElzSnNvblJwY0Vycm9yID0gYXNzZXJ0SXNKc29uUnBjRXJyb3I7XG4vKipcbiAqIEdldHMgYSBmdW5jdGlvbiBmb3IgdmFsaWRhdGluZyBKU09OLVJQQyByZXF1ZXN0IC8gcmVzcG9uc2UgYGlkYCB2YWx1ZXMuXG4gKlxuICogQnkgbWFuaXB1bGF0aW5nIHRoZSBvcHRpb25zIG9mIHRoaXMgZmFjdG9yeSwgeW91IGNhbiBjb250cm9sIHRoZSBiZWhhdmlvclxuICogb2YgdGhlIHJlc3VsdGluZyB2YWxpZGF0b3IgZm9yIHNvbWUgZWRnZSBjYXNlcy4gVGhpcyBpcyB1c2VmdWwgYmVjYXVzZSBlLmcuXG4gKiBgbnVsbGAgc2hvdWxkIHNvbWV0aW1lcyBidXQgbm90IGFsd2F5cyBiZSBwZXJtaXR0ZWQuXG4gKlxuICogTm90ZSB0aGF0IHRoZSBlbXB0eSBzdHJpbmcgKGAnJ2ApIGlzIGFsd2F5cyBwZXJtaXR0ZWQgYnkgdGhlIEpTT04tUlBDXG4gKiBzcGVjaWZpY2F0aW9uLCBidXQgdGhhdCBraW5kIG9mIHN1Y2tzIGFuZCB5b3UgbWF5IHdhbnQgdG8gZm9yYmlkIGl0IGluIHNvbWVcbiAqIGluc3RhbmNlcyBhbnl3YXkuXG4gKlxuICogRm9yIG1vcmUgZGV0YWlscywgc2VlIHRoZVxuICogW0pTT04tUlBDIFNwZWNpZmljYXRpb25dKGh0dHBzOi8vd3d3Lmpzb25ycGMub3JnL3NwZWNpZmljYXRpb24pLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0gb3B0aW9ucy5wZXJtaXRFbXB0eVN0cmluZyAtIFdoZXRoZXIgdGhlIGVtcHR5IHN0cmluZyAoaS5lLiBgJydgKVxuICogc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYSB2YWxpZCBJRC4gRGVmYXVsdDogYHRydWVgXG4gKiBAcGFyYW0gb3B0aW9ucy5wZXJtaXRGcmFjdGlvbnMgLSBXaGV0aGVyIGZyYWN0aW9uYWwgbnVtYmVycyAoZS5nLiBgMS4yYClcbiAqIHNob3VsZCBiZSB0cmVhdGVkIGFzIHZhbGlkIElEcy4gRGVmYXVsdDogYGZhbHNlYFxuICogQHBhcmFtIG9wdGlvbnMucGVybWl0TnVsbCAtIFdoZXRoZXIgYG51bGxgIHNob3VsZCBiZSB0cmVhdGVkIGFzIGEgdmFsaWQgSUQuXG4gKiBEZWZhdWx0OiBgdHJ1ZWBcbiAqIEByZXR1cm5zIFRoZSBKU09OLVJQQyBJRCB2YWxpZGF0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGdldEpzb25ScGNJZFZhbGlkYXRvcihvcHRpb25zKSB7XG4gICAgY29uc3QgeyBwZXJtaXRFbXB0eVN0cmluZywgcGVybWl0RnJhY3Rpb25zLCBwZXJtaXROdWxsIH0gPSBPYmplY3QuYXNzaWduKHsgcGVybWl0RW1wdHlTdHJpbmc6IHRydWUsIHBlcm1pdEZyYWN0aW9uczogZmFsc2UsIHBlcm1pdE51bGw6IHRydWUgfSwgb3B0aW9ucyk7XG4gICAgLyoqXG4gICAgICogVHlwZSBndWFyZCBmb3Ige0BsaW5rIEpzb25ScGNJZH0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgSlNPTi1SUEMgSUQgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgZ2l2ZW4gSUQgaXMgdmFsaWQgcGVyIHRoZSBvcHRpb25zIGdpdmVuIHRvIHRoZVxuICAgICAqIGZhY3RvcnkuXG4gICAgICovXG4gICAgY29uc3QgaXNWYWxpZEpzb25ScGNJZCA9IChpZCkgPT4ge1xuICAgICAgICByZXR1cm4gQm9vbGVhbigodHlwZW9mIGlkID09PSAnbnVtYmVyJyAmJiAocGVybWl0RnJhY3Rpb25zIHx8IE51bWJlci5pc0ludGVnZXIoaWQpKSkgfHxcbiAgICAgICAgICAgICh0eXBlb2YgaWQgPT09ICdzdHJpbmcnICYmIChwZXJtaXRFbXB0eVN0cmluZyB8fCBpZC5sZW5ndGggPiAwKSkgfHxcbiAgICAgICAgICAgIChwZXJtaXROdWxsICYmIGlkID09PSBudWxsKSk7XG4gICAgfTtcbiAgICByZXR1cm4gaXNWYWxpZEpzb25ScGNJZDtcbn1cbmV4cG9ydHMuZ2V0SnNvblJwY0lkVmFsaWRhdG9yID0gZ2V0SnNvblJwY0lkVmFsaWRhdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anNvbi5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJnZXRKc29uUnBjSWRWYWxpZGF0b3IiLCJhc3NlcnRJc0pzb25ScGNFcnJvciIsImlzSnNvblJwY0Vycm9yIiwiYXNzZXJ0SXNKc29uUnBjRmFpbHVyZSIsImlzSnNvblJwY0ZhaWx1cmUiLCJhc3NlcnRJc0pzb25ScGNTdWNjZXNzIiwiaXNKc29uUnBjU3VjY2VzcyIsImFzc2VydElzSnNvblJwY1Jlc3BvbnNlIiwiaXNKc29uUnBjUmVzcG9uc2UiLCJhc3NlcnRJc1BlbmRpbmdKc29uUnBjUmVzcG9uc2UiLCJpc1BlbmRpbmdKc29uUnBjUmVzcG9uc2UiLCJKc29uUnBjUmVzcG9uc2VTdHJ1Y3QiLCJKc29uUnBjRmFpbHVyZVN0cnVjdCIsIkpzb25ScGNTdWNjZXNzU3RydWN0IiwiUGVuZGluZ0pzb25ScGNSZXNwb25zZVN0cnVjdCIsImFzc2VydElzSnNvblJwY1JlcXVlc3QiLCJpc0pzb25ScGNSZXF1ZXN0IiwiYXNzZXJ0SXNKc29uUnBjTm90aWZpY2F0aW9uIiwiaXNKc29uUnBjTm90aWZpY2F0aW9uIiwiSnNvblJwY05vdGlmaWNhdGlvblN0cnVjdCIsIkpzb25ScGNSZXF1ZXN0U3RydWN0IiwiSnNvblJwY1BhcmFtc1N0cnVjdCIsIkpzb25ScGNFcnJvclN0cnVjdCIsIkpzb25ScGNJZFN0cnVjdCIsIkpzb25ScGNWZXJzaW9uU3RydWN0IiwianNvbnJwYzIiLCJnZXRKc29uU2l6ZSIsImlzVmFsaWRKc29uIiwiSnNvblN0cnVjdCIsIlVuc2FmZUpzb25TdHJ1Y3QiLCJzdXBlcnN0cnVjdF8xIiwicmVxdWlyZSIsImFzc2VydF8xIiwiZmluaXRlTnVtYmVyIiwiZGVmaW5lIiwiaXMiLCJudW1iZXIiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInVuaW9uIiwibGl0ZXJhbCIsImJvb2xlYW4iLCJzdHJpbmciLCJhcnJheSIsImxhenkiLCJyZWNvcmQiLCJjb250ZXh0IiwiY2hlY2tTdHJ1Y3QiLCJpbm5lclZhbHVlIiwic3RydWN0IiwiaXRlcmF0b3IiLCJ2YWxpZGF0b3IiLCJlcnJvcnMiLCJsZW5ndGgiLCJ1bnNhZmVSZXN1bHQiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJlcnJvciIsIlJhbmdlRXJyb3IiLCJhc3NlcnRTdHJ1Y3QiLCJqc29uIiwiVGV4dEVuY29kZXIiLCJlbmNvZGUiLCJieXRlTGVuZ3RoIiwibnVsbGFibGUiLCJvYmplY3QiLCJjb2RlIiwiaW50ZWdlciIsIm1lc3NhZ2UiLCJkYXRhIiwib3B0aW9uYWwiLCJzdGFjayIsImlkIiwianNvbnJwYyIsIm1ldGhvZCIsInBhcmFtcyIsIm9taXQiLCJFcnJvcldyYXBwZXIiLCJyZXN1bHQiLCJ1bmtub3duIiwicmVzcG9uc2UiLCJvcHRpb25zIiwicGVybWl0RW1wdHlTdHJpbmciLCJwZXJtaXRGcmFjdGlvbnMiLCJwZXJtaXROdWxsIiwiYXNzaWduIiwiaXNWYWxpZEpzb25ScGNJZCIsIkJvb2xlYW4iLCJpc0ludGVnZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/json.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/keyring.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/keyring.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n})); //# sourceMappingURL=keyring.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2tleXJpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUMsRUFDN0QsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHNlLTIvbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2V0aC1ibG9jay10cmFja2VyL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9rZXlyaW5nLmpzP2FiMDQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1rZXlyaW5nLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/keyring.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/logging.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/logging.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createModuleLogger = exports.createProjectLogger = void 0;\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\"));\nconst globalLogger = (0, debug_1.default)(\"metamask\");\n/**\n * Creates a logger via the `debug` library whose log messages will be tagged\n * using the name of your project. By default, such messages will be\n * suppressed, but you can reveal them by setting the `DEBUG` environment\n * variable to `metamask:<projectName>`. You can also set this variable to\n * `metamask:*` if you want to see log messages from all MetaMask projects that\n * are also using this function to create their loggers.\n *\n * @param projectName - The name of your project. This should be the name of\n * your NPM package if you're developing one.\n * @returns An instance of `debug`.\n */ function createProjectLogger(projectName) {\n    return globalLogger.extend(projectName);\n}\nexports.createProjectLogger = createProjectLogger;\n/**\n * Creates a logger via the `debug` library which is derived from the logger for\n * the whole project whose log messages will be tagged using the name of your\n * module. By default, such messages will be suppressed, but you can reveal them\n * by setting the `DEBUG` environment variable to\n * `metamask:<projectName>:<moduleName>`. You can also set this variable to\n * `metamask:<projectName>:*` if you want to see log messages from the project,\n * or `metamask:*` if you want to see log messages from all MetaMask projects.\n *\n * @param projectLogger - The logger created via {@link createProjectLogger}.\n * @param moduleName - The name of your module. You could use the name of the\n * file where you're using this logger or some other name.\n * @returns An instance of `debug`.\n */ function createModuleLogger(projectLogger, moduleName) {\n    return projectLogger.extend(moduleName);\n}\nexports.createModuleLogger = createModuleLogger; //# sourceMappingURL=logging.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2xvZ2dpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsSUFBSyxJQUFJLElBQUksQ0FBQ0EsZUFBZSxJQUFLLFNBQVVDLEdBQUc7SUFDakUsT0FBTyxPQUFRQSxJQUFJQyxVQUFVLEdBQUlELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQzVEO0FBQ0FFLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwwQkFBMEIsR0FBR0EsMkJBQTJCLEdBQUcsS0FBSztBQUNoRSxNQUFNSSxVQUFVVCxnQkFBZ0JVLG1CQUFPQSxDQUFDLHNEQUFPO0FBQy9DLE1BQU1DLGVBQWUsQ0FBQyxHQUFHRixRQUFRRyxPQUFPLEVBQUU7QUFDMUM7Ozs7Ozs7Ozs7O0NBV0MsR0FDRCxTQUFTSixvQkFBb0JLLFdBQVc7SUFDcEMsT0FBT0YsYUFBYUcsTUFBTSxDQUFDRDtBQUMvQjtBQUNBUiwyQkFBMkIsR0FBR0c7QUFDOUI7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNELFNBQVNELG1CQUFtQlEsYUFBYSxFQUFFQyxVQUFVO0lBQ2pELE9BQU9ELGNBQWNELE1BQU0sQ0FBQ0U7QUFDaEM7QUFDQVgsMEJBQTBCLEdBQUdFLG9CQUM3QixtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac2UtMi9uZXh0anMvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2xvZ2dpbmcuanM/ZGEwYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlTW9kdWxlTG9nZ2VyID0gZXhwb3J0cy5jcmVhdGVQcm9qZWN0TG9nZ2VyID0gdm9pZCAwO1xuY29uc3QgZGVidWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpO1xuY29uc3QgZ2xvYmFsTG9nZ2VyID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoJ21ldGFtYXNrJyk7XG4vKipcbiAqIENyZWF0ZXMgYSBsb2dnZXIgdmlhIHRoZSBgZGVidWdgIGxpYnJhcnkgd2hvc2UgbG9nIG1lc3NhZ2VzIHdpbGwgYmUgdGFnZ2VkXG4gKiB1c2luZyB0aGUgbmFtZSBvZiB5b3VyIHByb2plY3QuIEJ5IGRlZmF1bHQsIHN1Y2ggbWVzc2FnZXMgd2lsbCBiZVxuICogc3VwcHJlc3NlZCwgYnV0IHlvdSBjYW4gcmV2ZWFsIHRoZW0gYnkgc2V0dGluZyB0aGUgYERFQlVHYCBlbnZpcm9ubWVudFxuICogdmFyaWFibGUgdG8gYG1ldGFtYXNrOjxwcm9qZWN0TmFtZT5gLiBZb3UgY2FuIGFsc28gc2V0IHRoaXMgdmFyaWFibGUgdG9cbiAqIGBtZXRhbWFzazoqYCBpZiB5b3Ugd2FudCB0byBzZWUgbG9nIG1lc3NhZ2VzIGZyb20gYWxsIE1ldGFNYXNrIHByb2plY3RzIHRoYXRcbiAqIGFyZSBhbHNvIHVzaW5nIHRoaXMgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZWlyIGxvZ2dlcnMuXG4gKlxuICogQHBhcmFtIHByb2plY3ROYW1lIC0gVGhlIG5hbWUgb2YgeW91ciBwcm9qZWN0LiBUaGlzIHNob3VsZCBiZSB0aGUgbmFtZSBvZlxuICogeW91ciBOUE0gcGFja2FnZSBpZiB5b3UncmUgZGV2ZWxvcGluZyBvbmUuXG4gKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBgZGVidWdgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVQcm9qZWN0TG9nZ2VyKHByb2plY3ROYW1lKSB7XG4gICAgcmV0dXJuIGdsb2JhbExvZ2dlci5leHRlbmQocHJvamVjdE5hbWUpO1xufVxuZXhwb3J0cy5jcmVhdGVQcm9qZWN0TG9nZ2VyID0gY3JlYXRlUHJvamVjdExvZ2dlcjtcbi8qKlxuICogQ3JlYXRlcyBhIGxvZ2dlciB2aWEgdGhlIGBkZWJ1Z2AgbGlicmFyeSB3aGljaCBpcyBkZXJpdmVkIGZyb20gdGhlIGxvZ2dlciBmb3JcbiAqIHRoZSB3aG9sZSBwcm9qZWN0IHdob3NlIGxvZyBtZXNzYWdlcyB3aWxsIGJlIHRhZ2dlZCB1c2luZyB0aGUgbmFtZSBvZiB5b3VyXG4gKiBtb2R1bGUuIEJ5IGRlZmF1bHQsIHN1Y2ggbWVzc2FnZXMgd2lsbCBiZSBzdXBwcmVzc2VkLCBidXQgeW91IGNhbiByZXZlYWwgdGhlbVxuICogYnkgc2V0dGluZyB0aGUgYERFQlVHYCBlbnZpcm9ubWVudCB2YXJpYWJsZSB0b1xuICogYG1ldGFtYXNrOjxwcm9qZWN0TmFtZT46PG1vZHVsZU5hbWU+YC4gWW91IGNhbiBhbHNvIHNldCB0aGlzIHZhcmlhYmxlIHRvXG4gKiBgbWV0YW1hc2s6PHByb2plY3ROYW1lPjoqYCBpZiB5b3Ugd2FudCB0byBzZWUgbG9nIG1lc3NhZ2VzIGZyb20gdGhlIHByb2plY3QsXG4gKiBvciBgbWV0YW1hc2s6KmAgaWYgeW91IHdhbnQgdG8gc2VlIGxvZyBtZXNzYWdlcyBmcm9tIGFsbCBNZXRhTWFzayBwcm9qZWN0cy5cbiAqXG4gKiBAcGFyYW0gcHJvamVjdExvZ2dlciAtIFRoZSBsb2dnZXIgY3JlYXRlZCB2aWEge0BsaW5rIGNyZWF0ZVByb2plY3RMb2dnZXJ9LlxuICogQHBhcmFtIG1vZHVsZU5hbWUgLSBUaGUgbmFtZSBvZiB5b3VyIG1vZHVsZS4gWW91IGNvdWxkIHVzZSB0aGUgbmFtZSBvZiB0aGVcbiAqIGZpbGUgd2hlcmUgeW91J3JlIHVzaW5nIHRoaXMgbG9nZ2VyIG9yIHNvbWUgb3RoZXIgbmFtZS5cbiAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIGBkZWJ1Z2AuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1vZHVsZUxvZ2dlcihwcm9qZWN0TG9nZ2VyLCBtb2R1bGVOYW1lKSB7XG4gICAgcmV0dXJuIHByb2plY3RMb2dnZXIuZXh0ZW5kKG1vZHVsZU5hbWUpO1xufVxuZXhwb3J0cy5jcmVhdGVNb2R1bGVMb2dnZXIgPSBjcmVhdGVNb2R1bGVMb2dnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2dnaW5nLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2ltcG9ydERlZmF1bHQiLCJtb2QiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjcmVhdGVNb2R1bGVMb2dnZXIiLCJjcmVhdGVQcm9qZWN0TG9nZ2VyIiwiZGVidWdfMSIsInJlcXVpcmUiLCJnbG9iYWxMb2dnZXIiLCJkZWZhdWx0IiwicHJvamVjdE5hbWUiLCJleHRlbmQiLCJwcm9qZWN0TG9nZ2VyIiwibW9kdWxlTmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/logging.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/misc.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/misc.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n//\n// Types\n//\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.calculateNumberSize = exports.calculateStringSize = exports.isASCII = exports.isPlainObject = exports.ESCAPE_CHARACTERS_REGEXP = exports.JsonSize = exports.hasProperty = exports.isObject = exports.isNullOrUndefined = exports.isNonEmptyArray = void 0;\n//\n// Type Guards\n//\n/**\n * A {@link NonEmptyArray} type guard.\n *\n * @template Element - The non-empty array member type.\n * @param value - The value to check.\n * @returns Whether the value is a non-empty array.\n */ function isNonEmptyArray(value) {\n    return Array.isArray(value) && value.length > 0;\n}\nexports.isNonEmptyArray = isNonEmptyArray;\n/**\n * Type guard for \"nullishness\".\n *\n * @param value - Any value.\n * @returns `true` if the value is null or undefined, `false` otherwise.\n */ function isNullOrUndefined(value) {\n    return value === null || value === undefined;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n/**\n * A type guard for {@link RuntimeObject}.\n *\n * @param value - The value to check.\n * @returns Whether the specified value has a runtime type of `object` and is\n * neither `null` nor an `Array`.\n */ function isObject(value) {\n    return Boolean(value) && typeof value === \"object\" && !Array.isArray(value);\n}\nexports.isObject = isObject;\n//\n// Other utility functions\n//\n/**\n * A type guard for ensuring an object has a property.\n *\n * @param objectToCheck - The object to check.\n * @param name - The property name to check for.\n * @returns Whether the specified object has an own property with the specified\n * name, regardless of whether it is enumerable or not.\n */ const hasProperty = (objectToCheck, name)=>Object.hasOwnProperty.call(objectToCheck, name);\nexports.hasProperty = hasProperty;\n/**\n * Predefined sizes (in Bytes) of specific parts of JSON structure.\n */ var JsonSize;\n(function(JsonSize) {\n    JsonSize[JsonSize[\"Null\"] = 4] = \"Null\";\n    JsonSize[JsonSize[\"Comma\"] = 1] = \"Comma\";\n    JsonSize[JsonSize[\"Wrapper\"] = 1] = \"Wrapper\";\n    JsonSize[JsonSize[\"True\"] = 4] = \"True\";\n    JsonSize[JsonSize[\"False\"] = 5] = \"False\";\n    JsonSize[JsonSize[\"Quote\"] = 1] = \"Quote\";\n    JsonSize[JsonSize[\"Colon\"] = 1] = \"Colon\";\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    JsonSize[JsonSize[\"Date\"] = 24] = \"Date\";\n})(JsonSize = exports.JsonSize || (exports.JsonSize = {}));\n/**\n * Regular expression with pattern matching for (special) escaped characters.\n */ exports.ESCAPE_CHARACTERS_REGEXP = /\"|\\\\|\\n|\\r|\\t/gu;\n/**\n * Check if the value is plain object.\n *\n * @param value - Value to be checked.\n * @returns True if an object is the plain JavaScript object,\n * false if the object is not plain (e.g. function).\n */ function isPlainObject(value) {\n    if (typeof value !== \"object\" || value === null) {\n        return false;\n    }\n    try {\n        let proto = value;\n        while(Object.getPrototypeOf(proto) !== null){\n            proto = Object.getPrototypeOf(proto);\n        }\n        return Object.getPrototypeOf(value) === proto;\n    } catch (_) {\n        return false;\n    }\n}\nexports.isPlainObject = isPlainObject;\n/**\n * Check if character is ASCII.\n *\n * @param character - Character.\n * @returns True if a character code is ASCII, false if not.\n */ function isASCII(character) {\n    return character.charCodeAt(0) <= 127;\n}\nexports.isASCII = isASCII;\n/**\n * Calculate string size.\n *\n * @param value - String value to calculate size.\n * @returns Number of bytes used to store whole string value.\n */ function calculateStringSize(value) {\n    var _a;\n    const size = value.split(\"\").reduce((total, character)=>{\n        if (isASCII(character)) {\n            return total + 1;\n        }\n        return total + 2;\n    }, 0);\n    // Also detect characters that need backslash escape\n    return size + ((_a = value.match(exports.ESCAPE_CHARACTERS_REGEXP)) !== null && _a !== void 0 ? _a : []).length;\n}\nexports.calculateStringSize = calculateStringSize;\n/**\n * Calculate size of a number ofter JSON serialization.\n *\n * @param value - Number value to calculate size.\n * @returns Number of bytes used to store whole number in JSON.\n */ function calculateNumberSize(value) {\n    return value.toString().length;\n}\nexports.calculateNumberSize = calculateNumberSize; //# sourceMappingURL=misc.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L21pc2MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixFQUFFO0FBQ0YsUUFBUTtBQUNSLEVBQUU7QUFDRkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDJCQUEyQixHQUFHQSwyQkFBMkIsR0FBR0EsZUFBZSxHQUFHQSxxQkFBcUIsR0FBR0EsZ0NBQWdDLEdBQUdBLGdCQUFnQixHQUFHQSxtQkFBbUIsR0FBR0EsZ0JBQWdCLEdBQUdBLHlCQUF5QixHQUFHQSx1QkFBdUIsR0FBRyxLQUFLO0FBQ2hRLEVBQUU7QUFDRixjQUFjO0FBQ2QsRUFBRTtBQUNGOzs7Ozs7Q0FNQyxHQUNELFNBQVNXLGdCQUFnQlYsS0FBSztJQUMxQixPQUFPVyxNQUFNQyxPQUFPLENBQUNaLFVBQVVBLE1BQU1hLE1BQU0sR0FBRztBQUNsRDtBQUNBZCx1QkFBdUIsR0FBR1c7QUFDMUI7Ozs7O0NBS0MsR0FDRCxTQUFTRCxrQkFBa0JULEtBQUs7SUFDNUIsT0FBT0EsVUFBVSxRQUFRQSxVQUFVYztBQUN2QztBQUNBZix5QkFBeUIsR0FBR1U7QUFDNUI7Ozs7OztDQU1DLEdBQ0QsU0FBU0QsU0FBU1IsS0FBSztJQUNuQixPQUFPZSxRQUFRZixVQUFVLE9BQU9BLFVBQVUsWUFBWSxDQUFDVyxNQUFNQyxPQUFPLENBQUNaO0FBQ3pFO0FBQ0FELGdCQUFnQixHQUFHUztBQUNuQixFQUFFO0FBQ0YsMEJBQTBCO0FBQzFCLEVBQUU7QUFDRjs7Ozs7OztDQU9DLEdBQ0QsTUFBTUQsY0FBYyxDQUFDUyxlQUFlQyxPQUFTcEIsT0FBT3FCLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSCxlQUFlQztBQUN2RmxCLG1CQUFtQixHQUFHUTtBQUN0Qjs7Q0FFQyxHQUNELElBQUlEO0FBQ0gsVUFBVUEsUUFBUTtJQUNmQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxPQUFPLEdBQUcsRUFBRSxHQUFHO0lBQ2pDQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxRQUFRLEdBQUcsRUFBRSxHQUFHO0lBQ2xDQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxVQUFVLEdBQUcsRUFBRSxHQUFHO0lBQ3BDQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxPQUFPLEdBQUcsRUFBRSxHQUFHO0lBQ2pDQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxRQUFRLEdBQUcsRUFBRSxHQUFHO0lBQ2xDQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxRQUFRLEdBQUcsRUFBRSxHQUFHO0lBQ2xDQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxRQUFRLEdBQUcsRUFBRSxHQUFHO0lBQ2xDLHdEQUF3RDtJQUN4REEsUUFBUSxDQUFDQSxRQUFRLENBQUMsT0FBTyxHQUFHLEdBQUcsR0FBRztBQUN0QyxHQUFHQSxXQUFXUCxRQUFRTyxRQUFRLElBQUtQLENBQUFBLGdCQUFnQixHQUFHLENBQUM7QUFDdkQ7O0NBRUMsR0FDREEsZ0NBQWdDLEdBQUc7QUFDbkM7Ozs7OztDQU1DLEdBQ0QsU0FBU0ssY0FBY0osS0FBSztJQUN4QixJQUFJLE9BQU9BLFVBQVUsWUFBWUEsVUFBVSxNQUFNO1FBQzdDLE9BQU87SUFDWDtJQUNBLElBQUk7UUFDQSxJQUFJb0IsUUFBUXBCO1FBQ1osTUFBT0gsT0FBT3dCLGNBQWMsQ0FBQ0QsV0FBVyxLQUFNO1lBQzFDQSxRQUFRdkIsT0FBT3dCLGNBQWMsQ0FBQ0Q7UUFDbEM7UUFDQSxPQUFPdkIsT0FBT3dCLGNBQWMsQ0FBQ3JCLFdBQVdvQjtJQUM1QyxFQUNBLE9BQU9FLEdBQUc7UUFDTixPQUFPO0lBQ1g7QUFDSjtBQUNBdkIscUJBQXFCLEdBQUdLO0FBQ3hCOzs7OztDQUtDLEdBQ0QsU0FBU0QsUUFBUW9CLFNBQVM7SUFDdEIsT0FBT0EsVUFBVUMsVUFBVSxDQUFDLE1BQU07QUFDdEM7QUFDQXpCLGVBQWUsR0FBR0k7QUFDbEI7Ozs7O0NBS0MsR0FDRCxTQUFTRCxvQkFBb0JGLEtBQUs7SUFDOUIsSUFBSXlCO0lBQ0osTUFBTUMsT0FBTzFCLE1BQU0yQixLQUFLLENBQUMsSUFBSUMsTUFBTSxDQUFDLENBQUNDLE9BQU9OO1FBQ3hDLElBQUlwQixRQUFRb0IsWUFBWTtZQUNwQixPQUFPTSxRQUFRO1FBQ25CO1FBQ0EsT0FBT0EsUUFBUTtJQUNuQixHQUFHO0lBQ0gsb0RBQW9EO0lBQ3BELE9BQU9ILE9BQU8sQ0FBQyxDQUFDRCxLQUFLekIsTUFBTThCLEtBQUssQ0FBQy9CLFFBQVFNLHdCQUF3QixPQUFPLFFBQVFvQixPQUFPLEtBQUssSUFBSUEsS0FBSyxFQUFFLEVBQUVaLE1BQU07QUFDbkg7QUFDQWQsMkJBQTJCLEdBQUdHO0FBQzlCOzs7OztDQUtDLEdBQ0QsU0FBU0Qsb0JBQW9CRCxLQUFLO0lBQzlCLE9BQU9BLE1BQU0rQixRQUFRLEdBQUdsQixNQUFNO0FBQ2xDO0FBQ0FkLDJCQUEyQixHQUFHRSxxQkFDOUIsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHNlLTIvbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2V0aC1ibG9jay10cmFja2VyL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9taXNjLmpzP2QyNTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vL1xuLy8gVHlwZXNcbi8vXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNhbGN1bGF0ZU51bWJlclNpemUgPSBleHBvcnRzLmNhbGN1bGF0ZVN0cmluZ1NpemUgPSBleHBvcnRzLmlzQVNDSUkgPSBleHBvcnRzLmlzUGxhaW5PYmplY3QgPSBleHBvcnRzLkVTQ0FQRV9DSEFSQUNURVJTX1JFR0VYUCA9IGV4cG9ydHMuSnNvblNpemUgPSBleHBvcnRzLmhhc1Byb3BlcnR5ID0gZXhwb3J0cy5pc09iamVjdCA9IGV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBleHBvcnRzLmlzTm9uRW1wdHlBcnJheSA9IHZvaWQgMDtcbi8vXG4vLyBUeXBlIEd1YXJkc1xuLy9cbi8qKlxuICogQSB7QGxpbmsgTm9uRW1wdHlBcnJheX0gdHlwZSBndWFyZC5cbiAqXG4gKiBAdGVtcGxhdGUgRWxlbWVudCAtIFRoZSBub24tZW1wdHkgYXJyYXkgbWVtYmVyIHR5cGUuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIG5vbi1lbXB0eSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gaXNOb25FbXB0eUFycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA+IDA7XG59XG5leHBvcnRzLmlzTm9uRW1wdHlBcnJheSA9IGlzTm9uRW1wdHlBcnJheTtcbi8qKlxuICogVHlwZSBndWFyZCBmb3IgXCJudWxsaXNobmVzc1wiLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgbnVsbCBvciB1bmRlZmluZWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuLyoqXG4gKiBBIHR5cGUgZ3VhcmQgZm9yIHtAbGluayBSdW50aW1lT2JqZWN0fS5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBzcGVjaWZpZWQgdmFsdWUgaGFzIGEgcnVudGltZSB0eXBlIG9mIGBvYmplY3RgIGFuZCBpc1xuICogbmVpdGhlciBgbnVsbGAgbm9yIGFuIGBBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odmFsdWUpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuLy9cbi8vIE90aGVyIHV0aWxpdHkgZnVuY3Rpb25zXG4vL1xuLyoqXG4gKiBBIHR5cGUgZ3VhcmQgZm9yIGVuc3VyaW5nIGFuIG9iamVjdCBoYXMgYSBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0gb2JqZWN0VG9DaGVjayAtIFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcGFyYW0gbmFtZSAtIFRoZSBwcm9wZXJ0eSBuYW1lIHRvIGNoZWNrIGZvci5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHNwZWNpZmllZCBvYmplY3QgaGFzIGFuIG93biBwcm9wZXJ0eSB3aXRoIHRoZSBzcGVjaWZpZWRcbiAqIG5hbWUsIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciBpdCBpcyBlbnVtZXJhYmxlIG9yIG5vdC5cbiAqL1xuY29uc3QgaGFzUHJvcGVydHkgPSAob2JqZWN0VG9DaGVjaywgbmFtZSkgPT4gT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0VG9DaGVjaywgbmFtZSk7XG5leHBvcnRzLmhhc1Byb3BlcnR5ID0gaGFzUHJvcGVydHk7XG4vKipcbiAqIFByZWRlZmluZWQgc2l6ZXMgKGluIEJ5dGVzKSBvZiBzcGVjaWZpYyBwYXJ0cyBvZiBKU09OIHN0cnVjdHVyZS5cbiAqL1xudmFyIEpzb25TaXplO1xuKGZ1bmN0aW9uIChKc29uU2l6ZSkge1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiTnVsbFwiXSA9IDRdID0gXCJOdWxsXCI7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJDb21tYVwiXSA9IDFdID0gXCJDb21tYVwiO1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiV3JhcHBlclwiXSA9IDFdID0gXCJXcmFwcGVyXCI7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJUcnVlXCJdID0gNF0gPSBcIlRydWVcIjtcbiAgICBKc29uU2l6ZVtKc29uU2l6ZVtcIkZhbHNlXCJdID0gNV0gPSBcIkZhbHNlXCI7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJRdW90ZVwiXSA9IDFdID0gXCJRdW90ZVwiO1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiQ29sb25cIl0gPSAxXSA9IFwiQ29sb25cIjtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXNoYWRvd1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiRGF0ZVwiXSA9IDI0XSA9IFwiRGF0ZVwiO1xufSkoSnNvblNpemUgPSBleHBvcnRzLkpzb25TaXplIHx8IChleHBvcnRzLkpzb25TaXplID0ge30pKTtcbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIHdpdGggcGF0dGVybiBtYXRjaGluZyBmb3IgKHNwZWNpYWwpIGVzY2FwZWQgY2hhcmFjdGVycy5cbiAqL1xuZXhwb3J0cy5FU0NBUEVfQ0hBUkFDVEVSU19SRUdFWFAgPSAvXCJ8XFxcXHxcXG58XFxyfFxcdC9ndTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIHZhbHVlIGlzIHBsYWluIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgVHJ1ZSBpZiBhbiBvYmplY3QgaXMgdGhlIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0LFxuICogZmFsc2UgaWYgdGhlIG9iamVjdCBpcyBub3QgcGxhaW4gKGUuZy4gZnVuY3Rpb24pLlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBsZXQgcHJvdG8gPSB2YWx1ZTtcbiAgICAgICAgd2hpbGUgKE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bykgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gcHJvdG87XG4gICAgfVxuICAgIGNhdGNoIChfKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLmlzUGxhaW5PYmplY3QgPSBpc1BsYWluT2JqZWN0O1xuLyoqXG4gKiBDaGVjayBpZiBjaGFyYWN0ZXIgaXMgQVNDSUkuXG4gKlxuICogQHBhcmFtIGNoYXJhY3RlciAtIENoYXJhY3Rlci5cbiAqIEByZXR1cm5zIFRydWUgaWYgYSBjaGFyYWN0ZXIgY29kZSBpcyBBU0NJSSwgZmFsc2UgaWYgbm90LlxuICovXG5mdW5jdGlvbiBpc0FTQ0lJKGNoYXJhY3Rlcikge1xuICAgIHJldHVybiBjaGFyYWN0ZXIuY2hhckNvZGVBdCgwKSA8PSAxMjc7XG59XG5leHBvcnRzLmlzQVNDSUkgPSBpc0FTQ0lJO1xuLyoqXG4gKiBDYWxjdWxhdGUgc3RyaW5nIHNpemUuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gU3RyaW5nIHZhbHVlIHRvIGNhbGN1bGF0ZSBzaXplLlxuICogQHJldHVybnMgTnVtYmVyIG9mIGJ5dGVzIHVzZWQgdG8gc3RvcmUgd2hvbGUgc3RyaW5nIHZhbHVlLlxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVTdHJpbmdTaXplKHZhbHVlKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHNpemUgPSB2YWx1ZS5zcGxpdCgnJykucmVkdWNlKCh0b3RhbCwgY2hhcmFjdGVyKSA9PiB7XG4gICAgICAgIGlmIChpc0FTQ0lJKGNoYXJhY3RlcikpIHtcbiAgICAgICAgICAgIHJldHVybiB0b3RhbCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvdGFsICsgMjtcbiAgICB9LCAwKTtcbiAgICAvLyBBbHNvIGRldGVjdCBjaGFyYWN0ZXJzIHRoYXQgbmVlZCBiYWNrc2xhc2ggZXNjYXBlXG4gICAgcmV0dXJuIHNpemUgKyAoKF9hID0gdmFsdWUubWF0Y2goZXhwb3J0cy5FU0NBUEVfQ0hBUkFDVEVSU19SRUdFWFApKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSkubGVuZ3RoO1xufVxuZXhwb3J0cy5jYWxjdWxhdGVTdHJpbmdTaXplID0gY2FsY3VsYXRlU3RyaW5nU2l6ZTtcbi8qKlxuICogQ2FsY3VsYXRlIHNpemUgb2YgYSBudW1iZXIgb2Z0ZXIgSlNPTiBzZXJpYWxpemF0aW9uLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIE51bWJlciB2YWx1ZSB0byBjYWxjdWxhdGUgc2l6ZS5cbiAqIEByZXR1cm5zIE51bWJlciBvZiBieXRlcyB1c2VkIHRvIHN0b3JlIHdob2xlIG51bWJlciBpbiBKU09OLlxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVOdW1iZXJTaXplKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCkubGVuZ3RoO1xufVxuZXhwb3J0cy5jYWxjdWxhdGVOdW1iZXJTaXplID0gY2FsY3VsYXRlTnVtYmVyU2l6ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1pc2MuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiY2FsY3VsYXRlTnVtYmVyU2l6ZSIsImNhbGN1bGF0ZVN0cmluZ1NpemUiLCJpc0FTQ0lJIiwiaXNQbGFpbk9iamVjdCIsIkVTQ0FQRV9DSEFSQUNURVJTX1JFR0VYUCIsIkpzb25TaXplIiwiaGFzUHJvcGVydHkiLCJpc09iamVjdCIsImlzTnVsbE9yVW5kZWZpbmVkIiwiaXNOb25FbXB0eUFycmF5IiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwidW5kZWZpbmVkIiwiQm9vbGVhbiIsIm9iamVjdFRvQ2hlY2siLCJuYW1lIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwicHJvdG8iLCJnZXRQcm90b3R5cGVPZiIsIl8iLCJjaGFyYWN0ZXIiLCJjaGFyQ29kZUF0IiwiX2EiLCJzaXplIiwic3BsaXQiLCJyZWR1Y2UiLCJ0b3RhbCIsIm1hdGNoIiwidG9TdHJpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/misc.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/number.js":
/*!************************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/number.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.hexToBigInt = exports.hexToNumber = exports.bigIntToHex = exports.numberToHex = void 0;\nconst assert_1 = __webpack_require__(/*! ./assert */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/assert.js\");\nconst hex_1 = __webpack_require__(/*! ./hex */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/hex.js\");\n/**\n * Convert a number to a hexadecimal string. This verifies that the number is a\n * non-negative safe integer.\n *\n * To convert a `bigint` to a hexadecimal string instead, use\n * {@link bigIntToHex}.\n *\n * @example\n * ```typescript\n * numberToHex(0); // '0x0'\n * numberToHex(1); // '0x1'\n * numberToHex(16); // '0x10'\n * ```\n * @param value - The number to convert to a hexadecimal string.\n * @returns The hexadecimal string, with the \"0x\"-prefix.\n * @throws If the number is not a non-negative safe integer.\n */ const numberToHex = (value)=>{\n    (0, assert_1.assert)(typeof value === \"number\", \"Value must be a number.\");\n    (0, assert_1.assert)(value >= 0, \"Value must be a non-negative number.\");\n    (0, assert_1.assert)(Number.isSafeInteger(value), \"Value is not a safe integer. Use `bigIntToHex` instead.\");\n    return (0, hex_1.add0x)(value.toString(16));\n};\nexports.numberToHex = numberToHex;\n/**\n * Convert a `bigint` to a hexadecimal string. This verifies that the `bigint`\n * is a non-negative integer.\n *\n * To convert a number to a hexadecimal string instead, use {@link numberToHex}.\n *\n * @example\n * ```typescript\n * bigIntToHex(0n); // '0x0'\n * bigIntToHex(1n); // '0x1'\n * bigIntToHex(16n); // '0x10'\n * ```\n * @param value - The `bigint` to convert to a hexadecimal string.\n * @returns The hexadecimal string, with the \"0x\"-prefix.\n * @throws If the `bigint` is not a non-negative integer.\n */ const bigIntToHex = (value)=>{\n    (0, assert_1.assert)(typeof value === \"bigint\", \"Value must be a bigint.\");\n    (0, assert_1.assert)(value >= 0, \"Value must be a non-negative bigint.\");\n    return (0, hex_1.add0x)(value.toString(16));\n};\nexports.bigIntToHex = bigIntToHex;\n/**\n * Convert a hexadecimal string to a number. This verifies that the string is a\n * valid hex string, and that the resulting number is a safe integer. Both\n * \"0x\"-prefixed and unprefixed strings are supported.\n *\n * To convert a hexadecimal string to a `bigint` instead, use\n * {@link hexToBigInt}.\n *\n * @example\n * ```typescript\n * hexToNumber('0x0'); // 0\n * hexToNumber('0x1'); // 1\n * hexToNumber('0x10'); // 16\n * ```\n * @param value - The hexadecimal string to convert to a number.\n * @returns The number.\n * @throws If the value is not a valid hexadecimal string, or if the resulting\n * number is not a safe integer.\n */ const hexToNumber = (value)=>{\n    (0, hex_1.assertIsHexString)(value);\n    // `parseInt` accepts values without the \"0x\"-prefix, whereas `Number` does\n    // not. Using this is slightly faster than `Number(add0x(value))`.\n    const numberValue = parseInt(value, 16);\n    (0, assert_1.assert)(Number.isSafeInteger(numberValue), \"Value is not a safe integer. Use `hexToBigInt` instead.\");\n    return numberValue;\n};\nexports.hexToNumber = hexToNumber;\n/**\n * Convert a hexadecimal string to a `bigint`. This verifies that the string is\n * a valid hex string. Both \"0x\"-prefixed and unprefixed strings are supported.\n *\n * To convert a hexadecimal string to a number instead, use {@link hexToNumber}.\n *\n * @example\n * ```typescript\n * hexToBigInt('0x0'); // 0n\n * hexToBigInt('0x1'); // 1n\n * hexToBigInt('0x10'); // 16n\n * ```\n * @param value - The hexadecimal string to convert to a `bigint`.\n * @returns The `bigint`.\n * @throws If the value is not a valid hexadecimal string.\n */ const hexToBigInt = (value)=>{\n    (0, hex_1.assertIsHexString)(value);\n    // The `BigInt` constructor requires the \"0x\"-prefix to parse a hex string.\n    return BigInt((0, hex_1.add0x)(value));\n};\nexports.hexToBigInt = hexToBigInt; //# sourceMappingURL=number.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L251bWJlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsbUJBQW1CLEdBQUdBLG1CQUFtQixHQUFHQSxtQkFBbUIsR0FBR0EsbUJBQW1CLEdBQUcsS0FBSztBQUM3RixNQUFNTSxXQUFXQyxtQkFBT0EsQ0FBQyxvR0FBVTtBQUNuQyxNQUFNQyxRQUFRRCxtQkFBT0EsQ0FBQyw4RkFBTztBQUM3Qjs7Ozs7Ozs7Ozs7Ozs7OztDQWdCQyxHQUNELE1BQU1GLGNBQWMsQ0FBQ0o7SUFDaEIsSUFBR0ssU0FBU0csTUFBTSxFQUFFLE9BQU9SLFVBQVUsVUFBVTtJQUMvQyxJQUFHSyxTQUFTRyxNQUFNLEVBQUVSLFNBQVMsR0FBRztJQUNoQyxJQUFHSyxTQUFTRyxNQUFNLEVBQUVDLE9BQU9DLGFBQWEsQ0FBQ1YsUUFBUTtJQUNsRCxPQUFPLENBQUMsR0FBR08sTUFBTUksS0FBSyxFQUFFWCxNQUFNWSxRQUFRLENBQUM7QUFDM0M7QUFDQWIsbUJBQW1CLEdBQUdLO0FBQ3RCOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNELE1BQU1ELGNBQWMsQ0FBQ0g7SUFDaEIsSUFBR0ssU0FBU0csTUFBTSxFQUFFLE9BQU9SLFVBQVUsVUFBVTtJQUMvQyxJQUFHSyxTQUFTRyxNQUFNLEVBQUVSLFNBQVMsR0FBRztJQUNqQyxPQUFPLENBQUMsR0FBR08sTUFBTUksS0FBSyxFQUFFWCxNQUFNWSxRQUFRLENBQUM7QUFDM0M7QUFDQWIsbUJBQW1CLEdBQUdJO0FBQ3RCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrQkMsR0FDRCxNQUFNRCxjQUFjLENBQUNGO0lBQ2hCLElBQUdPLE1BQU1NLGlCQUFpQixFQUFFYjtJQUM3QiwyRUFBMkU7SUFDM0Usa0VBQWtFO0lBQ2xFLE1BQU1jLGNBQWNDLFNBQVNmLE9BQU87SUFDbkMsSUFBR0ssU0FBU0csTUFBTSxFQUFFQyxPQUFPQyxhQUFhLENBQUNJLGNBQWM7SUFDeEQsT0FBT0E7QUFDWDtBQUNBZixtQkFBbUIsR0FBR0c7QUFDdEI7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0QsTUFBTUQsY0FBYyxDQUFDRDtJQUNoQixJQUFHTyxNQUFNTSxpQkFBaUIsRUFBRWI7SUFDN0IsMkVBQTJFO0lBQzNFLE9BQU9nQixPQUFPLENBQUMsR0FBR1QsTUFBTUksS0FBSyxFQUFFWDtBQUNuQztBQUNBRCxtQkFBbUIsR0FBR0UsYUFDdEIsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHNlLTIvbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2V0aC1ibG9jay10cmFja2VyL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9udW1iZXIuanM/MzYzYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaGV4VG9CaWdJbnQgPSBleHBvcnRzLmhleFRvTnVtYmVyID0gZXhwb3J0cy5iaWdJbnRUb0hleCA9IGV4cG9ydHMubnVtYmVyVG9IZXggPSB2b2lkIDA7XG5jb25zdCBhc3NlcnRfMSA9IHJlcXVpcmUoXCIuL2Fzc2VydFwiKTtcbmNvbnN0IGhleF8xID0gcmVxdWlyZShcIi4vaGV4XCIpO1xuLyoqXG4gKiBDb252ZXJ0IGEgbnVtYmVyIHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLiBUaGlzIHZlcmlmaWVzIHRoYXQgdGhlIG51bWJlciBpcyBhXG4gKiBub24tbmVnYXRpdmUgc2FmZSBpbnRlZ2VyLlxuICpcbiAqIFRvIGNvbnZlcnQgYSBgYmlnaW50YCB0byBhIGhleGFkZWNpbWFsIHN0cmluZyBpbnN0ZWFkLCB1c2VcbiAqIHtAbGluayBiaWdJbnRUb0hleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIG51bWJlclRvSGV4KDApOyAvLyAnMHgwJ1xuICogbnVtYmVyVG9IZXgoMSk7IC8vICcweDEnXG4gKiBudW1iZXJUb0hleCgxNik7IC8vICcweDEwJ1xuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nLCB3aXRoIHRoZSBcIjB4XCItcHJlZml4LlxuICogQHRocm93cyBJZiB0aGUgbnVtYmVyIGlzIG5vdCBhIG5vbi1uZWdhdGl2ZSBzYWZlIGludGVnZXIuXG4gKi9cbmNvbnN0IG51bWJlclRvSGV4ID0gKHZhbHVlKSA9PiB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ1ZhbHVlIG11c3QgYmUgYSBudW1iZXIuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodmFsdWUgPj0gMCwgJ1ZhbHVlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbHVlKSwgJ1ZhbHVlIGlzIG5vdCBhIHNhZmUgaW50ZWdlci4gVXNlIGBiaWdJbnRUb0hleGAgaW5zdGVhZC4nKTtcbiAgICByZXR1cm4gKDAsIGhleF8xLmFkZDB4KSh2YWx1ZS50b1N0cmluZygxNikpO1xufTtcbmV4cG9ydHMubnVtYmVyVG9IZXggPSBudW1iZXJUb0hleDtcbi8qKlxuICogQ29udmVydCBhIGBiaWdpbnRgIHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLiBUaGlzIHZlcmlmaWVzIHRoYXQgdGhlIGBiaWdpbnRgXG4gKiBpcyBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyLlxuICpcbiAqIFRvIGNvbnZlcnQgYSBudW1iZXIgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcgaW5zdGVhZCwgdXNlIHtAbGluayBudW1iZXJUb0hleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGJpZ0ludFRvSGV4KDBuKTsgLy8gJzB4MCdcbiAqIGJpZ0ludFRvSGV4KDFuKTsgLy8gJzB4MSdcbiAqIGJpZ0ludFRvSGV4KDE2bik7IC8vICcweDEwJ1xuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgYGJpZ2ludGAgdG8gY29udmVydCB0byBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcsIHdpdGggdGhlIFwiMHhcIi1wcmVmaXguXG4gKiBAdGhyb3dzIElmIHRoZSBgYmlnaW50YCBpcyBub3QgYSBub24tbmVnYXRpdmUgaW50ZWdlci5cbiAqL1xuY29uc3QgYmlnSW50VG9IZXggPSAodmFsdWUpID0+IHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnLCAnVmFsdWUgbXVzdCBiZSBhIGJpZ2ludC4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh2YWx1ZSA+PSAwLCAnVmFsdWUgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBiaWdpbnQuJyk7XG4gICAgcmV0dXJuICgwLCBoZXhfMS5hZGQweCkodmFsdWUudG9TdHJpbmcoMTYpKTtcbn07XG5leHBvcnRzLmJpZ0ludFRvSGV4ID0gYmlnSW50VG9IZXg7XG4vKipcbiAqIENvbnZlcnQgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYSBudW1iZXIuIFRoaXMgdmVyaWZpZXMgdGhhdCB0aGUgc3RyaW5nIGlzIGFcbiAqIHZhbGlkIGhleCBzdHJpbmcsIGFuZCB0aGF0IHRoZSByZXN1bHRpbmcgbnVtYmVyIGlzIGEgc2FmZSBpbnRlZ2VyLiBCb3RoXG4gKiBcIjB4XCItcHJlZml4ZWQgYW5kIHVucHJlZml4ZWQgc3RyaW5ncyBhcmUgc3VwcG9ydGVkLlxuICpcbiAqIFRvIGNvbnZlcnQgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYSBgYmlnaW50YCBpbnN0ZWFkLCB1c2VcbiAqIHtAbGluayBoZXhUb0JpZ0ludH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGhleFRvTnVtYmVyKCcweDAnKTsgLy8gMFxuICogaGV4VG9OdW1iZXIoJzB4MScpOyAvLyAxXG4gKiBoZXhUb051bWJlcignMHgxMCcpOyAvLyAxNlxuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGNvbnZlcnQgdG8gYSBudW1iZXIuXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgdmFsaWQgaGV4YWRlY2ltYWwgc3RyaW5nLCBvciBpZiB0aGUgcmVzdWx0aW5nXG4gKiBudW1iZXIgaXMgbm90IGEgc2FmZSBpbnRlZ2VyLlxuICovXG5jb25zdCBoZXhUb051bWJlciA9ICh2YWx1ZSkgPT4ge1xuICAgICgwLCBoZXhfMS5hc3NlcnRJc0hleFN0cmluZykodmFsdWUpO1xuICAgIC8vIGBwYXJzZUludGAgYWNjZXB0cyB2YWx1ZXMgd2l0aG91dCB0aGUgXCIweFwiLXByZWZpeCwgd2hlcmVhcyBgTnVtYmVyYCBkb2VzXG4gICAgLy8gbm90LiBVc2luZyB0aGlzIGlzIHNsaWdodGx5IGZhc3RlciB0aGFuIGBOdW1iZXIoYWRkMHgodmFsdWUpKWAuXG4gICAgY29uc3QgbnVtYmVyVmFsdWUgPSBwYXJzZUludCh2YWx1ZSwgMTYpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKE51bWJlci5pc1NhZmVJbnRlZ2VyKG51bWJlclZhbHVlKSwgJ1ZhbHVlIGlzIG5vdCBhIHNhZmUgaW50ZWdlci4gVXNlIGBoZXhUb0JpZ0ludGAgaW5zdGVhZC4nKTtcbiAgICByZXR1cm4gbnVtYmVyVmFsdWU7XG59O1xuZXhwb3J0cy5oZXhUb051bWJlciA9IGhleFRvTnVtYmVyO1xuLyoqXG4gKiBDb252ZXJ0IGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGEgYGJpZ2ludGAuIFRoaXMgdmVyaWZpZXMgdGhhdCB0aGUgc3RyaW5nIGlzXG4gKiBhIHZhbGlkIGhleCBzdHJpbmcuIEJvdGggXCIweFwiLXByZWZpeGVkIGFuZCB1bnByZWZpeGVkIHN0cmluZ3MgYXJlIHN1cHBvcnRlZC5cbiAqXG4gKiBUbyBjb252ZXJ0IGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGEgbnVtYmVyIGluc3RlYWQsIHVzZSB7QGxpbmsgaGV4VG9OdW1iZXJ9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBoZXhUb0JpZ0ludCgnMHgwJyk7IC8vIDBuXG4gKiBoZXhUb0JpZ0ludCgnMHgxJyk7IC8vIDFuXG4gKiBoZXhUb0JpZ0ludCgnMHgxMCcpOyAvLyAxNm5cbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byBjb252ZXJ0IHRvIGEgYGJpZ2ludGAuXG4gKiBAcmV0dXJucyBUaGUgYGJpZ2ludGAuXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSB2YWxpZCBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKi9cbmNvbnN0IGhleFRvQmlnSW50ID0gKHZhbHVlKSA9PiB7XG4gICAgKDAsIGhleF8xLmFzc2VydElzSGV4U3RyaW5nKSh2YWx1ZSk7XG4gICAgLy8gVGhlIGBCaWdJbnRgIGNvbnN0cnVjdG9yIHJlcXVpcmVzIHRoZSBcIjB4XCItcHJlZml4IHRvIHBhcnNlIGEgaGV4IHN0cmluZy5cbiAgICByZXR1cm4gQmlnSW50KCgwLCBoZXhfMS5hZGQweCkodmFsdWUpKTtcbn07XG5leHBvcnRzLmhleFRvQmlnSW50ID0gaGV4VG9CaWdJbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udW1iZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiaGV4VG9CaWdJbnQiLCJoZXhUb051bWJlciIsImJpZ0ludFRvSGV4IiwibnVtYmVyVG9IZXgiLCJhc3NlcnRfMSIsInJlcXVpcmUiLCJoZXhfMSIsImFzc2VydCIsIk51bWJlciIsImlzU2FmZUludGVnZXIiLCJhZGQweCIsInRvU3RyaW5nIiwiYXNzZXJ0SXNIZXhTdHJpbmciLCJudW1iZXJWYWx1ZSIsInBhcnNlSW50IiwiQmlnSW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/number.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/opaque.js":
/*!************************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/opaque.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n})); //# sourceMappingURL=opaque.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L29wYXF1ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQyxFQUM3RCxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac2UtMi9uZXh0anMvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L29wYXF1ZS5qcz80YmIyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3BhcXVlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/opaque.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/time.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/time.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.timeSince = exports.inMilliseconds = exports.Duration = void 0;\n/**\n * Common duration constants, in milliseconds.\n */ var Duration;\n(function(Duration) {\n    /**\n     * A millisecond.\n     */ Duration[Duration[\"Millisecond\"] = 1] = \"Millisecond\";\n    /**\n     * A second, in milliseconds.\n     */ Duration[Duration[\"Second\"] = 1000] = \"Second\";\n    /**\n     * A minute, in milliseconds.\n     */ Duration[Duration[\"Minute\"] = 60000] = \"Minute\";\n    /**\n     * An hour, in milliseconds.\n     */ Duration[Duration[\"Hour\"] = 3600000] = \"Hour\";\n    /**\n     * A day, in milliseconds.\n     */ Duration[Duration[\"Day\"] = 86400000] = \"Day\";\n    /**\n     * A week, in milliseconds.\n     */ Duration[Duration[\"Week\"] = 604800000] = \"Week\";\n    /**\n     * A year, in milliseconds.\n     */ Duration[Duration[\"Year\"] = 31536000000] = \"Year\";\n})(Duration = exports.Duration || (exports.Duration = {}));\nconst isNonNegativeInteger = (number)=>Number.isInteger(number) && number >= 0;\nconst assertIsNonNegativeInteger = (number, name)=>{\n    if (!isNonNegativeInteger(number)) {\n        throw new Error(`\"${name}\" must be a non-negative integer. Received: \"${number}\".`);\n    }\n};\n/**\n * Calculates the millisecond value of the specified number of units of time.\n *\n * @param count - The number of units of time.\n * @param duration - The unit of time to count.\n * @returns The count multiplied by the specified duration.\n */ function inMilliseconds(count, duration) {\n    assertIsNonNegativeInteger(count, \"count\");\n    return count * duration;\n}\nexports.inMilliseconds = inMilliseconds;\n/**\n * Gets the milliseconds since a particular Unix epoch timestamp.\n *\n * @param timestamp - A Unix millisecond timestamp.\n * @returns The number of milliseconds elapsed since the specified timestamp.\n */ function timeSince(timestamp) {\n    assertIsNonNegativeInteger(timestamp, \"timestamp\");\n    return Date.now() - timestamp;\n}\nexports.timeSince = timeSince; //# sourceMappingURL=time.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3RpbWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGlCQUFpQixHQUFHQSxzQkFBc0IsR0FBR0EsZ0JBQWdCLEdBQUcsS0FBSztBQUNyRTs7Q0FFQyxHQUNELElBQUlJO0FBQ0gsVUFBVUEsUUFBUTtJQUNmOztLQUVDLEdBQ0RBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLGNBQWMsR0FBRyxFQUFFLEdBQUc7SUFDeEM7O0tBRUMsR0FDREEsUUFBUSxDQUFDQSxRQUFRLENBQUMsU0FBUyxHQUFHLEtBQUssR0FBRztJQUN0Qzs7S0FFQyxHQUNEQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxTQUFTLEdBQUcsTUFBTSxHQUFHO0lBQ3ZDOztLQUVDLEdBQ0RBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLE9BQU8sR0FBRyxRQUFRLEdBQUc7SUFDdkM7O0tBRUMsR0FDREEsUUFBUSxDQUFDQSxRQUFRLENBQUMsTUFBTSxHQUFHLFNBQVMsR0FBRztJQUN2Qzs7S0FFQyxHQUNEQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxPQUFPLEdBQUcsVUFBVSxHQUFHO0lBQ3pDOztLQUVDLEdBQ0RBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLE9BQU8sR0FBRyxZQUFZLEdBQUc7QUFDL0MsR0FBR0EsV0FBV0osUUFBUUksUUFBUSxJQUFLSixDQUFBQSxnQkFBZ0IsR0FBRyxDQUFDO0FBQ3ZELE1BQU1LLHVCQUF1QixDQUFDQyxTQUFXQyxPQUFPQyxTQUFTLENBQUNGLFdBQVdBLFVBQVU7QUFDL0UsTUFBTUcsNkJBQTZCLENBQUNILFFBQVFJO0lBQ3hDLElBQUksQ0FBQ0wscUJBQXFCQyxTQUFTO1FBQy9CLE1BQU0sSUFBSUssTUFBTSxDQUFDLENBQUMsRUFBRUQsS0FBSyw2Q0FBNkMsRUFBRUosT0FBTyxFQUFFLENBQUM7SUFDdEY7QUFDSjtBQUNBOzs7Ozs7Q0FNQyxHQUNELFNBQVNILGVBQWVTLEtBQUssRUFBRUMsUUFBUTtJQUNuQ0osMkJBQTJCRyxPQUFPO0lBQ2xDLE9BQU9BLFFBQVFDO0FBQ25CO0FBQ0FiLHNCQUFzQixHQUFHRztBQUN6Qjs7Ozs7Q0FLQyxHQUNELFNBQVNELFVBQVVZLFNBQVM7SUFDeEJMLDJCQUEyQkssV0FBVztJQUN0QyxPQUFPQyxLQUFLQyxHQUFHLEtBQUtGO0FBQ3hCO0FBQ0FkLGlCQUFpQixHQUFHRSxXQUNwQixnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac2UtMi9uZXh0anMvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3RpbWUuanM/MDFhZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudGltZVNpbmNlID0gZXhwb3J0cy5pbk1pbGxpc2Vjb25kcyA9IGV4cG9ydHMuRHVyYXRpb24gPSB2b2lkIDA7XG4vKipcbiAqIENvbW1vbiBkdXJhdGlvbiBjb25zdGFudHMsIGluIG1pbGxpc2Vjb25kcy5cbiAqL1xudmFyIER1cmF0aW9uO1xuKGZ1bmN0aW9uIChEdXJhdGlvbikge1xuICAgIC8qKlxuICAgICAqIEEgbWlsbGlzZWNvbmQuXG4gICAgICovXG4gICAgRHVyYXRpb25bRHVyYXRpb25bXCJNaWxsaXNlY29uZFwiXSA9IDFdID0gXCJNaWxsaXNlY29uZFwiO1xuICAgIC8qKlxuICAgICAqIEEgc2Vjb25kLCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgRHVyYXRpb25bRHVyYXRpb25bXCJTZWNvbmRcIl0gPSAxMDAwXSA9IFwiU2Vjb25kXCI7XG4gICAgLyoqXG4gICAgICogQSBtaW51dGUsIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICBEdXJhdGlvbltEdXJhdGlvbltcIk1pbnV0ZVwiXSA9IDYwMDAwXSA9IFwiTWludXRlXCI7XG4gICAgLyoqXG4gICAgICogQW4gaG91ciwgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqL1xuICAgIER1cmF0aW9uW0R1cmF0aW9uW1wiSG91clwiXSA9IDM2MDAwMDBdID0gXCJIb3VyXCI7XG4gICAgLyoqXG4gICAgICogQSBkYXksIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICBEdXJhdGlvbltEdXJhdGlvbltcIkRheVwiXSA9IDg2NDAwMDAwXSA9IFwiRGF5XCI7XG4gICAgLyoqXG4gICAgICogQSB3ZWVrLCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgRHVyYXRpb25bRHVyYXRpb25bXCJXZWVrXCJdID0gNjA0ODAwMDAwXSA9IFwiV2Vla1wiO1xuICAgIC8qKlxuICAgICAqIEEgeWVhciwgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqL1xuICAgIER1cmF0aW9uW0R1cmF0aW9uW1wiWWVhclwiXSA9IDMxNTM2MDAwMDAwXSA9IFwiWWVhclwiO1xufSkoRHVyYXRpb24gPSBleHBvcnRzLkR1cmF0aW9uIHx8IChleHBvcnRzLkR1cmF0aW9uID0ge30pKTtcbmNvbnN0IGlzTm9uTmVnYXRpdmVJbnRlZ2VyID0gKG51bWJlcikgPT4gTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpICYmIG51bWJlciA+PSAwO1xuY29uc3QgYXNzZXJ0SXNOb25OZWdhdGl2ZUludGVnZXIgPSAobnVtYmVyLCBuYW1lKSA9PiB7XG4gICAgaWYgKCFpc05vbk5lZ2F0aXZlSW50ZWdlcihudW1iZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke25hbWV9XCIgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyLiBSZWNlaXZlZDogXCIke251bWJlcn1cIi5gKTtcbiAgICB9XG59O1xuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBtaWxsaXNlY29uZCB2YWx1ZSBvZiB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiB1bml0cyBvZiB0aW1lLlxuICpcbiAqIEBwYXJhbSBjb3VudCAtIFRoZSBudW1iZXIgb2YgdW5pdHMgb2YgdGltZS5cbiAqIEBwYXJhbSBkdXJhdGlvbiAtIFRoZSB1bml0IG9mIHRpbWUgdG8gY291bnQuXG4gKiBAcmV0dXJucyBUaGUgY291bnQgbXVsdGlwbGllZCBieSB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uLlxuICovXG5mdW5jdGlvbiBpbk1pbGxpc2Vjb25kcyhjb3VudCwgZHVyYXRpb24pIHtcbiAgICBhc3NlcnRJc05vbk5lZ2F0aXZlSW50ZWdlcihjb3VudCwgJ2NvdW50Jyk7XG4gICAgcmV0dXJuIGNvdW50ICogZHVyYXRpb247XG59XG5leHBvcnRzLmluTWlsbGlzZWNvbmRzID0gaW5NaWxsaXNlY29uZHM7XG4vKipcbiAqIEdldHMgdGhlIG1pbGxpc2Vjb25kcyBzaW5jZSBhIHBhcnRpY3VsYXIgVW5peCBlcG9jaCB0aW1lc3RhbXAuXG4gKlxuICogQHBhcmFtIHRpbWVzdGFtcCAtIEEgVW5peCBtaWxsaXNlY29uZCB0aW1lc3RhbXAuXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBlbGFwc2VkIHNpbmNlIHRoZSBzcGVjaWZpZWQgdGltZXN0YW1wLlxuICovXG5mdW5jdGlvbiB0aW1lU2luY2UodGltZXN0YW1wKSB7XG4gICAgYXNzZXJ0SXNOb25OZWdhdGl2ZUludGVnZXIodGltZXN0YW1wLCAndGltZXN0YW1wJyk7XG4gICAgcmV0dXJuIERhdGUubm93KCkgLSB0aW1lc3RhbXA7XG59XG5leHBvcnRzLnRpbWVTaW5jZSA9IHRpbWVTaW5jZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbWUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidGltZVNpbmNlIiwiaW5NaWxsaXNlY29uZHMiLCJEdXJhdGlvbiIsImlzTm9uTmVnYXRpdmVJbnRlZ2VyIiwibnVtYmVyIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiYXNzZXJ0SXNOb25OZWdhdGl2ZUludGVnZXIiLCJuYW1lIiwiRXJyb3IiLCJjb3VudCIsImR1cmF0aW9uIiwidGltZXN0YW1wIiwiRGF0ZSIsIm5vdyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/time.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/transaction-types.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/transaction-types.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n})); //# sourceMappingURL=transaction-types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3RyYW5zYWN0aW9uLXR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDLEVBQzdELDZDQUE2QyIsInNvdXJjZXMiOlsid2VicGFjazovL0BzZS0yL25leHRqcy8uL25vZGVfbW9kdWxlcy9ldGgtYmxvY2stdHJhY2tlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvdHJhbnNhY3Rpb24tdHlwZXMuanM/MjIzMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zYWN0aW9uLXR5cGVzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/transaction-types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/versions.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/versions.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.satisfiesVersionRange = exports.gtRange = exports.gtVersion = exports.assertIsSemVerRange = exports.assertIsSemVerVersion = exports.isValidSemVerRange = exports.isValidSemVerVersion = exports.VersionRangeStruct = exports.VersionStruct = void 0;\nconst semver_1 = __webpack_require__(/*! semver */ \"(ssr)/./node_modules/semver/index.js\");\nconst superstruct_1 = __webpack_require__(/*! superstruct */ \"(ssr)/./node_modules/superstruct/dist/index.mjs\");\nconst assert_1 = __webpack_require__(/*! ./assert */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/assert.js\");\n/**\n * A struct for validating a version string.\n */ exports.VersionStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), \"Version\", (value)=>{\n    if ((0, semver_1.valid)(value) === null) {\n        return `Expected SemVer version, got \"${value}\"`;\n    }\n    return true;\n});\nexports.VersionRangeStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), \"Version range\", (value)=>{\n    if ((0, semver_1.validRange)(value) === null) {\n        return `Expected SemVer range, got \"${value}\"`;\n    }\n    return true;\n});\n/**\n * Checks whether a SemVer version is valid.\n *\n * @param version - A potential version.\n * @returns `true` if the version is valid, and `false` otherwise.\n */ function isValidSemVerVersion(version) {\n    return (0, superstruct_1.is)(version, exports.VersionStruct);\n}\nexports.isValidSemVerVersion = isValidSemVerVersion;\n/**\n * Checks whether a SemVer version range is valid.\n *\n * @param versionRange - A potential version range.\n * @returns `true` if the version range is valid, and `false` otherwise.\n */ function isValidSemVerRange(versionRange) {\n    return (0, superstruct_1.is)(versionRange, exports.VersionRangeStruct);\n}\nexports.isValidSemVerRange = isValidSemVerRange;\n/**\n * Asserts that a value is a valid concrete SemVer version.\n *\n * @param version - A potential SemVer concrete version.\n */ function assertIsSemVerVersion(version) {\n    (0, assert_1.assertStruct)(version, exports.VersionStruct);\n}\nexports.assertIsSemVerVersion = assertIsSemVerVersion;\n/**\n * Asserts that a value is a valid SemVer range.\n *\n * @param range - A potential SemVer range.\n */ function assertIsSemVerRange(range) {\n    (0, assert_1.assertStruct)(range, exports.VersionRangeStruct);\n}\nexports.assertIsSemVerRange = assertIsSemVerRange;\n/**\n * Checks whether a SemVer version is greater than another.\n *\n * @param version1 - The left-hand version.\n * @param version2 - The right-hand version.\n * @returns `version1 > version2`.\n */ function gtVersion(version1, version2) {\n    return (0, semver_1.gt)(version1, version2);\n}\nexports.gtVersion = gtVersion;\n/**\n * Checks whether a SemVer version is greater than all possibilities in a range.\n *\n * @param version - A SemvVer version.\n * @param range - The range to check against.\n * @returns `version > range`.\n */ function gtRange(version, range) {\n    return (0, semver_1.gtr)(version, range);\n}\nexports.gtRange = gtRange;\n/**\n * Returns whether a SemVer version satisfies a SemVer range.\n *\n * @param version - The SemVer version to check.\n * @param versionRange - The SemVer version range to check against.\n * @returns Whether the version satisfied the version range.\n */ function satisfiesVersionRange(version, versionRange) {\n    return (0, semver_1.satisfies)(version, versionRange, {\n        includePrerelease: true\n    });\n}\nexports.satisfiesVersionRange = satisfiesVersionRange; //# sourceMappingURL=versions.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3ZlcnNpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCw2QkFBNkIsR0FBR0EsZUFBZSxHQUFHQSxpQkFBaUIsR0FBR0EsMkJBQTJCLEdBQUdBLDZCQUE2QixHQUFHQSwwQkFBMEIsR0FBR0EsNEJBQTRCLEdBQUdBLDBCQUEwQixHQUFHQSxxQkFBcUIsR0FBRyxLQUFLO0FBQzFQLE1BQU1XLFdBQVdDLG1CQUFPQSxDQUFDLG9EQUFRO0FBQ2pDLE1BQU1DLGdCQUFnQkQsbUJBQU9BLENBQUMsb0VBQWE7QUFDM0MsTUFBTUUsV0FBV0YsbUJBQU9BLENBQUMsb0dBQVU7QUFDbkM7O0NBRUMsR0FDRFoscUJBQXFCLEdBQUcsQ0FBQyxHQUFHYSxjQUFjRSxNQUFNLEVBQUUsQ0FBQyxHQUFHRixjQUFjRyxNQUFNLEtBQUssV0FBVyxDQUFDZjtJQUN2RixJQUFJLENBQUMsR0FBR1UsU0FBU00sS0FBSyxFQUFFaEIsV0FBVyxNQUFNO1FBQ3JDLE9BQU8sQ0FBQyw4QkFBOEIsRUFBRUEsTUFBTSxDQUFDLENBQUM7SUFDcEQ7SUFDQSxPQUFPO0FBQ1g7QUFDQUQsMEJBQTBCLEdBQUcsQ0FBQyxHQUFHYSxjQUFjRSxNQUFNLEVBQUUsQ0FBQyxHQUFHRixjQUFjRyxNQUFNLEtBQUssaUJBQWlCLENBQUNmO0lBQ2xHLElBQUksQ0FBQyxHQUFHVSxTQUFTTyxVQUFVLEVBQUVqQixXQUFXLE1BQU07UUFDMUMsT0FBTyxDQUFDLDRCQUE0QixFQUFFQSxNQUFNLENBQUMsQ0FBQztJQUNsRDtJQUNBLE9BQU87QUFDWDtBQUNBOzs7OztDQUtDLEdBQ0QsU0FBU08scUJBQXFCVyxPQUFPO0lBQ2pDLE9BQU8sQ0FBQyxHQUFHTixjQUFjTyxFQUFFLEVBQUVELFNBQVNuQixRQUFRVSxhQUFhO0FBQy9EO0FBQ0FWLDRCQUE0QixHQUFHUTtBQUMvQjs7Ozs7Q0FLQyxHQUNELFNBQVNELG1CQUFtQmMsWUFBWTtJQUNwQyxPQUFPLENBQUMsR0FBR1IsY0FBY08sRUFBRSxFQUFFQyxjQUFjckIsUUFBUVMsa0JBQWtCO0FBQ3pFO0FBQ0FULDBCQUEwQixHQUFHTztBQUM3Qjs7OztDQUlDLEdBQ0QsU0FBU0Qsc0JBQXNCYSxPQUFPO0lBQ2pDLElBQUdMLFNBQVNRLFlBQVksRUFBRUgsU0FBU25CLFFBQVFVLGFBQWE7QUFDN0Q7QUFDQVYsNkJBQTZCLEdBQUdNO0FBQ2hDOzs7O0NBSUMsR0FDRCxTQUFTRCxvQkFBb0JrQixLQUFLO0lBQzdCLElBQUdULFNBQVNRLFlBQVksRUFBRUMsT0FBT3ZCLFFBQVFTLGtCQUFrQjtBQUNoRTtBQUNBVCwyQkFBMkIsR0FBR0s7QUFDOUI7Ozs7OztDQU1DLEdBQ0QsU0FBU0QsVUFBVW9CLFFBQVEsRUFBRUMsUUFBUTtJQUNqQyxPQUFPLENBQUMsR0FBR2QsU0FBU2UsRUFBRSxFQUFFRixVQUFVQztBQUN0QztBQUNBekIsaUJBQWlCLEdBQUdJO0FBQ3BCOzs7Ozs7Q0FNQyxHQUNELFNBQVNELFFBQVFnQixPQUFPLEVBQUVJLEtBQUs7SUFDM0IsT0FBTyxDQUFDLEdBQUdaLFNBQVNnQixHQUFHLEVBQUVSLFNBQVNJO0FBQ3RDO0FBQ0F2QixlQUFlLEdBQUdHO0FBQ2xCOzs7Ozs7Q0FNQyxHQUNELFNBQVNELHNCQUFzQmlCLE9BQU8sRUFBRUUsWUFBWTtJQUNoRCxPQUFPLENBQUMsR0FBR1YsU0FBU2lCLFNBQVMsRUFBRVQsU0FBU0UsY0FBYztRQUNsRFEsbUJBQW1CO0lBQ3ZCO0FBQ0o7QUFDQTdCLDZCQUE2QixHQUFHRSx1QkFDaEMsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHNlLTIvbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2V0aC1ibG9jay10cmFja2VyL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC92ZXJzaW9ucy5qcz8wODE1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zYXRpc2ZpZXNWZXJzaW9uUmFuZ2UgPSBleHBvcnRzLmd0UmFuZ2UgPSBleHBvcnRzLmd0VmVyc2lvbiA9IGV4cG9ydHMuYXNzZXJ0SXNTZW1WZXJSYW5nZSA9IGV4cG9ydHMuYXNzZXJ0SXNTZW1WZXJWZXJzaW9uID0gZXhwb3J0cy5pc1ZhbGlkU2VtVmVyUmFuZ2UgPSBleHBvcnRzLmlzVmFsaWRTZW1WZXJWZXJzaW9uID0gZXhwb3J0cy5WZXJzaW9uUmFuZ2VTdHJ1Y3QgPSBleHBvcnRzLlZlcnNpb25TdHJ1Y3QgPSB2b2lkIDA7XG5jb25zdCBzZW12ZXJfMSA9IHJlcXVpcmUoXCJzZW12ZXJcIik7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcInN1cGVyc3RydWN0XCIpO1xuY29uc3QgYXNzZXJ0XzEgPSByZXF1aXJlKFwiLi9hc3NlcnRcIik7XG4vKipcbiAqIEEgc3RydWN0IGZvciB2YWxpZGF0aW5nIGEgdmVyc2lvbiBzdHJpbmcuXG4gKi9cbmV4cG9ydHMuVmVyc2lvblN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnJlZmluZSkoKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCAnVmVyc2lvbicsICh2YWx1ZSkgPT4ge1xuICAgIGlmICgoMCwgc2VtdmVyXzEudmFsaWQpKHZhbHVlKSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYEV4cGVjdGVkIFNlbVZlciB2ZXJzaW9uLCBnb3QgXCIke3ZhbHVlfVwiYDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbmV4cG9ydHMuVmVyc2lvblJhbmdlU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEucmVmaW5lKSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksICdWZXJzaW9uIHJhbmdlJywgKHZhbHVlKSA9PiB7XG4gICAgaWYgKCgwLCBzZW12ZXJfMS52YWxpZFJhbmdlKSh2YWx1ZSkgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGBFeHBlY3RlZCBTZW1WZXIgcmFuZ2UsIGdvdCBcIiR7dmFsdWV9XCJgO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIFNlbVZlciB2ZXJzaW9uIGlzIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uIC0gQSBwb3RlbnRpYWwgdmVyc2lvbi5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmVyc2lvbiBpcyB2YWxpZCwgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkU2VtVmVyVmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2ZXJzaW9uLCBleHBvcnRzLlZlcnNpb25TdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc1ZhbGlkU2VtVmVyVmVyc2lvbiA9IGlzVmFsaWRTZW1WZXJWZXJzaW9uO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIFNlbVZlciB2ZXJzaW9uIHJhbmdlIGlzIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uUmFuZ2UgLSBBIHBvdGVudGlhbCB2ZXJzaW9uIHJhbmdlLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2ZXJzaW9uIHJhbmdlIGlzIHZhbGlkLCBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRTZW1WZXJSYW5nZSh2ZXJzaW9uUmFuZ2UpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZlcnNpb25SYW5nZSwgZXhwb3J0cy5WZXJzaW9uUmFuZ2VTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc1ZhbGlkU2VtVmVyUmFuZ2UgPSBpc1ZhbGlkU2VtVmVyUmFuZ2U7XG4vKipcbiAqIEFzc2VydHMgdGhhdCBhIHZhbHVlIGlzIGEgdmFsaWQgY29uY3JldGUgU2VtVmVyIHZlcnNpb24uXG4gKlxuICogQHBhcmFtIHZlcnNpb24gLSBBIHBvdGVudGlhbCBTZW1WZXIgY29uY3JldGUgdmVyc2lvbi5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNTZW1WZXJWZXJzaW9uKHZlcnNpb24pIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2ZXJzaW9uLCBleHBvcnRzLlZlcnNpb25TdHJ1Y3QpO1xufVxuZXhwb3J0cy5hc3NlcnRJc1NlbVZlclZlcnNpb24gPSBhc3NlcnRJc1NlbVZlclZlcnNpb247XG4vKipcbiAqIEFzc2VydHMgdGhhdCBhIHZhbHVlIGlzIGEgdmFsaWQgU2VtVmVyIHJhbmdlLlxuICpcbiAqIEBwYXJhbSByYW5nZSAtIEEgcG90ZW50aWFsIFNlbVZlciByYW5nZS5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNTZW1WZXJSYW5nZShyYW5nZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHJhbmdlLCBleHBvcnRzLlZlcnNpb25SYW5nZVN0cnVjdCk7XG59XG5leHBvcnRzLmFzc2VydElzU2VtVmVyUmFuZ2UgPSBhc3NlcnRJc1NlbVZlclJhbmdlO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIFNlbVZlciB2ZXJzaW9uIGlzIGdyZWF0ZXIgdGhhbiBhbm90aGVyLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uMSAtIFRoZSBsZWZ0LWhhbmQgdmVyc2lvbi5cbiAqIEBwYXJhbSB2ZXJzaW9uMiAtIFRoZSByaWdodC1oYW5kIHZlcnNpb24uXG4gKiBAcmV0dXJucyBgdmVyc2lvbjEgPiB2ZXJzaW9uMmAuXG4gKi9cbmZ1bmN0aW9uIGd0VmVyc2lvbih2ZXJzaW9uMSwgdmVyc2lvbjIpIHtcbiAgICByZXR1cm4gKDAsIHNlbXZlcl8xLmd0KSh2ZXJzaW9uMSwgdmVyc2lvbjIpO1xufVxuZXhwb3J0cy5ndFZlcnNpb24gPSBndFZlcnNpb247XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgU2VtVmVyIHZlcnNpb24gaXMgZ3JlYXRlciB0aGFuIGFsbCBwb3NzaWJpbGl0aWVzIGluIGEgcmFuZ2UuXG4gKlxuICogQHBhcmFtIHZlcnNpb24gLSBBIFNlbXZWZXIgdmVyc2lvbi5cbiAqIEBwYXJhbSByYW5nZSAtIFRoZSByYW5nZSB0byBjaGVjayBhZ2FpbnN0LlxuICogQHJldHVybnMgYHZlcnNpb24gPiByYW5nZWAuXG4gKi9cbmZ1bmN0aW9uIGd0UmFuZ2UodmVyc2lvbiwgcmFuZ2UpIHtcbiAgICByZXR1cm4gKDAsIHNlbXZlcl8xLmd0cikodmVyc2lvbiwgcmFuZ2UpO1xufVxuZXhwb3J0cy5ndFJhbmdlID0gZ3RSYW5nZTtcbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIGEgU2VtVmVyIHZlcnNpb24gc2F0aXNmaWVzIGEgU2VtVmVyIHJhbmdlLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uIC0gVGhlIFNlbVZlciB2ZXJzaW9uIHRvIGNoZWNrLlxuICogQHBhcmFtIHZlcnNpb25SYW5nZSAtIFRoZSBTZW1WZXIgdmVyc2lvbiByYW5nZSB0byBjaGVjayBhZ2FpbnN0LlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmVyc2lvbiBzYXRpc2ZpZWQgdGhlIHZlcnNpb24gcmFuZ2UuXG4gKi9cbmZ1bmN0aW9uIHNhdGlzZmllc1ZlcnNpb25SYW5nZSh2ZXJzaW9uLCB2ZXJzaW9uUmFuZ2UpIHtcbiAgICByZXR1cm4gKDAsIHNlbXZlcl8xLnNhdGlzZmllcykodmVyc2lvbiwgdmVyc2lvblJhbmdlLCB7XG4gICAgICAgIGluY2x1ZGVQcmVyZWxlYXNlOiB0cnVlLFxuICAgIH0pO1xufVxuZXhwb3J0cy5zYXRpc2ZpZXNWZXJzaW9uUmFuZ2UgPSBzYXRpc2ZpZXNWZXJzaW9uUmFuZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9ucy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJzYXRpc2ZpZXNWZXJzaW9uUmFuZ2UiLCJndFJhbmdlIiwiZ3RWZXJzaW9uIiwiYXNzZXJ0SXNTZW1WZXJSYW5nZSIsImFzc2VydElzU2VtVmVyVmVyc2lvbiIsImlzVmFsaWRTZW1WZXJSYW5nZSIsImlzVmFsaWRTZW1WZXJWZXJzaW9uIiwiVmVyc2lvblJhbmdlU3RydWN0IiwiVmVyc2lvblN0cnVjdCIsInNlbXZlcl8xIiwicmVxdWlyZSIsInN1cGVyc3RydWN0XzEiLCJhc3NlcnRfMSIsInJlZmluZSIsInN0cmluZyIsInZhbGlkIiwidmFsaWRSYW5nZSIsInZlcnNpb24iLCJpcyIsInZlcnNpb25SYW5nZSIsImFzc2VydFN0cnVjdCIsInJhbmdlIiwidmVyc2lvbjEiLCJ2ZXJzaW9uMiIsImd0IiwiZ3RyIiwic2F0aXNmaWVzIiwiaW5jbHVkZVByZXJlbGVhc2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/versions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/pify/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/pify/index.js ***!
  \*******************************************************************/
/***/ ((module) => {

eval("\nconst processFn = (fn, opts)=>function() {\n        const P = opts.promiseModule;\n        const args = new Array(arguments.length);\n        for(let i = 0; i < arguments.length; i++){\n            args[i] = arguments[i];\n        }\n        return new P((resolve, reject)=>{\n            if (opts.errorFirst) {\n                args.push(function(err, result) {\n                    if (opts.multiArgs) {\n                        const results = new Array(arguments.length - 1);\n                        for(let i = 1; i < arguments.length; i++){\n                            results[i - 1] = arguments[i];\n                        }\n                        if (err) {\n                            results.unshift(err);\n                            reject(results);\n                        } else {\n                            resolve(results);\n                        }\n                    } else if (err) {\n                        reject(err);\n                    } else {\n                        resolve(result);\n                    }\n                });\n            } else {\n                args.push(function(result) {\n                    if (opts.multiArgs) {\n                        const results = new Array(arguments.length - 1);\n                        for(let i = 0; i < arguments.length; i++){\n                            results[i] = arguments[i];\n                        }\n                        resolve(results);\n                    } else {\n                        resolve(result);\n                    }\n                });\n            }\n            fn.apply(this, args);\n        });\n    };\nmodule.exports = (obj, opts)=>{\n    opts = Object.assign({\n        exclude: [\n            /.+(Sync|Stream)$/\n        ],\n        errorFirst: true,\n        promiseModule: Promise\n    }, opts);\n    const filter = (key)=>{\n        const match = (pattern)=>typeof pattern === \"string\" ? key === pattern : pattern.test(key);\n        return opts.include ? opts.include.some(match) : !opts.exclude.some(match);\n    };\n    let ret;\n    if (typeof obj === \"function\") {\n        ret = function() {\n            if (opts.excludeMain) {\n                return obj.apply(this, arguments);\n            }\n            return processFn(obj, opts).apply(this, arguments);\n        };\n    } else {\n        ret = Object.create(Object.getPrototypeOf(obj));\n    }\n    for(const key in obj){\n        const x = obj[key];\n        ret[key] = typeof x === \"function\" && filter(key) ? processFn(x, opts) : x;\n    }\n    return ret;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3BpZnkvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxZQUFZLENBQUNDLElBQUlDLE9BQVM7UUFDL0IsTUFBTUMsSUFBSUQsS0FBS0UsYUFBYTtRQUM1QixNQUFNQyxPQUFPLElBQUlDLE1BQU1DLFVBQVVDLE1BQU07UUFFdkMsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLFVBQVVDLE1BQU0sRUFBRUMsSUFBSztZQUMxQ0osSUFBSSxDQUFDSSxFQUFFLEdBQUdGLFNBQVMsQ0FBQ0UsRUFBRTtRQUN2QjtRQUVBLE9BQU8sSUFBSU4sRUFBRSxDQUFDTyxTQUFTQztZQUN0QixJQUFJVCxLQUFLVSxVQUFVLEVBQUU7Z0JBQ3BCUCxLQUFLUSxJQUFJLENBQUMsU0FBVUMsR0FBRyxFQUFFQyxNQUFNO29CQUM5QixJQUFJYixLQUFLYyxTQUFTLEVBQUU7d0JBQ25CLE1BQU1DLFVBQVUsSUFBSVgsTUFBTUMsVUFBVUMsTUFBTSxHQUFHO3dCQUU3QyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUYsVUFBVUMsTUFBTSxFQUFFQyxJQUFLOzRCQUMxQ1EsT0FBTyxDQUFDUixJQUFJLEVBQUUsR0FBR0YsU0FBUyxDQUFDRSxFQUFFO3dCQUM5Qjt3QkFFQSxJQUFJSyxLQUFLOzRCQUNSRyxRQUFRQyxPQUFPLENBQUNKOzRCQUNoQkgsT0FBT007d0JBQ1IsT0FBTzs0QkFDTlAsUUFBUU87d0JBQ1Q7b0JBQ0QsT0FBTyxJQUFJSCxLQUFLO3dCQUNmSCxPQUFPRztvQkFDUixPQUFPO3dCQUNOSixRQUFRSztvQkFDVDtnQkFDRDtZQUNELE9BQU87Z0JBQ05WLEtBQUtRLElBQUksQ0FBQyxTQUFVRSxNQUFNO29CQUN6QixJQUFJYixLQUFLYyxTQUFTLEVBQUU7d0JBQ25CLE1BQU1DLFVBQVUsSUFBSVgsTUFBTUMsVUFBVUMsTUFBTSxHQUFHO3dCQUU3QyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUYsVUFBVUMsTUFBTSxFQUFFQyxJQUFLOzRCQUMxQ1EsT0FBTyxDQUFDUixFQUFFLEdBQUdGLFNBQVMsQ0FBQ0UsRUFBRTt3QkFDMUI7d0JBRUFDLFFBQVFPO29CQUNULE9BQU87d0JBQ05QLFFBQVFLO29CQUNUO2dCQUNEO1lBQ0Q7WUFFQWQsR0FBR2tCLEtBQUssQ0FBQyxJQUFJLEVBQUVkO1FBQ2hCO0lBQ0Q7QUFFQWUsT0FBT0MsT0FBTyxHQUFHLENBQUNDLEtBQUtwQjtJQUN0QkEsT0FBT3FCLE9BQU9DLE1BQU0sQ0FBQztRQUNwQkMsU0FBUztZQUFDO1NBQW1CO1FBQzdCYixZQUFZO1FBQ1pSLGVBQWVzQjtJQUNoQixHQUFHeEI7SUFFSCxNQUFNeUIsU0FBU0MsQ0FBQUE7UUFDZCxNQUFNQyxRQUFRQyxDQUFBQSxVQUFXLE9BQU9BLFlBQVksV0FBV0YsUUFBUUUsVUFBVUEsUUFBUUMsSUFBSSxDQUFDSDtRQUN0RixPQUFPMUIsS0FBSzhCLE9BQU8sR0FBRzlCLEtBQUs4QixPQUFPLENBQUNDLElBQUksQ0FBQ0osU0FBUyxDQUFDM0IsS0FBS3VCLE9BQU8sQ0FBQ1EsSUFBSSxDQUFDSjtJQUNyRTtJQUVBLElBQUlLO0lBQ0osSUFBSSxPQUFPWixRQUFRLFlBQVk7UUFDOUJZLE1BQU07WUFDTCxJQUFJaEMsS0FBS2lDLFdBQVcsRUFBRTtnQkFDckIsT0FBT2IsSUFBSUgsS0FBSyxDQUFDLElBQUksRUFBRVo7WUFDeEI7WUFFQSxPQUFPUCxVQUFVc0IsS0FBS3BCLE1BQU1pQixLQUFLLENBQUMsSUFBSSxFQUFFWjtRQUN6QztJQUNELE9BQU87UUFDTjJCLE1BQU1YLE9BQU9hLE1BQU0sQ0FBQ2IsT0FBT2MsY0FBYyxDQUFDZjtJQUMzQztJQUVBLElBQUssTUFBTU0sT0FBT04sSUFBSztRQUN0QixNQUFNZ0IsSUFBSWhCLEdBQUcsQ0FBQ00sSUFBSTtRQUNsQk0sR0FBRyxDQUFDTixJQUFJLEdBQUcsT0FBT1UsTUFBTSxjQUFjWCxPQUFPQyxPQUFPNUIsVUFBVXNDLEdBQUdwQyxRQUFRb0M7SUFDMUU7SUFFQSxPQUFPSjtBQUNSIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHNlLTIvbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2V0aC1ibG9jay10cmFja2VyL25vZGVfbW9kdWxlcy9waWZ5L2luZGV4LmpzP2MxNWQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBwcm9jZXNzRm4gPSAoZm4sIG9wdHMpID0+IGZ1bmN0aW9uICgpIHtcblx0Y29uc3QgUCA9IG9wdHMucHJvbWlzZU1vZHVsZTtcblx0Y29uc3QgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcblxuXHRmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG5cdH1cblxuXHRyZXR1cm4gbmV3IFAoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdGlmIChvcHRzLmVycm9yRmlyc3QpIHtcblx0XHRcdGFyZ3MucHVzaChmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcblx0XHRcdFx0aWYgKG9wdHMubXVsdGlBcmdzKSB7XG5cdFx0XHRcdFx0Y29uc3QgcmVzdWx0cyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG5cblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0cmVzdWx0c1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGVycikge1xuXHRcdFx0XHRcdFx0cmVzdWx0cy51bnNoaWZ0KGVycik7XG5cdFx0XHRcdFx0XHRyZWplY3QocmVzdWx0cyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJlc29sdmUocmVzdWx0cyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGVycikge1xuXHRcdFx0XHRcdHJlamVjdChlcnIpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlc29sdmUocmVzdWx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFyZ3MucHVzaChmdW5jdGlvbiAocmVzdWx0KSB7XG5cdFx0XHRcdGlmIChvcHRzLm11bHRpQXJncykge1xuXHRcdFx0XHRcdGNvbnN0IHJlc3VsdHMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdHJlc3VsdHNbaV0gPSBhcmd1bWVudHNbaV07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmVzb2x2ZShyZXN1bHRzKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXNvbHZlKHJlc3VsdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHR9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gKG9iaiwgb3B0cykgPT4ge1xuXHRvcHRzID0gT2JqZWN0LmFzc2lnbih7XG5cdFx0ZXhjbHVkZTogWy8uKyhTeW5jfFN0cmVhbSkkL10sXG5cdFx0ZXJyb3JGaXJzdDogdHJ1ZSxcblx0XHRwcm9taXNlTW9kdWxlOiBQcm9taXNlXG5cdH0sIG9wdHMpO1xuXG5cdGNvbnN0IGZpbHRlciA9IGtleSA9PiB7XG5cdFx0Y29uc3QgbWF0Y2ggPSBwYXR0ZXJuID0+IHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJyA/IGtleSA9PT0gcGF0dGVybiA6IHBhdHRlcm4udGVzdChrZXkpO1xuXHRcdHJldHVybiBvcHRzLmluY2x1ZGUgPyBvcHRzLmluY2x1ZGUuc29tZShtYXRjaCkgOiAhb3B0cy5leGNsdWRlLnNvbWUobWF0Y2gpO1xuXHR9O1xuXG5cdGxldCByZXQ7XG5cdGlmICh0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0cmV0ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKG9wdHMuZXhjbHVkZU1haW4pIHtcblx0XHRcdFx0cmV0dXJuIG9iai5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcHJvY2Vzc0ZuKG9iaiwgb3B0cykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdHJldCA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikpO1xuXHR9XG5cblx0Zm9yIChjb25zdCBrZXkgaW4gb2JqKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZ3VhcmQtZm9yLWluXG5cdFx0Y29uc3QgeCA9IG9ialtrZXldO1xuXHRcdHJldFtrZXldID0gdHlwZW9mIHggPT09ICdmdW5jdGlvbicgJiYgZmlsdGVyKGtleSkgPyBwcm9jZXNzRm4oeCwgb3B0cykgOiB4O1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG4iXSwibmFtZXMiOlsicHJvY2Vzc0ZuIiwiZm4iLCJvcHRzIiwiUCIsInByb21pc2VNb2R1bGUiLCJhcmdzIiwiQXJyYXkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJpIiwicmVzb2x2ZSIsInJlamVjdCIsImVycm9yRmlyc3QiLCJwdXNoIiwiZXJyIiwicmVzdWx0IiwibXVsdGlBcmdzIiwicmVzdWx0cyIsInVuc2hpZnQiLCJhcHBseSIsIm1vZHVsZSIsImV4cG9ydHMiLCJvYmoiLCJPYmplY3QiLCJhc3NpZ24iLCJleGNsdWRlIiwiUHJvbWlzZSIsImZpbHRlciIsImtleSIsIm1hdGNoIiwicGF0dGVybiIsInRlc3QiLCJpbmNsdWRlIiwic29tZSIsInJldCIsImV4Y2x1ZGVNYWluIiwiY3JlYXRlIiwiZ2V0UHJvdG90eXBlT2YiLCJ4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/pify/index.js\n");

/***/ })

};
;