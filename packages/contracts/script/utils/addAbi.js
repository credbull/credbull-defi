const fs = require('fs');
const path = require('path');

const generatedContractComment = `
/**
 * This file is autogenerated by Scaffold-ETH.
 * You should not edit it manually or your changes might be overwritten.
 */
`;

function getDirectories(path) {
  return fs.readdirSync(path).filter((file) => fs.statSync(path + '/' + file).isDirectory());
}

function getFiles(path) {
  return fs.readdirSync(path).filter((file) => fs.statSync(path + '/' + file).isFile());
}

function getArtifactOfContract(contractName) {
  const current_path_to_artifacts = path.join(
    __dirname,
    '../..',
    ['SimpleToken', 'SimpleUSDC', 'SimpleVault', 'ERC1155MintableBurnable', 'SimpleTimelockAsyncUnlock'].includes(
      contractName,
    )
      ? `out/${contractName}.t.sol`
      : `out/${contractName}.sol`,
  );
  return JSON.parse(fs.readFileSync(`${current_path_to_artifacts}/${contractName}.json`));
}

function getInheritedFromContracts(artifact) {
  const inheritedFromContracts = [];
  if (artifact?.ast) {
    for (const astNode of artifact.ast.nodes) {
      if (astNode.nodeType == 'ContractDefinition' && astNode.baseContracts.length > 0) {
        inheritedFromContracts.push(...astNode.baseContracts.map(({ baseName }) => baseName.name));
      }
    }
  }
  return inheritedFromContracts;
}

function getInheritedFunctions(mainArtifact) {
  const inheritedFunctions = {};
  getInheritedFromContracts(mainArtifact).forEach((contractName) => {
    const {
      abi,
      ast: { absolutePath },
    } = getArtifactOfContract(contractName);
    abi.forEach((abiEntry) => {
      if (abiEntry.type === 'function') {
        inheritedFunctions[abiEntry.name] = absolutePath;
      }
    });
  });
  return inheritedFunctions;
}

function main() {
  const current_path_to_broadcast = path.join(__dirname, '../..', 'broadcast/DeployAndLoadLiquidMultiTokenVault.s.sol');
  const current_path_to_deployments = path.join(__dirname, '../..', 'broadcast');
  const chains = getDirectories(current_path_to_broadcast);
  const Deploymentchains = getFiles(current_path_to_deployments);
  const deployments = {};
  const allGeneratedContracts = {};

  Deploymentchains.forEach((chain) => {
    if (!chain.endsWith('.json')) return;
    const chainName = chain.slice(0, -5);
    deployments[chainName] = JSON.parse(fs.readFileSync(`${current_path_to_deployments}/${chain}.json`));
  });

  chains.forEach((chain) => {
    allGeneratedContracts[chain] = {};
    const broadCastObject = JSON.parse(fs.readFileSync(`${current_path_to_broadcast}/${chain}/run-latest.json`));
    const transactionsCreate = broadCastObject.transactions.filter(
      (transaction) => transaction.transactionType === 'CREATE',
    );
    const mapContractNames = {};
    const mapContracts = {};

    transactionsCreate.forEach((transaction) => {
      const contractName = transaction.contractName;
      const uniqueKey = `${contractName}#${mapContractNames[contractName] || 0}`;
      mapContracts[uniqueKey] = {
        num: mapContractNames[contractName] || 0,
        name: contractName,
        address: transaction.contractAddress,
      };
      mapContractNames[contractName] = (mapContractNames[contractName] || 0) + 1;
    });

    Object.values(mapContracts).forEach((contract) => {
      const artifact = getArtifactOfContract(contract.name);
      allGeneratedContracts[chain][`${contract.name}#${contract.num}`] = {
        address: contract.address,
        abi: artifact.abi,
        inheritedFunctions: getInheritedFunctions(artifact),
      };
    });
  });

  const TARGET_DIR = '../../spikes/spike-liquid-stone/packages/nextjs/contracts/';
  const TARGET_FILE = path.join(TARGET_DIR, 'deployedContracts.ts');

  // Read existing file content if it exists
  let existingContracts = {};
  if (fs.existsSync(TARGET_FILE)) {
    const existingContent = fs.readFileSync(TARGET_FILE, 'utf-8');
    const existingContractsMatch = existingContent.match(/const deployedContracts = ({[\s\S]*?}) as const;/);
    if (existingContractsMatch) {
      existingContracts = eval(`(${existingContractsMatch[1]})`); // Parse existing deployedContracts
    }
  }

  // Merge new contract data into existing contracts
  const mergedContracts = { ...existingContracts, ...allGeneratedContracts };

  // Prepare the final content
  const mergedContractsContent = Object.entries(mergedContracts).reduce((content, [chainId, chainConfig]) => {
    return `${content}  ${parseInt(chainId).toFixed(0)}: ${JSON.stringify(chainConfig, null, 2)},\n`;
  }, '');

  const newContent = `${generatedContractComment}
import { GenericContractsDeclaration } from "~~/utils/scaffold-eth/contract";

const deployedContracts = {
${mergedContractsContent}
} as const;

export default deployedContracts satisfies GenericContractsDeclaration;
`;

  // Ensure target directory exists
  if (!fs.existsSync(TARGET_DIR)) {
    fs.mkdirSync(TARGET_DIR);
  }

  // Write the final content back to the file
  fs.writeFileSync(TARGET_FILE, newContent);
}

try {
  main();
} catch (error) {
  console.error(error);
  process.exitCode = 1;
}
